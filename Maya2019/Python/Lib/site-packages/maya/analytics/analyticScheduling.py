"""
Check that the scheduling graph generated by the automated process is
equivalent to the graph generated by the dbpeek command.
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)

import re
import os
import maya.cmds as cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic
from maya.debug.emModeManager import emModeManager
from maya.debug.PlaybackManager import PlaybackManager

kAnalyticLabel = maya.stringTable['y_analyticScheduling.kAnalyticLabel' ]
kAnalyticDescriptionShort = maya.stringTable['y_analyticScheduling.kAnalyticDescriptionShort' ]

RE_EDGE = re.compile( r'^\s*"([^"]+)" -> "([^"]+)"' )
RE_NODE = re.compile( r'^\s*"([^"]+)"' )
BUILD = os.getenv( 'BUILD' )

OLD_ROOT = 'RootTask'
NEW_ROOT = '__SCHEDULING_ROOT__'

@addMethodDocs
@addHelp
@makeAnalytic(False)
class analyticScheduling(BaseAnalytic):
    """
    The normal output the output is a dictionary whose keys are the error types
    the values are the details of that error. There are only four:

        "scheduling" : {
            "nodeMissing" : "transform1",
            "nodeAdded"   : "transform2",
            "edgeMissing" : ["transform1", "transform2"],
            "edgeAdded"   : ["transform2", "group1"]
        }

    "Missing" means it existed in the original dump but not in the new one.
    "Added" means it did not exist in the original dump but does in the new one.
    """
    ANALYTIC_LABEL = kAnalyticLabel
    ANALYTIC_DESCRIPTION_SHORT = kAnalyticDescriptionShort

    def __init__(self):
        """
        Initialize the persistent class members
        """
        super(self.__class__, self).__init__()

    #----------------------------------------------------------------------
    def read_scheduling_file( self, file_name ):
        """
        Read the scheduling .dot file and extract the relevant information
        from it.

        :param file_name: Name of file containing JSON scheduling data
        :return: (nodes, edges) where:
            nodes: list of node names in the file
            edges: list of node pairs corresponding to edges in the file
        """
        nodes = []
        edges = []
        try:
            dot_fd = open(file_name, 'r')
            for line in dot_fd:
                edge_match = RE_EDGE.match( line )
                if edge_match:
                    src = edge_match.group(1)
                    dst = edge_match.group(2)
                    # Skip the root task connections, there's no old equivalent
                    if -1 == src.find(NEW_ROOT):
                        nodes.append( src )
                        nodes.append( dst )
                        edges.append( (src, dst) )
                else:
                    node_match = RE_NODE.match( line )
                    if node_match and (-1 == line.find(OLD_ROOT)) and (-1 == line.find(NEW_ROOT)):
                        nodes.append( node_match.group(1) )
        except KeyError:
            return None

        # The nodes were added through both edges and nodes so make the list unique first
        return (list(set(nodes)), edges)

    #----------------------------------------------------------------------
    def run(self):
        """
        Run the analytic on the current scene.
        Runs the EMP animation to generate the old scheduling graph dump,
        run the commands needed to generate the new dump, then compare
        the two to generate the results
        :result: JSON data as described in the class doc
        """
        json_data = { 'scheduling' : {
                        'nodesMissing' : [],
                        'nodesAdded'   : [],
                        'edgesMissing' : [],
                        'edgesAdded'   : []
                        }
                    }

        nodes_missing = json_data['scheduling']['nodesMissing']
        nodes_added   = json_data['scheduling']['nodesAdded']
        edges_missing = json_data['scheduling']['edgesMissing']
        edges_added   = json_data['scheduling']['edgesAdded']

        with emModeManager() as em_mgr, PlaybackManager() as play_mgr:
            em_mgr.setMode( 'emp' )
            em_mgr.rebuild( include_scheduling=True )
            play_mgr.play_limited_range( 3 )

            # Read the old file
            (old_nodes, old_edges) = self.read_scheduling_file( os.path.join(BUILD, '_MayaSchedulingGraph.dot') )

            # Generate the manual file
            dot_file = os.path.join(BUILD, 'SchedulingGraph.dot')
            cmds.dbpeek( op='graph', eg=True, a=['scheduling', 'dot'], all=True, of=dot_file )

            # Read the manual file
            (new_nodes, new_edges) = self.read_scheduling_file( dot_file )

            # Compare the two files
            for new_node in new_nodes:
                if new_node not in old_nodes:
                    nodes_added.append( new_node )

            for old_node in old_nodes:
                if old_node not in new_nodes:
                    nodes_missing.append( old_node )

            for new_edge in new_edges:
                if new_edge not in old_edges:
                    edges_added.append( new_edge )

            for old_edge in old_edges:
                if old_edge not in new_edges:
                    edges_missing.append( old_edge )

        return json_data

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
