import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Maya-specific utility tools (classes and method) for UI

These are utilities to interact with Maya UI.  They give basic building blocks
to wrap simple operations in easier-to-use tools.

These can be used inside Maya and MayaLT.
'''

import re
from functools import partial
import subprocess
import maya.cmds as cmds

__all__ = [
        'LayoutManager'             # Scoped access to nested field types
    ,   'showMessageBox'            # Simple interface to show a short message
    ,   'scrollableMessageBox'      # Simple interface to show a long message
    ,   'showConfirmationDialog'    # Simple interface for an ok/cancel question
    ,   'getClipboardData'          # Retrieve text from the clipboard
    ,   'setClipboardData'          # Set text onto the clipboard
    ,   'callback_wrapper'          # Wrap a callback in UI widget form
    ,   'callback_tool'             # Create a callback method in UI widget form, passing the 
    ,   'highlight_colour'          # Return the unified Maya highlight colour
    ]

# Fake clipboard, for passing tests when PySide is not present
FAKE_CLIPBOARD = None

#======================================================================
def callback_wrapper(*args, **kwargs):
    """
    This method is a wrapper in the form expected by UI elements.

    Its signature allows it to be flexible with regards to what UI elements
    expects.  Then it simply calls the given functor.

    :param args: Ignored
    :param kwargs: Keyword-based args, passed on to the callback function

    Sample use:
        reload_functor = partial(THE_RELOAD_CALLBACK_METHOD, reload_arg=SOME_RELOAD_ARGUMENT)
        reload_command = partial(callback_wrapper, functor=reload_functor)
        # calls "def THE_RELOAD_CALLBACK_METHOD(reload_arg):"
    """
    kwargs['functor']()

#======================================================================
def callback_tool(ui_tool, functor):
    '''
    This method returns a callback method that can be used by the UI
    elements.

    It wraps the "easier to define" callbacks that take the tool as
    an element into the callbacks that UI element expects.

    :param ui_tool: Object to pass as the first parameter "tool" to the callback function
    :param function: Functor object defining the rest of the function to be called

    Sample use:
        cmds.button( command=callback_tool(self, partial(SOME_FUNCTION, operation='operationParameter')) )
        # calls "def SOME_FUNCTION(tool, operation):"
    '''
    functor = partial(functor, tool=ui_tool)
    return partial(callback_wrapper, functor=functor)

#======================================================================
class LayoutManager(object):
    """
    This class is a simple manager that is responsible for returning to the
    parent layout when exiting.

    It should be used when layering several layouts to make it easier to track
    which layout is currently being populated.  It makes code easier to read by
    grouping all UI creation under a given layout within the same indentation
    level.
    """

    def __init__(self, name):
        """
        Simple constructor that just remembers the name of the given layout.
        """
        self.name = name

    def __enter__(self):
        """
        When entering the ``with`` statement, this object returns the
        handled layout.
        """
        return self.name

    def __exit__(self, type, value, traceback):
        cmds.setParent('..')


#======================================================================
def showMessageBox(title, message, icon=None):
    """
    This method pops up a Maya message box with the given title and the given
    message.

    It also accepts an optional icon parameter which can receive the same
    values as the confirmDialog command does.
    """

    extraParams = {}
    if icon:
        extraParams['icon'] = icon

    okButtonString = maya.stringTable['y_ui.kOK' ]
    cmds.confirmDialog(
        title=title,
        message=message,
        button=okButtonString,
        defaultButton=okButtonString,
        **extraParams
        )

#======================================================================
#
#   smb_output_window (window)
#    +--------------------------------------------------------------+
#    | rowLayout                                                    |
#    | +-----------------+---------------+-----------------------+  |
#    | |button "Refresh" | button "Copy" | text "Highlight Text" |  |
#    | +-----------------+---------------+-----------------------+  |
#    | |  SEPARATOR                                              |  |
#    | +---------------------------------------------------------+  |
#    | | scrollLayout                                            |  |
#    | | +-----------------------------------------------------+ |  |
#    | | |  formLayout                                         | |  |
#    | | |  +-----------------------------------------------+  | |  |
#    | | |  |  smb_output_text (text)                       |  | |  |
#    | | |  +-----------------------------------------------+  | |  |
#    | | +-----------------------------------------------------+ |  |
#    | +---------------------------------------------------------+  |
#    +--------------------------------------------------------------+
#
def scrollableMessageBox(title, messageCallback):
    """
    Use showMessageBox for simple messages. This one is for longer, possibly
    externally generated, ones that may need periodic refreshing.

    Pops up a Maya message box with the given title and the given
    message with scrolling capabilities for longer messages and extra
    controls:

        Refresh   : Call the provided method that will reload the window content
        Copy      : Copy the current highlighted text to the clipboard, all if no highlights
        Highlight : Color any text matching the highlight string, for easy viewing

    :param title: Window title for the message box
    :param messageCallback: Method called that will supply the output text on demand
    :return: The name of the output text control (for reading back)
    """
    # Default name of the window that displays scrollable message box output
    smb_output_window = 'SMB_Output'
    # Default name of the output filter field within the scrollable message box output window
    smb_output_filter = '{}Filter'.format(smb_output_window)
    # Default name of the main text form within the scrollable message box output window
    smb_output_frame = '{}Form'.format(smb_output_window)
    # Default name of the content section within the scrollable message box output window
    smb_output_content = '{}Content'.format(smb_output_window)
    # Default name of the text section within the scrollable message box output window
    smb_output_text = '{}Text'.format(smb_output_window)

    # For now only allow one of these windows at a time
    if cmds.window(smb_output_window, exists=True):
        cmds.deleteUI(smb_output_window)

    cmds.window( smb_output_window, title=title )
    cmds.formLayout( smb_output_frame )

    # Section 1, the controls
    top_row = cmds.rowLayout( rowAttach=[(1,'both',0)],
                numberOfColumns=5, adjustableColumn=5,
                columnAlign=[(i+1,'center') for i in range(3)] + [(4,'right'), (5,'left')],
                columnAttach=[(i+1,'both',0) for i in range(5)]
                )

    refresh_button = cmds.button( maya.stringTable['y_ui.kRefresh' ], annotation=maya.stringTable['y_ui.kRefreshAnnotation' ] )

    copy_button = cmds.button( maya.stringTable['y_ui.kCopy' ], annotation=maya.stringTable['y_ui.kCopyAnnotation' ] )

    cmds.separator( style='single' )

    cmds.text( label=maya.stringTable['y_ui.kOutputHighlight' ] )
    filter_field = cmds.textField( smb_output_filter,
                    text='', alwaysInvokeEnterCommandOnReturn=True,
                    annotation=maya.stringTable['y_ui.kShowOutputFilterInfo' ] )
    cmds.setParent( '..' )

    # Section 2, the file content
    cmds.scrollLayout( smb_output_content, childResizable=True )
    output_field = cmds.textScrollList( smb_output_text
                                      , numberOfRows=1
                                      , allowMultiSelection=True
                                      , append=['Temporary text'] )

    # Set the callbacks to reload the file content on demand
    copy_functor = partial(copyScrollableMessageBox, output_field=output_field)
    copy_command = partial(callback_wrapper, functor=copy_functor)
    reload_functor = partial(reloadScrollableMessageBox, messageCallback=messageCallback, output_field=output_field, filter_field=filter_field)
    reload_command = partial(callback_wrapper, functor=reload_functor)
    cmds.button( refresh_button, edit=True, command=reload_command )
    cmds.button( copy_button, edit=True, command=copy_command )
    cmds.textField( filter_field, edit=True, enterCommand=reload_command )

    cmds.formLayout( smb_output_frame, edit=True,
                     attachControl=[(smb_output_content,'top',5,top_row)],
                     attachForm=[(top_row,'top',0),
                                 (top_row,'left',0),
                                 (top_row,'right',0),
                                 (smb_output_content,'left',0),
                                     (smb_output_content,'right',0),
                                     (smb_output_content,'bottom',0)] )

    # Lastly, load the content and show the window
    reloadScrollableMessageBox(messageCallback, output_field, filter_field)

    cmds.showWindow()

#======================================================================
def reloadScrollableMessageBox(messageCallback, output_field, filter_field):
    '''
    Reload the output into the scrollable text area, using the filter
    information to highlight sections of interest where needed.

    :param messageCallback: Method to call that will provide the text as an
                            array, one line per array entry or a single string
                            with embedded linefeeds.
    :param output_field:    Scrollable text field control containing the output
    :param filter_field:    Text field containing the highlight filter
    '''
    # Populate the window components with the current trace output
    filter_data = cmds.textField( filter_field, query=True, text=True )

    # From the contents of the file construct three synchronized arrays of
    # descriptive elements, one per line:
    #       line_id:     Unique ID of the line for selection purposes
    #       line_text:   Contents of the line
    #       line_select: True|False saying whether it matched the filter data or not
    try:
        line_number = 0
        line_id = []
        line_text = []
        line_select = []
        text_to_show = messageCallback()
        # Accept both a single string with embedded line breaks or a list of one string per line
        for line in text_to_show if isinstance(text_to_show,list) else text_to_show.split('\n'):
            line_number += 1
            this_id = 'line{}'.format(line_number)
            line_id.append( this_id )
            line_text.append(line.rstrip())
            if filter_data != '' and re.search(filter_data, line) is not None:
                line_select.append( this_id )
    except Exception:
        line_id = ['line0']
        line_text = [maya.stringTable['y_ui.kDataNotFound' ]]
        line_select = []

    cmds.textScrollList( output_field, edit=True, removeAll=True )
    cmds.textScrollList( output_field, edit=True,
                         numberOfRows=len(line_text),
                         append=line_text,
                         uniqueTag=line_id,
                         selectUniqueTagItem=line_select )

#======================================================================
def copyScrollableMessageBox(output_field):
    '''
    Copy the highlighted output from the scrollable text area. If nothing
    is highlighted then copy everything.

    :param output_field:    Scrollable text field control containing the output
    '''
    # Find the highlighted items, if any, otherwise get the entire list
    if cmds.textScrollList( output_field, query=True, numberOfSelectedItems=True ):
        to_copy = cmds.textScrollList( output_field, query=True, selectItem=True )
    else:
        to_copy = cmds.textScrollList( output_field, query=True, allItems=True )

    # Construct a multi-line string from the list and put it onto the clipboard
    setClipboardData( '\n'.join(to_copy) )

#======================================================================
def showConfirmationDialog(title, message):
    """
    This method pops up a Maya confirmation dialog with the given title and the
    given message.

    It returns True if the user accepted, False otherwise.
    """

    okButtonString = maya.stringTable['y_ui.kOKButton' ]
    cancelButtonString = maya.stringTable['y_ui.kCancelButton' ]
    answer = cmds.confirmDialog(
        title=title,
        message=message,
        button=[okButtonString, cancelButtonString],
        defaultButton=okButtonString,
        icon='question'
        )

    return answer == okButtonString

#======================================================================
def unix_cmd_exists(cmd):
    '''Simple utility to see if a command is accessible in the current shell path'''
    return subprocess.call("type " + cmd, shell=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0

#======================================================================
def getClipboardData():
    '''
    Retrieve data from the clipboard.
    '''
    try:
        from PySide2.QtWidgets import QApplication
        from PySide2 import QtGui
        from PySide2.QtGui import QClipboard

        clipboard = QApplication.clipboard()
        return clipboard.text(mode=clipboard.Clipboard)
    except ImportError:
        return FAKE_CLIPBOARD

#======================================================================
def setClipboardData(data):
    '''
    Set data onto the clipboard.
    '''
    global FAKE_CLIPBOARD
    try:
        from PySide2.QtWidgets import QApplication
        from PySide2 import QtGui
        from PySide2.QtGui import QClipboard

        clipboard = QApplication.clipboard()
        clipboard.clear(mode=clipboard.Clipboard )
        clipboard.setText(str(data), mode=clipboard.Clipboard)
    except ImportError:
        FAKE_CLIPBOARD = data

#======================================================================
def highlight_colour():
    '''
    :return: List of [R,G,B] for the unified Maya highlight colour in a format suitable for
    passing to the 'backgroundColor' parameter of most UI commands.
    '''
    return [0.322, 0.52, 0.65]  # Nearest equivalent to #5285A6

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
