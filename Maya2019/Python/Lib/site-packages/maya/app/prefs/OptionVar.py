import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Encapsulation of the optionVar values as a Python object of type OptionVar.
The encapsulation handles preference-related functions such as:
    - getting optionVar value
    - setting optionVar value
    - setting default value on uninitialized optionVar
    - saving and restoring optionVar value (for undo)

In addition to the native types float, int, and string, this class provides
abstract support for boolean types and enum types. It performs basic validation
on the type of data passed in (e.g. you cannot pass "3" to a boolean)

    b_var = OptionVar( 'bVar', OPTION_VAR_TYPE_BOOL, False )
    e_var = OptionVar( 'eVar', [ 'red', 'green', 'blue' ], 'red' )

Note: Although this currently doesn't handle array optionVars it could easily be extended to do so.
'''

__all__ = [ 'OptionVar'
          , 'OPTION_VAR_TYPE_BOOL'
          , 'OPTION_VAR_TYPE_FLOAT'
          , 'OPTION_VAR_TYPE_INT'
          , 'OPTION_VAR_TYPE_STRING'
          ]

from functools import partial

#======================================================================
#
# Maya LT has a sandboxed version of Python that does not allow access to the debug modules
# so for that version provide an alternative. Also provide it for the unit test since running
# that from the command line may not have access to the module and it's not necessary for the
# test.
#
CREATE_DEBUG_PROXY = True
CREATE_DEBUG_PROXY = __name__ == '__main__'
if CREATE_DEBUG_PROXY:
    class DebugTrace(object):
        '''Proxy implementation of the debug trace class'''
        def dbg(self,_): pass
else:
    from maya.debug.DebugTrace import DebugTrace
DBG = DebugTrace()
# DBG.debugging = True # Uncomment this line to enable debugging

#======================================================================

if __name__ == '__main__':
    # Facade to allow the localization macros to work in standalone mode
    # Has to be hacked through a string to prevent the preprocessor from complaining.
    exec 'def _L10N(_, english_string):  return english_string'

# Constants representing the allowable types of optionVars supported by this module.
# There isn't really a "boolean" option var type. It's introduced here to provide a
# more natural interface to preferences that are boolean values.
OPTION_VAR_TYPE_BOOL = 0
OPTION_VAR_TYPE_FLOAT = 1
OPTION_VAR_TYPE_INT = 2
OPTION_VAR_TYPE_STRING = 3
OPTION_VAR_TYPES = [ OPTION_VAR_TYPE_BOOL
                   , OPTION_VAR_TYPE_FLOAT
                   , OPTION_VAR_TYPE_INT
                   , OPTION_VAR_TYPE_STRING
                   ]

# Dictionary of dynamically added enum optionVar types (strings with limited values).
# KEY=Index into OPTION_VAR_TYPES of the enum type
# VALUE=List of allowed types for this enum
ENUM_LISTS = {}

# Errors encountered when a mismatch of data and optionVar type is found
ERR_OV_NOT_BOOL       = maya.stringTable['y_OptionVar.kOptionVarNotBool'     ]
ERR_OV_NOT_FLOAT      = maya.stringTable['y_OptionVar.kOptionVarNotFloat'    ]
ERR_OV_NOT_INT        = maya.stringTable['y_OptionVar.kOptionVarNotInt'      ]
ERR_OV_NOT_STRING     = maya.stringTable['y_OptionVar.kOptionVarNotString'   ]
ERR_OV_NOT_ENUM       = maya.stringTable['y_OptionVar.kOptionVarIllegalEnum' ]
ERR_OV_NOT_LEGAL_ENUM = maya.stringTable['y_OptionVar.kOptionVarNotEnum'     ]
ERR_OV_TYPE_UNKNOWN   = maya.stringTable['y_OptionVar.kOptionVarTypeUnknown' ]

#======================================================================
def var_type_info(var_type):
    '''Utility method to return a debug string representing a variable type'''
    if var_type <= OPTION_VAR_TYPE_STRING:
        return ['boolean', 'float', 'int', 'string'][var_type]

    return 'enum[{}] ({})'.format( var_type, ENUM_LISTS[var_type] )

#======================================================================
def option_var_set_value(var_name, var_type, var_value ):
    '''
    Set the value of an optionVar, with input type validation
    :param var_name: Name of the optionVar to retrieve
    :param var_type: Type of optionVar this is
    :param var_value: New value to be set
    :raise ValueError: If the var_value type is not compatible with var_type
                       This is slightly more restrictive than normal usage:
                           - non-string types to strings.
                           - integers are converted to floats but not booleans
                           - booleans are converted to ints (0, 1) but not floats
                           - enum string matches the known string types
    '''
    DBG.dbg( 'Setting optionVar {} to {} ({})'.format( var_name, var_value, var_type_info(var_type)) )
    assert var_type in OPTION_VAR_TYPES
    if var_type == OPTION_VAR_TYPE_BOOL:
        if not isinstance(var_value,bool):
            raise ValueError( ERR_OV_NOT_BOOL.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( intValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_FLOAT:
        if not isinstance(var_value,int) and not isinstance(var_value, float):
            raise ValueError( ERR_OV_NOT_FLOAT.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( floatValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_INT:
        if not isinstance(var_value,int):
            raise ValueError( ERR_OV_NOT_INT.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( intValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_STRING:
        if not isinstance(var_value,str):
            raise ValueError( ERR_OV_NOT_STRING.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( stringValue=[var_name, var_value] )
    #
    elif var_type in ENUM_LISTS:
        if not isinstance(var_value,str) and not isinstance(var_value,unicode):
            raise ValueError( ERR_OV_NOT_ENUM.format(var_name, var_value, type(var_value)) )
        if str(var_value) not in ENUM_LISTS[var_type]:
            raise ValueError( ERR_OV_NOT_LEGAL_ENUM.format(var_name, var_value, ENUM_LISTS[var_type]) )
        cmds.optionVar( stringValue=[var_name, str(var_value)] )
    #
    else:
        raise ValueError( ERR_OV_TYPE_UNKNOWN.format( var_name, var_type, var_value ) )

#======================================================================
def option_var_get_value(var_name, var_type):
    '''
    Type-safe method of retrieving the current value of the optionVar. Converts from
    the raw value to the var_type the optionVar is expected to be.
    :param var_name: Name of the optionVar to retrieve
    :param var_type: Type of optionVar this is
    :param var_value: New value to be set
    :raise ValueError: If the var_value type is not compatible with retrieved value.
                       - A boolean is not 0 or 1
                       - An enum is not part of the allowed enum string list
                       - Floats are truncated to integers
    '''
    assert var_type in OPTION_VAR_TYPES
    var_value = cmds.optionVar( query=var_name )
    if var_type == OPTION_VAR_TYPE_BOOL:
        if not isinstance(var_value,int) or var_value not in [0,1]:
            raise ValueError( ERR_OV_NOT_BOOL.format(var_name, var_value) )
        var_value = [False,True][var_value]
    #
    elif var_type == OPTION_VAR_TYPE_FLOAT:
        if not isinstance(var_value,int) and not isinstance(var_value, float):
            raise ValueError( ERR_OV_NOT_FLOAT.format(var_name, var_value) )
    #
    elif var_type == OPTION_VAR_TYPE_INT:
        if not isinstance(var_value,int):
            raise ValueError( ERR_OV_NOT_INT.format(var_name, var_value) )
        var_value = int(var_value)
    #
    elif var_type == OPTION_VAR_TYPE_STRING:
        if not isinstance(var_value,str):
            raise ValueError( ERR_OV_NOT_STRING.format(var_name, var_value) )
    #
    elif var_type in ENUM_LISTS:
        if not isinstance(var_value,str) and not isinstance(var_value,unicode):
            raise ValueError( ERR_OV_NOT_ENUM.format(var_name, var_value, type(var_value)) )
        if str(var_value) not in ENUM_LISTS[var_type]:
            raise ValueError( ERR_OV_NOT_LEGAL_ENUM.format(var_name, var_value, ENUM_LISTS[var_type]) )
    #
    else:
        raise ValueError( ERR_OV_TYPE_UNKNOWN.format( var_name, var_type, var_value ) )

    return var_value

#======================================================================
class OptionVar(object):
    '''
    Class that manages an optionVar synced preference variable. It understands all of the various
    types of optionVars as well as some metatypes (e.g. boolean implemented as int, enum
    implemented as string).
        :member name: Name of the optionVar (i.e. what you pass to the optionVar command)
        :member value_default: The default value of the optionVar (i.e. the value it gets when prefs are reset)
        :member value_type: One of the OPTION_VAR_TYPE_xxx constants indicating what type of variable this is
        :member value_remembered: Value that was remembered when requested
        :member title: Short title describing the preference
        :member info: Longer description of the preference
        :member option_var_job: scriptJob ID for the job that updates the preference when the optionVar changes
        :member clients: Dictionary of client methods to call when the OptionVar changes,
                         either directly or via the Maya state - usually for UI. KEY=client, VALUE=callback
    '''
    def __init__(self, name, value_type, value_default):
        '''
        Initialize a new optionVar sync object
        :param name: Name of the optionVar (i.e. what you pass to the optionVar command)
        :param value_type: One of the OPTION_VAR_TYPE_xxx constants indicating what type of variable this is
                           If this is a list instead then it is considered to be the list of valid
                           strings for an enum type.
        :param value_default: The default value of the optionVar (i.e. the value it gets when prefs are reset)
        '''
        self.name = name
        self.value_default = value_default
        self.clients = {}
        self.title = name
        self.info = name
        self.option_var_job = None

        if isinstance(value_type, list):
            OPTION_VAR_TYPES.append( len(OPTION_VAR_TYPES) )
            new_type = len(OPTION_VAR_TYPES) - 1
            ENUM_LISTS[new_type] = value_type
            self.value_type = new_type
        else:
            assert value_type in OPTION_VAR_TYPES
            self.value_type = value_type

        # Always initialize the optionVar if it doesn't yet exist
        if not cmds.optionVar( exists=self.name ):
            option_var_set_value( self.name, self.value_type, self.value_default )

        # Remember the current value so that initialization can be verified
        self.value_remembered = self.get_value()

        self.monitor_preference = True

    #----------------------------------------------------------------------
    class StateError(ValueError):
        '''
        Exception raised to indicate that state information was not available. This is used to
        differentiate a state that couldn't be set from an attempt to set up an illegal state value
        '''
        def __init__(self, msg):
            '''Initialize the message in the ValueError, this class has no information of its own'''
            super( OptionVar.StateError, self ).__init__( msg )

    #----------------------------------------------------------------------
    def read_preference_from_state(self):
        '''Override this to read the new value of the optionVar from the scene state. Do not call directly.'''
        DBG.dbg( 'No override of read_preference_from_state({})'.format( self.name ) )

    #----------------------------------------------------------------------
    def set_state_from_preference(self):
        '''Override this to apply the current value of the optionVar to the scene state. Do not call directly.'''
        DBG.dbg( 'No override of set_state_from_preference({})'.format( self.name ) )

    #----------------------------------------------------------------------
    def do_read_preference_from_state(self):
        '''Wrapper around read_preference_from_state that ensures monitoring is off and values are legal'''
        DBG.dbg( 'do_read_preference_from_state({})'.format( self.name ) )
        old_preference = self.monitor_preference
        self.monitor_preference = False
        try:
            self.read_preference_from_state()
        except OptionVar.StateError, ex:
            DBG.dbg( 'State information unavailable for {}, retaining current preference ({})'.format( self.name, ex ) )
        except ValueError, ex:
            DBG.dbg( 'Failed to get new value of {} from state, retaining old value ({})'.format( self.name, ex ) )
        self.monitor_preference = old_preference

    #----------------------------------------------------------------------
    def do_set_state_from_preference(self):
        '''Wrapper around set_state_from_preference that ensures monitoring is off and values are legal'''
        DBG.dbg( 'do_set_state_from_preference({})'.format( self.name ) )
        old_preference = self.monitor_preference
        self.monitor_preference = False
        try:
            self.set_state_from_preference()
        except OptionVar.StateError, ex:
            DBG.dbg( 'Preference value could not be set into the state at the moment' )
        except ValueError, ex:
            DBG.dbg( 'Preference value of {} was illegal, retrieving value from state ({})'.format( self.name, ex ) )
            try:
                self.read_preference_from_state()
            except ValueError, ex:
                DBG.dbg( '--> That failed as well ({})'.format( ex ) )
        self.monitor_preference = old_preference

    #----------------------------------------------------------------------
    def __str__(self):
        ''':return: String representation of the optionVar'''
        callbacks = ', '.join( [listener.__class__.__name__ for listener in self.clients.keys()] )

        if self.value_type in ENUM_LISTS:
            values = ENUM_LISTS[self.value_type]
        else:
            values = ['boolean','integer','float','string'][self.value_type]

        return '{} (type {}, default {}, remembered {} - callbacks ({}))'.format( self.name, values, self.value_default, self.value_remembered, callbacks )

    #----------------------------------------------------------------------
    def update_clients(self):
        '''Notify the list of clients that the value has changed'''
        for client_callback in self.clients.values():
            client_callback()

    #----------------------------------------------------------------------
    def update_all_clients_but_me(self, who_am_i):
        '''
        Notify the list of clients that the value has changed, not including the one passed in
        :param who_am_i: The client that initiated the changed (which is why it won't be notified)
        '''
        for client, client_callback in self.clients.iteritems():
            if client != who_am_i:
                client_callback()

    #----------------------------------------------------------------------
    def add_client(self, client, client_callback):
        '''
        Add a new client function to be called when this OptionVar value changes
        :param client: Name of client owning the callback
        :param client_callback: Function to be called when the OptionVar changes
                                Takes this OptionVar as the parameter.
        '''
        assert client not in self.clients
        self.clients[client] = client_callback

    #----------------------------------------------------------------------
    def remove_client(self, client):
        '''
        Remove all clients
        '''
        assert client in self.clients
        del self.clients[client]

    #----------------------------------------------------------------------
    def get_value(self):
        '''
        Get the current value of this managed variable. If the value has not yet
        been defined as an optionVar then return the default (not 0 as the optionVar
        command normally would).
        :raise ValueError: If the var_name is not known to the manager
        '''
        current_value = self.value_default
        if cmds.optionVar( exists=self.name ):
            try:
                current_value = option_var_get_value( self.name, self.value_type )
                DBG.dbg( 'Getting current value of {} from optionVar {}'.format( current_value, self.name ) )
            except ValueError:
                DBG.dbg( 'Current value of {} is illegal, returning the default {}'.format( self.name, self.value_default ) )
        else:
            DBG.dbg( 'Option var {} does not exist - getting default value of {}'.format( self.name, self.value_default ) )

        return current_value

    #----------------------------------------------------------------------
    def set_value(self, var_value):
        '''
        Set the value of the managed variable. The value passed in must match
        the type the variable has been defined as.
        :param var_value: New value of the optionVar
        '''
        try:
            old_value = self.get_value()
            option_var_set_value( self.name, self.value_type, var_value )
            # Only update the state if the preference wasn't being read from it in the first
            # place, and it has a new value
            if self.monitor_preference and old_value != var_value:
                self.do_set_state_from_preference()
                self.update_clients()
        except ValueError:
            DBG.dbg( 'Tried to set illegal value of {} on {}'.format( var_value, self.name ) )

    #----------------------------------------------------------------------
    def set_value_directly(self, client, var_value):
        '''
        Same as set_value, except that monitoring is disabled and the state is updated
        directly after the new optionVar is set, including any clients (not including
        the client that set the value).
        :param var_value: New value of the optionVar
        :param client: Who set the value directly
        :raise ValueError: If the value was not a legal value for this optionVar
        '''
        old_monitor = self.monitor_preference
        self.monitor_preference = False
        try:
            option_var_set_value( self.name, self.value_type, var_value )
            self.set_state_from_preference()
            self.update_all_clients_but_me( client )
        except ValueError:
            DBG.dbg( 'Tried to set illegal value of {} on {}'.format( var_value, self.name ) )
        finally:
            self.monitor_preference = old_monitor

    #----------------------------------------------------------------------
    def remember_current(self):
        '''
        Remember the current states of all managed optionVars
        '''
        self.value_remembered = self.get_value()
        DBG.dbg( 'Remember optionVar {} value {}'.format( self.name, self.value_remembered ) )

    #----------------------------------------------------------------------
    def restore_remembered(self):
        '''
        Restore the remembered states of all managed optionVars
        '''
        DBG.dbg( 'Restore optionVar {} value {}'.format( self.name, self.value_remembered ) )
        self.set_value( self.value_remembered )
        self.update_clients()

    #----------------------------------------------------------------------
    def revert_to_default(self):
        '''
        Restore the states of all managed optionVars to their factory defaults
        '''
        DBG.dbg( 'Revert optionVar {} to default {}'.format( self.name, self.value_default ) )
        self.set_value( self.value_default )
        self.update_clients()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_preference_changed(option_var):
        '''
        Callback invoked when the optionVar has been modified via the optionVar command
        :param option_var: OptionVar object generating the callback
        '''
        DBG.dbg( '{}.callback_preference_changed'.format( option_var.name ) )
        try:
            option_var.set_state_from_preference()
            option_var.update_clients()
        except ValueError, ex:
            DBG.dbg( 'Preference value of {} was illegal, retrieving value from state ({})'.format( option_var.name, ex ) )
            try:
                option_var.read_preference_from_state()
            except ValueError, ex:
                DBG.dbg( '--- state retrieval failed as well ({})'.format( ex ) )

    #----------------------------------------
    @property
    def monitor_preference(self):
        '''Return the resource guard state value'''
        return self.option_var_job is not None

    @monitor_preference.setter
    def monitor_preference(self, new_value):
        '''
        Set the state the the preference monitoring.
        :param new_value: New preference monitoring state.  True means a script job
                          will be run (or let continue) that provides a callback when
                          this class's optionVar changes value.
        '''
        # Skip the cases where the monitoring is unchanged
        if new_value and self.option_var_job is not None:
            return
        if not new_value and self.option_var_job is None:
            return

        if new_value:
            self.option_var_job = cmds.scriptJob( optionVarChange=[self.name, partial(self.callback_preference_changed, option_var=self)] )
        else:
            cmds.scriptJob( kill=self.option_var_job )
            self.option_var_job = None

#######################################################################
# Unit testing module
#######################################################################

if __name__ == '__main__':
    import unittest
    class cmds(object):
        '''Proxy implementation of the maya commands that are used in the class'''
        JOBS_ACTIVE = []
        NEXT_JOB = 0

        @staticmethod
        def scriptJob( kill=None, optionVarChange=None ):
            '''Proxy implementation of the Maya scriptJob command.  Does not actually monitor anything
            but it does keep track of monitoring job IDs for proper management'''
            assert optionVarChange is None or kill is None
            if kill is not None:
                assert kill in cmds.JOBS_ACTIVE
                del cmds.JOBS_ACTIVE[kill]
            else:
                cmds.JOBS_ACTIVE.append( cmds.NEXT_JOB )
                cmds.NEXT_JOB = cmds.NEXT_JOB + 1

        # Global map containing the test optionVars
        #   KEY=var_name, VALUE=[var_type,var_value]
        global_option_vars = {}
        @staticmethod
        def optionVar( intValue=None, floatValue=None, stringValue=None, exists=None, query=None):
            ''' Simulate the operation of an optionVar for testing purposes '''
            if exists is not None:
                return exists in cmds.global_option_vars
            if query is not None:
                if query in cmds.global_option_vars:
                    return cmds.global_option_vars[query][1]
                else:
                    return None
            if intValue is not None:
                assert isinstance(intValue, list)
                assert len(intValue) == 2
                (name, value) = intValue
                cmds.global_option_vars[name] = [OPTION_VAR_TYPE_INT, value]
            elif floatValue is not None:
                assert isinstance(floatValue, list)
                assert len(floatValue) == 2
                (name, value) =  floatValue
                cmds.global_option_vars[name] = [OPTION_VAR_TYPE_FLOAT, value]
            elif stringValue is not None:
                assert isinstance(stringValue, list)
                assert len(stringValue) == 2
                (name, value) =  stringValue
                cmds.global_option_vars[name] = [OPTION_VAR_TYPE_STRING, value]

    #----------------------------------------------------------------------
    class MyOptionVar(OptionVar):
        '''Class to provide testable behaviour in an OptionVar override'''
        my_state = 0
        def __init__(self):
            '''Create a known type of OptionVar'''
            super( MyOptionVar, self ).__init__('MyOptionVar', OPTION_VAR_TYPE_INT, 0)
            self.title = 'My Option Var'
            self.info  = 'This is My Option Var'
        def read_preference_from_state(self):
            '''Set the preference to an internal value'''
            if MyOptionVar.my_state < 0:
                raise ValueError( 'MyOptionVar must be positive' )
            self.set_value( MyOptionVar.my_state )
        def set_state_from_preference(self):
            '''Set the internal value to the preference value'''
            MyOptionVar.my_state = self.get_value()

    #----------------------------------------------------------------------
    class OptionVarTest(unittest.TestCase):
        ''' Class that contains the unit tests for the OptionVar class '''
        #----------------------------------------
        def test_simple(self):
            '''
            Test simple creation and initialization of optionVars
            '''
            # Create one of each type of optionVar
            i_option_var = OptionVar( 'intVar', OPTION_VAR_TYPE_INT, 5 )
            self.assertEqual( i_option_var.get_value(), 5 )
            b_option_var = OptionVar( 'boolVar', OPTION_VAR_TYPE_BOOL, True )
            self.assertEqual( b_option_var.get_value(), True )
            f_option_var = OptionVar( 'floatVar', OPTION_VAR_TYPE_FLOAT, 2.5 )
            self.assertEqual( f_option_var.get_value(), 2.5 )
            s_option_var = OptionVar( 'stringVar', OPTION_VAR_TYPE_STRING, 'hello' )
            self.assertEqual( s_option_var.get_value(), 'hello' )

            # Test the sync functions
            my_option_var = MyOptionVar()
            my_option_var.set_value( 6 )
            self.assertEqual( my_option_var.get_value(), 6 )
            self.assertEqual( MyOptionVar.my_state, 6 )
            MyOptionVar.my_state = 10
            my_option_var.read_preference_from_state()
            self.assertEqual( my_option_var.get_value(), 10 )
            MyOptionVar.my_state = 1
            my_option_var.set_state_from_preference()
            self.assertEqual( MyOptionVar.my_state, 10 )

            # Test attempts to set illegal values
            with self.assertRaises( ValueError ):
                i_option_var.set_value( 'hello' )
            with self.assertRaises( ValueError ):
                i_option_var.set_value( 2.4 )
            with self.assertRaises( ValueError ):
                f_option_var.set_value( 'hello' )
            with self.assertRaises( ValueError ):
                b_option_var.set_value( 'hello' )
            with self.assertRaises( ValueError ):
                b_option_var.set_value( 3.0 )
            with self.assertRaises( ValueError ):
                b_option_var.set_value( 1 )
            with self.assertRaises( ValueError ):
                MyOptionVar.my_state = -1
                my_option_var.read_preference_from_state()

        #----------------------------------------
        def test_enum(self):
            '''
            Test creation and initialization of a custom enum optionVar
            '''
            enums = [ 'yes', 'no', 'maybe so', 'makes sense' ]
            e_option_var = OptionVar( 'enumVar', enums, enums[0] )
            self.assertEqual( e_option_var.get_value(), enums[0] )

            e_option_var.set_value( enums[2] )
            self.assertEqual( e_option_var.get_value(), enums[2] )

            with self.assertRaises( ValueError ):
                e_option_var.set_value( 1 )
            with self.assertRaises( ValueError ):
                e_option_var.set_value( 1.5 )
            with self.assertRaises( ValueError ):
                e_option_var.set_value( 'doubt it' )

    if __name__ == '__main__':
        unittest.main()
else:
    import maya.cmds as cmds

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
