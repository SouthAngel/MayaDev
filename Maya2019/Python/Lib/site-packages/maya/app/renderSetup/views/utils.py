import maya
maya.utils.loadStringResourcesForModule(__name__)

import maya.cmds as cmds
import maya.mel as mel

from maya import OpenMayaUI as omui 

from PySide2.QtCore import Qt
from PySide2.QtGui import QMouseEvent, QPixmap, QIcon
from PySide2.QtWidgets import QLabel, QLineEdit, QWidget, QHBoxLayout, QPushButton, QFrame, QSizePolicy
from shiboken2 import wrapInstance 

import maya.app.renderSetup.common.utils as commonUtils
import maya.app.renderSetup.model.plug as plug
from maya.app.renderSetup.model.progressObservable import ProgressObservable
from maya.app.renderSetup.views.propertyEditor.collectionPropertyEditorStrings import kNbObjects, kOK, kSelectAll
from functools import partial

kExpandedStateString = "expandedState"

kImageNotFoundError = maya.stringTable['y_utils.kImageNotFoundError' ]
kIconNotFoundError = maya.stringTable['y_utils.kIconNotFoundError' ]

_DPI_SCALE = 1.0 if not hasattr(cmds, "mayaDpiSetting") else cmds.mayaDpiSetting(query=True, realScaleValue=True)

def dpiScale(value):
    return value * _DPI_SCALE

def updateMouseEvent(event):
    # Handles one and two button mice CMD-click and Control-click events in
    # order to make it possible to right click and middle click with those mice.
    if cmds.about(mac=True):
        numMouseButtons = cmds.mouse(mouseButtonTrackingStatus=True)
        if numMouseButtons == 1:
            if event.modifiers() & Qt.MetaModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   Qt.RightButton,
                                   event.buttons(),
                                   event.modifiers() & ~Qt.MetaModifier,
                                   event.source())
            elif int(event.buttons()) & int(Qt.LeftButton) and event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   event.button(),
                                   Qt.MouseButtons(int(event.buttons())|Qt.MiddleButton&~Qt.LeftButton),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())
            elif event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   Qt.MiddleButton,
                                   event.buttons(),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())

        elif numMouseButtons == 2:
            if event.button() == Qt.LeftButton and event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   Qt.MiddleButton,
                                   event.buttons(),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())
            elif int(event.buttons()) & int(Qt.LeftButton) and event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   event.button(),
                                   Qt.MouseButtons(int(event.buttons())|Qt.MiddleButton&~Qt.LeftButton),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())
    return event

def createPixmap(imageName, width=0, height=0):
    rawPixmap = omui.MQtUtil.createPixmap(imageName)
    if rawPixmap is None:
        raise RuntimeError(kImageNotFoundError % imageName)
    pixmap = wrapInstance(long(rawPixmap), QPixmap)
    if (width != 0 and height != 0):
        return pixmap.scaled(width, height)
    return pixmap

def createIcon(iconName):
    rawIcon = omui.MQtUtil.createIcon(iconName)
    if rawIcon is None:
        raise RuntimeError(kIconNotFoundError + iconName)
    icon = wrapInstance(long(rawIcon), QIcon)
    return icon

def createIconWithOnOffStates(pixmapOffState, pixmapOnState):
    """ Create an icon with on/off states. Each state has a different pixmap."""
    rawIcon = omui.MQtUtil.createIcon(pixmapOffState)
    if rawIcon is None:
        raise RuntimeError(kImageNotFoundError + pixmapOffState)
    icon = wrapInstance(long(rawIcon), QIcon)
    icon.addPixmap(createPixmap(pixmapOnState), QIcon.Normal, QIcon.On)
    return icon

class ProgressBar(object):
    __metaclass__ = commonUtils.SingletonMetaClass

    def __init__(self):
        super(ProgressBar, self).__init__()
        # Variable used to store the progress bar used in the class
        # and monitor active progress.
        self.mainProgressBar = None
        self.progressPercentage = 0

    def stepProgressBar(self, progress, info):
        newProgressPercentage = (int)(100*progress)
        if self.mainProgressBar and newProgressPercentage - self.progressPercentage:
            self.progressPercentage = newProgressPercentage
            cmds.progressBar(self.mainProgressBar, edit=True, progress=self.progressPercentage, status=info)

    def createProgressBar(self):
        self.mainProgressBar = mel.eval('$tmp = $gMainProgressBar')
        if self.mainProgressBar:
            cmds.progressBar(self.mainProgressBar,
                             edit=True,
                             beginProgress=True,
                             isInterruptable=False,
                             status="",
                             maxValue=100)
            self.progressPercentage = 1
            cmds.progressBar(self.mainProgressBar, edit=True, progress=self.progressPercentage, status="")
            cmds.waitCursor(state=True)

    def endProgressBar(self):
        if self.mainProgressBar:
            cmds.progressBar(self.mainProgressBar, edit=True, endProgress=True)
            self.progressPercentage = 0
            self.mainProgressBar = None
            cmds.waitCursor(state=False)

    def registerAsProgressObserver(self):
        assert ProgressObservable().hasItemObserver(self.reactToItemChangedNotification) == False
        ProgressObservable().addItemObserver(self.reactToItemChangedNotification)

    def unregisterAsProgressObserver(self):
        assert ProgressObservable().hasItemObserver(self.reactToItemChangedNotification) == True
        ProgressObservable().removeItemObserver(self.reactToItemChangedNotification)

    def reactToItemChangedNotification(self, *posArgs, **kwArgs):
        """ The subject of observation sends messages in the form of classes to
            indicate that progress has started or ended. Otherwise, it sends
            information about the progress estimated to be done
            (as a value from 0 to 1) and a message to be displayed.
        """
        assert len(posArgs) > 0 and len(posArgs) <=2
        if posArgs[0] == ProgressObservable.StartProgressNotification:
            self.createProgressBar()
        elif posArgs[0] == ProgressObservable.EndProgressNotification:
            self.endProgressBar()
        elif self.mainProgressBar:
            self.stepProgressBar(posArgs[0], posArgs[1])

def setExpandedState(node, value):
    """ Sets an attribute on the node storing the expanded state of
    this node in the view. Creates it if it doesn't exist """

    # Get the plug associated with the expanded state attribute
    plugRef = commonUtils.findPlug(node, kExpandedStateString)
    if plugRef is None:
        # If it doesn't exist, we create it. It's a Plug object, Python side
        plugRef = plug.Plug.createAttribute(node, kExpandedStateString, 
            kExpandedStateString, {'type': 'Bool', 'connectable': False},
            plug.kNotUndoable)
        plugRef.value = value
    else:
        # If it already exists, we set its value. It's a MPlug object, OpenMaya side
        plugRef.setBool(value)

def getExpandedState(node):
    """ Retrieves the expanded state attribute of the node """

    plugRef = commonUtils.findPlug(node, kExpandedStateString)

    # If the attribte doesn't exist, just return False
    return plugRef.asBool() if plugRef is not None else False

def browse(fileNameAttr):
    result = cmds.fileDialog2(returnFilter=1, dialogStyle=2, fileMode=1) 
    if result and len(result) > 0:
        cmds.setAttr(fileNameAttr, result[0], type='string')

class NodeListView:
    def __init__(self, title):
        self.title = title
        # self.first is used for efficient selection command
        # on first selection => replace the current selection (~= clear + select)
        # on other selections => add/remove to the current selection
        self.first = True

    def show(self, names):
        self.first = True
        cmds.layoutDialog(ui=partial(self.buildViewObjects, names=names), title=self.title)
    
    def buildViewObjects(self, names):
        vSpc = 3
        hSpc = 10
        # Get the layoutDialog's formLayout.
        #
        form = cmds.setParent(q=True)

        # layoutDialog's are unfortunately not resizable, so hard code a size
        # here, to make sure all UI elements are visible.
        #
        cmds.formLayout(form, e=True, width=500, height=500)

        nbObjects = cmds.text(label=(kNbObjects % len(names)))

        treeView = cmds.treeView(allowDragAndDrop=False, allowReparenting=False, attachButtonRight=False)
        cmds.treeView(treeView, e=True, addItem = [(name,"") for name in names], itemDblClickCommand=lambda x:False)
        cmds.treeView(treeView, e=True, selectCommand=self.selectTreeCallBack)

        selectAllBtn = cmds.button(label=kSelectAll,command=partial(self.onSelectAllButton, treeView=treeView, names=names))
        okBtn = cmds.button(label=kOK,command=partial(self.onOKButton, msg='ok'))

        cmds.formLayout(
            form, edit=True,
            attachForm=[(nbObjects,   'top',    vSpc),
                        (nbObjects,   'left',   hSpc),
                        (treeView,    'left',   hSpc),
                        (treeView,    'right',  hSpc),
                        (okBtn,       'bottom', vSpc),
                        (okBtn,       'right',  hSpc),
                        (selectAllBtn,'bottom', hSpc)],
            attachControl=[(treeView, 'top', vSpc, nbObjects), 
                           (treeView, 'bottom', vSpc, okBtn),
                           (selectAllBtn, 'top', vSpc, treeView),
                           (selectAllBtn, 'right', hSpc, okBtn)])

    def onSelectAllButton(self, data, treeView, names):
        for name in names:
            cmds.treeView(treeView, e=True, selectItem=(name,1))
        commonUtils.echoSelect(names, noExpand=True, add=(not self.first))
        self.first = False
    
    def onOKButton(self, data, msg):
        cmds.layoutDialog(dismiss=msg)
        
    def selectTreeCallBack(self, *args):
        cmds.select(args[0], noExpand=True, add=(not self.first), deselect=(not args[1]))
        self.first = False
        return True

class LabelFieldButtonGrp(QWidget):
    '''Same as cmds.textFieldButtonGrp, but with better controls on each different widgets.
    (ex: more control on callbacks, tooltips and such).'''
    
    def __init__(self, label=None, text=None, placeholder=None, tooltip=None, button=None):
        super(LabelFieldButtonGrp, self).__init__()
        self._layout = QHBoxLayout()
        self.setLayout(self._layout)
        
        # label
        self._label = QLabel(label) if label else QLabel()
        self._layout.addWidget(self._label)
        
        # text field
        self._field = QLineEdit()
        if tooltip:
            self._field.setToolTip(tooltip)
        if placeholder:
            self._field.setPlaceholderText(placeholder)
        self._layout.addWidget(self._field)

        # button
        self._button = QPushButton(button) if button else QPushButton()
        self._layout.addWidget(self._button)
    
    @property
    def layout(self):
        return self._layout
         
    @property
    def label(self):
        return self._label
    
    @property
    def field(self):
        return self._field
    
    @property
    def button(self):
        return self._button

class Separator(QWidget):
    '''Same as cmds.separator(), except it allows to add a text in the middle of the separator.
    Ex: -------------- My Section --------------'''
    
    def __init__(self, text=None):
        super(Separator,self).__init__()
        
        layout = QHBoxLayout()
        self.setLayout(layout)
        
        def createLine():
            line = QFrame()
            line.setFrameShape(QFrame.HLine)
            return line
        layout.addWidget(createLine())
        if text:
            label = QLabel(text)
            label.setAlignment(Qt.AlignCenter)
            label.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
            layout.addWidget(label)
            layout.addWidget(createLine())
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
