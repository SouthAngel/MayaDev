"""Collection node class and utility functions.

   This module provides the collection class, as well as utility
   functions to operate on collections.

   The collection owns its associated selector node: on collection
   delete, the collection is deleted as well.

   Conceptually, a collection fulfills four roles in render setup:

   1) It is a container of overrides.  If enabled, the collection will
      apply all its enabled overrides on nodes it selects (see (2)).
   2) It selects nodes onto which overrides will be applied.  These nodes
      can be DAG or DG nodes.
   3) It is a container of child collections.  Child collections always
      select nodes based on their parent's selected nodes (see (2)).
   4) It defines render layer membership.  Members of a render layer can
      only be DAG nodes.  These are always a subset of the nodes selected
      by the collection (see (2)).  The members of the render layer are the
      union of the top-level collection members; children collections can
      exclude or re-include members.  See RenderLayer.getMembers for more
      details (including the effect of isolate select mode).

   The application of overrides only obeys enabled / disabled status.

   Render layer membership is determined from enabled / disabled, in
   conjunction with isolate select."""
import maya
maya.utils.loadStringResourcesForModule(__name__)


import re
import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya

import maya.app.renderSetup.model.nodeList as nodeList
import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.model.plug as plug
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.model.selector as selector
import maya.app.renderSetup.model.undo as undo
import maya.app.renderSetup.model.override as override
import maya.app.renderSetup.model.overrideUtils as overrideUtils
import maya.app.renderSetup.model.childNode as childNode
import maya.app.renderSetup.model.enabled as computeEnabled
import maya.app.renderSetup.model.namespace as namespace
import maya.app.renderSetup.model.rendererCallbacks as rendererCallbacks
import maya.app.renderSetup.model.traverse as traverse
import maya.app.renderSetup.model.clipboardData as clipboardData

import maya.app.renderSetup.common.utils as commonUtils
import maya.app.renderSetup.common.profiler as profiler
import maya.app.renderSetup.model.context as context

import maya.app.renderSetup.model.jsonTranslatorUtils as jsonTranslatorUtils
import maya.app.renderSetup.model.jsonTranslatorGlobals as jsonTranslatorGlobals


# List all error messages below
kInvalidChildName          = maya.stringTable['y_collection.kInvalidChildName'          ]
kUnknownChild              = maya.stringTable['y_collection.kUnknownChild'              ]
kOverrideCreationFailed    = maya.stringTable['y_collection.kOverrideCreationFailed'    ]
kCollectionMissingSelector = maya.stringTable['y_collection.kCollectionMissingSelector' ]
kRendererMismatch          = maya.stringTable['y_collection.kRendererMismatch'          ]
kIncorrectChildType        = maya.stringTable['y_collection.kIncorrectChildType'        ]

# List of undo messages
kChildAttached = maya.stringTable['y_collection.kChildAttached' ]
kChildDetached = maya.stringTable['y_collection.kChildDetached' ]
kSet           = maya.stringTable['y_collection.kSet'           ]

def collections(c):
    return c.getCollections()

class Collection(nodeList.ListBase, childNode.TreeOrderedItem,
                 childNode.ChildNode):
    """
    Collection node.

    A collection has an ordered list of children, and a selector to
    determine nodes to which the children apply.

    MAYA-59277: 
      - When we start implementing proper hierarchical collections we 
        need to decide on the relationship between parent and child
        selectors. Do we always consider a parent collection to be the 
        union of its child collections, and propagate the selector 
        information upwards when a child collection is added or changed?
        Or do we go the opposite direction and restrict the child collection
        to use the intersection between its selector and its parent's selector?

      - Light child collections always have a single light source member.
        We should utilize this and create a specific selector for such
        use cases for better performance.

    """

    kTypeId = typeIDs.collection
    kTypeName = 'collection'

    # Attributes for collection as list of children.
    # 
    # Connections to lowest-priority and highest-priority child
    # on children linked list.  The lowest-priority child
    # is considered to be the front of the list, and the highest-priority
    # child the back of the list.
    childLowest  = OpenMaya.MObject()
    childHighest = OpenMaya.MObject()

    # Connection to all children in the list.
    children = OpenMaya.MObject()

    # Attribute for message connection to selector node associated with the
    # collection. This attribute is a destination, as only one selector
    # can be associated with each collection.
    aSelector = OpenMaya.MObject()

    # Enabled behavior.  See enabled module for documentation.
    enabled       = OpenMaya.MObject()
    selfEnabled   = OpenMaya.MObject()
    parentEnabled = OpenMaya.MObject()

    # isolateSelected flag as attribute
    isolateSelected = OpenMaya.MObject()
    
    # The number of isolate selected children in a collection's subtree.
    numIsolatedChildren = OpenMaya.MObject()
    
    # The number of isolate selected ancestors of this collection.
    numIsolatedAncestors = OpenMaya.MObject()

    # the SimpleSelector is the default.
    kDefaultSelectorTypeName = selector.SimpleSelector.kTypeName
    
    @staticmethod
    def creator():
        return Collection()

    @staticmethod
    def initializer():
        
        # A collection is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other
        # attributes.
        Collection.inheritAttributesFrom(nodeList.ListItem.kTypeName)

        # A collection is a list of children.
        Collection.children = Collection.initListItems()

        Collection.childLowest = utils.createDstMsgAttr(
            'childLowest', 'cl')
        Collection.addAttribute(Collection.childLowest)

        Collection.childHighest = utils.createDstMsgAttr(
            'childHighest', 'ch')
        Collection.addAttribute(Collection.childHighest)

        Collection.aSelector = utils.createDstMsgAttr('selector', 'sel')
        Collection.addAttribute(Collection.aSelector)
        
        # Set up enabled attribute.
        computeEnabled.initializeAttributes(Collection)

        # Add isolateSelected attribute
        Collection.numIsolatedChildren = computeEnabled.createNumIsolatedChildrenAttribute()
        Collection.addAttribute(Collection.numIsolatedChildren)

        Collection.numIsolatedAncestors = computeEnabled.createHiddenIntAttribute(
            "numIsolatedAncestors", "nia")
        Collection.addAttribute(Collection.numIsolatedAncestors)

        # Add isolateSelected attribute
        numAttrFn = OpenMaya.MFnNumericAttribute()
        Collection.isolateSelected = numAttrFn.create("isolateSelected", "is", OpenMaya.MFnNumericData.kBoolean, 0)
        numAttrFn.storable = True
        numAttrFn.keyable = False
        numAttrFn.readable = True
        numAttrFn.writable = True
        numAttrFn.hidden = True
        OpenMaya.MPxNode.addAttribute(Collection.isolateSelected)
        
        Collection.attributeAffects(Collection.numIsolatedChildren, Collection.enabled)
        Collection.attributeAffects(Collection.numIsolatedAncestors, Collection.enabled)
        Collection.attributeAffects(Collection.isolateSelected, Collection.enabled)

    def typeId(self):
        return Collection.kTypeId

    def typeName(self):
        return Collection.kTypeName

    def _createSelector(self, parent=None, selArgs=None):
        """Create a selector node, and attach it to the collection.

        parent is an optional parent collection.  This method must be
        overridden by derived classes."""

        self.setSelectorType(parent.getSelector().kTypeName if parent else \
                             self.kDefaultSelectorTypeName)
        if parent:
            self.getSelector().minimalClone(parent.getSelector())

    def _createAndConnectSelector(self, typeName, selArgs=None):
        """Engine method for _createSelector.
    
        selArgs is an optional dictionary passed to _createSelectorNode."""
    
        newSelector = self._createSelectorNode(
            typeName, self.name()+'Selector', selArgs)
        cmds.connectAttr(newSelector + '.c', self.name() + '.selector')

    def _createSelectorNode(self, typeName, selectorName, selArgs):
        """Create the selector node.

        Can be overridden by derived classes."""
        return cmds.createNode(typeName, name=selectorName, skipSelect=True)
    
    def getSelectorType(self):
        try: return self.getSelector().kTypeName
        except: return None
    
    def setSelectorType(self, typeName):
        '''Sets the selector type of this collection.'''
        if self.getSelectorType() == typeName:
            return
        with undo.NotifyCtxMgr("Set selector type", self._selectorChanged):
            children = [child for child in self.getChildren() if isinstance(child, Collection)]
            # need to disconnect all selector children 
            # otherwise they get deleted along with their parent selector
            for child in children:
                child.getSelector().setParent(None)
            try: self._deleteSelector()
            except: pass
            self._createAndConnectSelector(typeName)
            parent = self.parent()
            selector = self.getSelector()
            if isinstance(parent, Collection):
                selector.setParent(parent.getSelector())
            for child in children:
                child.getSelector().setParent(selector)

    def _deleteSelector(self):
        # Because of unloaded or missing plugin, selector might be unknown node,
        # in which case getSelector() will raise.
        selectorName = utils.getSrcNodeName(
            utils.findPlug(self, Collection.aSelector))

        cmds.disconnectAttr(selectorName + '.c', self.name() + '.selector')
        utils.deleteNode(selectorName)

    def _getInputAttr(self, attr, dataBlock=None):
        return dataBlock.inputValue(attr) if dataBlock else OpenMaya.MPlug(self.thisMObject(), attr)
    
    def _getSelfEnabledPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Collection.selfEnabled)

    def _getIsolatePlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Collection.isolateSelected)

    def hasIsolatedAncestors(self, dataBlock=None):
        return self._getInputAttr(self.numIsolatedAncestors, dataBlock).asInt() > 0

    def hasIsolatedChildren(self, dataBlock=None):
        return self._getInputAttr(self.numIsolatedChildren, dataBlock).asInt() > 0
    
    def compute(self, plug, dataBlock):
        if plug == self.enabled:
            # We are enabled if:
            #
            # o The normal enabled computation is true (self enabled is true AND
            #   parent enabled is true).
            #
            # AND
            #
            # o We're in batch mode OR
            # o No node is isolated OR
            # o This node is isolated OR
            # o This node has isolate selected children OR
            # o This node has isolate selected ancestors.
            #
            value = computeEnabled.computeEnabled(self, dataBlock) and \
                (cmds.about(batch=True) or \
                dataBlock.inputValue(self.layerNumIsolatedChildren).asInt()==0 or \
                self.isIsolateSelected(dataBlock) or \
                self.hasIsolatedAncestors(dataBlock) or \
                self.hasIsolatedChildren(dataBlock))
            computeEnabled.setEnabledOutput(self, dataBlock, value)

            # The plug was successfully computed
            return self
        
        # Let the Maya parent class compute the plug
        return None

    def enabledChanged(self):
        layer = self.getRenderLayer()
        if layer:
            layer._collectionChanged(self)
        self.itemChangedRecursive()
    
    def isEnabled(self, dataBlock=None):
        return self._getInputAttr(self.enabled, dataBlock).asBool()
    
    def isSelfEnabled(self, dataBlock=None):
        return self._getInputAttr(self.selfEnabled, dataBlock).asBool()

    def setSelfEnabled(self, value):
        if value != self.isSelfEnabled():
            # pulling isEnabled will trigger enabledChanged 
            # (no matter if enable output value has changed or not)
            with undo.NotifyCtxMgr(kSet % (self.name(), 'enabled', value), self.enabledChanged):
                with undo.NotifyDecorateMgr(None, context.beforeEnabled(self), context.afterEnabled(self)):
                    cmds.setAttr(self.name()+".selfEnabled", 1 if value else 0)

    def itemChangedRecursive(self):
        for n in nodeList.forwardListGenerator(self):
            n.itemChangedRecursive()
        self.itemChanged()

    def isIsolateSelected(self, dataBlock=None):
        """ Get if isolate selected. Will always return False in batch mode """
        return False if cmds.about(batch=True) else self._getInputAttr(self.isolateSelected, dataBlock).asBool()

    def _notifyLayerIsolateSelectedChanged(self):
        layer = self.getRenderLayer()
        if layer:
            layer._collectionChanged(self)
            layer.itemChangedRecursive()

    def setIsolateSelected(self, value):
        if value != self.isIsolateSelected() and not cmds.about(batch=True):
            with undo.NotifyCtxMgr(kSet % (self.name(), 'isolateSelected', value), self._notifyLayerIsolateSelectedChanged):
                with undo.NotifyDecorateMgr(None, context.beforeIsolated(self), context.afterIsolated(self)):
                    # Use a command to support the undo mechanism
                    cmds.setAttr(self._getIsolatePlug().name(), value)
                    self._updateIsolateSelected(1 if value else -1)

    def getRenderLayer(self):
        # For hierarchical collections the parent
        # could be another collection, otherwise
        # the parent is always the render layer
        parent = self.parent()
        if isinstance(parent, Collection):
            return parent.getRenderLayer()
        return parent

    def _findSubcollectionForType(self, typeName):
        '''Finds the subcollection of this collection that will handle that typeName
           or creates it and returns it if it doesn't exist.'''

        if self.getSelector().getFilterType() == selector.Filters.kSets and \
                typeName != 'transform':
            xformCol = self._findSubcollectionForType('transform')
            return xformCol._findSubcollectionForType(typeName)

        filterType, customFilter = selector.Filters.getFiltersFor(typeName)

        def predicate(child):
            if not isinstance(child, Collection):
                return False
            sel = child.getSelector()
            return sel.kTypeName == selector.SimpleSelector.kTypeName and \
                   sel.getPattern() == "*" and \
                   len(sel.staticSelection) == 0 and \
                   sel.getFilterType() == filterType and \
                   (filterType != selector.Filters.kCustom or sel.getCustomFilterValue() == customFilter)

        def creator():
            name = self.name() + "_" + selector.Filters.names.get(filterType, customFilter)
            col = create(name)
            col.setSelectorType(selector.SimpleSelector.kTypeName)
            sel = col.getSelector()
            sel.setPattern('*')
            sel.setFilterType(filterType)
            sel.setCustomFilterValue(customFilter)
            return col

        return self.findChild(predicate, creator)

    @undo.chunk('Create and append an override')
    def createOverride(self, overrideName, overrideType):
        """ Add an override to the Collection using its node type id or type name."""
        # Note: No need to propagate the change notification
        #       as an empty override does not affect the collection
        over = override.create(overrideName, overrideType)
        if not over:
            raise Exception(kOverrideCreationFailed % overrideName)

        def selectorHasSetsFilter():
            return self.getSelector().getFilterType() == selector.Filters.kSets

        col = self
        if over.typeId() == typeIDs.shaderOverride:
            # special handle for shader override as they apply to shading
            # engines => create subcollection of shading engines
            if selectorHasSetsFilter() or not self.getSelector().acceptsType('shadingEngine'):
                col = self._findSubcollectionForType('shadingEngine')
        elif over.typeId() == typeIDs.materialOverride:
            # special handle for material override as they apply to dag nodes
            # when selector is filter on sets.
            if selectorHasSetsFilter():
                col = self._findSubcollectionForType('transform')
        col.appendChild(over)
        return over
    
    def _getOverrideType(self, plg, overrideType):
        '''Returns the override type that should be created for the given 
        plg in the given collection (self). Overrides that can't be relative will become absolute.'''
        if overrideType == typeIDs.connectionOverride:
            return overrideType
        return plg.overrideType(overrideType)

    @undo.chunk('Create and append an override')
    def _createOverride(self, plg, overrideType):
        over = override.create(plg.attributeName, self._getOverrideType(plg, overrideType))
        if not over:
            raise Exception(kOverrideCreationFailed % plg.attributeName)
        over.finalize(plg.name)

        typeName = OpenMaya.MFnDependencyNode(plg.node()).typeName
        collection = self if self.getSelector().acceptsType(typeName) else \
            self._findSubcollectionForType(typeName)
        collection.appendChild(over)
        return over
    
    @undo.chunk('Create and append an absolute override')
    def createAbsoluteOverride(self, nodeName, attrName):
        """ Add an absolute override to a collection """
        return self._createOverride(plug.Plug(nodeName,attrName), typeIDs.absOverride)
            
    @undo.chunk('Create and append a relative override')
    def createRelativeOverride(self, nodeName, attrName):
        """ Add a relative override to a collection """
        return self._createOverride(plug.Plug(nodeName,attrName), typeIDs.relOverride)
    
    @undo.chunk('Create and append a connection override')
    def createConnectionOverride(self, nodeName, attrName):
        """ Add a connection override to a collection """
        return self._createOverride(plug.Plug(nodeName,attrName), typeIDs.connectionOverride)

    @undo.chunk('Create and append a child collection')
    def _createCollection(self, collectionName, typeName):
        col = create(collectionName, typeName, parent=self)
        self.appendChild(col)
        return col

    def createCollection(self, collectionName):
        """ Add a child collection to the Collection. """
        return self._createCollection(collectionName, Collection.kTypeName)

    def _childAttached(self, child):
        '''Perform work to attach a child.

        The child has already been added to collection's list when this
        method is called.'''

        with undo.NotifyCtxMgr(kChildAttached % (self.name(), child.name()), self.itemChanged):
            # Once inserted, hook up the child's parentEnabled input to our
            # enabled output.  Use existing command for undo / redo purposes.
            cmds.connectAttr(self.name() + '.enabled',
                             child.name() + '.parentEnabled')
            if isinstance(child, Collection):
                child.getSelector().setParent(self.getSelector())
                child._attach(self.getRenderLayer())
                
            layer = self.getRenderLayer()
            if layer:
                layer.descendantAdded(child)
        
    def _detachChild(self, child):
        '''Perform work to detach a child.

        The child has not yet been removed from the collection's list when
        this method is called.'''

        with undo.NotifyCtxMgr(kChildDetached % (self.name(), child.name()), self.itemChanged):
            # Disconnect the child's parentEnabled input from our enabled
            # output.  Use existing command for undo / redo purposes.
            childParentEnabled = child.name() + '.parentEnabled'
            cmds.disconnectAttr(self.name() + '.enabled', childParentEnabled)

            # Child parentEnabled will retain its last value, so set it
            # to True in case the collection gets parented to the render layer.
            cmds.setAttr(childParentEnabled, 1)

            if isinstance(child, Collection):
                # Handle unknown selector type (e.g. from unavailable plugin)
                # gracefully.
                if child.getSelectorType() is not None:
                    child.getSelector().setParent(None)
                child._detach(self.getRenderLayer())

    def _attach(self, layer):
        """Attach this collection."""
        self._connectLayerIsolatedChildren(layer)

        # Number of isolated children doesn't change when we attach.
        # Update isolated children of our ancestors.
        self._updateAncestorsIsolatedChildren(
            self.getNumIsolatedChildren(includeSelf=True))

        # Update isolated ancestors of ourselves and our children.
        self._updateChildrenIsolatedAncestors(
            self._computeIsolatedAncestors(), includeSelf=True)
            
    def _detach(self, layer):
        """Detach this collection."""
        self._disconnectLayerIsolatedChildren(layer)
        
        # Number of isolated children doesn't change when we detach.
        # Update isolated children of our ancestors.
        self._updateAncestorsIsolatedChildren(
            -self.getNumIsolatedChildren(includeSelf=True))

        # Update isolated ancestors of ourselves and our children.
        self._updateChildrenIsolatedAncestors(
            -self.getNumIsolatedAncestors(), includeSelf=True)


    @undo.chunk('Append to collection')
    def appendChild(self, child):
        """ Add a child as the highest-priority child."""
        if child.typeId()==RenderSettingsCollection.kTypeId \
            or child.typeId()==LightsCollection.kTypeId:
            raise RuntimeError(kIncorrectChildType % child.typeName())

        nodeList.append(self, child)
        self._childAttached(child)

    @undo.chunk('Attach to collection')
    def attachChild(self, pos, child):
        """ Attach a child at a specific position. """
        if child.typeId()==RenderSettingsCollection.kTypeId \
            or child.typeId()==LightsCollection.kTypeId:
            raise RuntimeError(kIncorrectChildType % child.typeName())

        nodeList.insert(self, pos, child)
        self._childAttached(child)

    @undo.chunk('Detach from collection')
    def detachChild(self, child):
        """ Detach a child whatever its position. """
        unapply(child) # NoOp if not applied; otherwise commands are used
        # Must perform detach operations before removing from list,
        # otherwise parenting information is gone.
        self._detachChild(child)
        nodeList.remove(self, child)

    def getChildren(self, cls=childNode.ChildNode):
        """ Get the list of all children. 
        Optionally only the children matching the given class. """
        return list(nodeList.forwardListNodeClassGenerator(self, cls))
    
    def hasChildren(self):
        return self.findChild(lambda child: True) is not None

    def getCollections(self):
        return self.getChildren(cls=Collection)
        
    def getCollectionByName(self, collectionName, nested=False):
        for collection in nodeList.forwardListNodeClassGenerator(self, cls=Collection):
            if collection.name() == collectionName:
                return collection
            elif nested:
                collection2 = collection.getCollectionByName(collectionName, True)
                if collection2:
                    return collection2
        return None
        
    def findChild(self, predicate, creator=None):
        '''Find the child of this collection satisfying the predicate function or creates it
        with the creator function if not found and a creator function is specified.
        Function signatures are:
          predicate(childNode): returns boolean.
          creator(void) : returns the created node.'''
        for child in nodeList.forwardListNodeClassGenerator(self, childNode.ChildNode):
            if predicate(child):
                return child
        if not creator:
            return None
        child = creator()
        self.appendChild(child)
        return child

    def getChild(self, childName, cls=childNode.ChildNode):
        """ Look for an existing child by name and optionally class.

            @type childName: string
            @param childName: Name of child to look for
            @type cls: class name
            @param cls: Class name for the type of class to look for
            @rtype: Child model instance
            @return: Found instance or throw an exception
        """
        if not childName:
            raise Exception(kInvalidChildName)

        for child in nodeList.forwardListNodeClassGenerator(self, cls):
            if child.name() == childName:
                return child

        raise Exception(kUnknownChild % (childName, self.name()))

    def isAbstractClass(self):
        # Override method inherited from base class: not an abstract class.
        return False

    def getSelector(self):
        """Return the selector user node for this collection.

        If there is no selector node, or if the selector node does not
        have an MPxNode interface (e.g. an unknown node), an exception
        of type Exception is raised.
        """
        selector = utils.getSrcUserNode(
            utils.findPlug(self, Collection.aSelector))
        if (selector is None):
            raise Exception(kCollectionMissingSelector % self.name())
        return selector

    @context.applyCollection
    def apply(self):
        """ Apply all children in this collection. """
        with profiler.ProfilerMgr('Collection::apply'):
            # Apply all our children to the selection
            for child in nodeList.forwardListGenerator(self):
                child.apply()

    @context.applyCollection
    def postApply(self):
        '''Post applies all children in this collection. This function may be called to apply a collection (with contained overrides)
        after the layer was set visible. It allows inserting new overrides in the currently visible layer
        without the need to toggle visibility.'''
        with profiler.ProfilerMgr('Collection::postApply'):
            # Post apply all our children
            for child in nodeList.forwardListGenerator(self):
                child.postApply()

    @context.unapplyCollection
    def unapply(self):
        """Unapply all children in this collection."""
        with profiler.ProfilerMgr('Collection::unapply'):
            for child in nodeList.reverseListGenerator(self):
                child.unapply()
    
    @context.updateCollection
    def update(self):
        with profiler.ProfilerMgr('Collection::update'):
            for n in nodeList.forwardListGenerator(self):
                n.update()
    
    def overridesConnections(self):
        for n in nodeList.forwardListGenerator(self):
            if n.overridesConnections():
                return True
        return False

    def hasOverridesRecursive(self):
        # Check if the collection or any of its subcollections
        # have any overrides at all.
        return next(utils.getOverridesRecursive(self), None) is not None

    def hasApplyOverridesRecursive(self):
        # Check if the collection or any of its subcollections
        # have any apply overrides at all.
        for ovr in utils.getOverridesRecursive(self):
            if ovr.hasApplyOverrides():
                return True
        return False

    def getOverrides(self):
        return self.getChildren(cls=override.Override)

    # Collection interface as list of children.
    # These methods implement the list requirements for the nodeList module.
    #
    # The list front and back are destination plugs connected to the child
    # node's message plug (which is a source).
    def _getFrontAttr(self):
        return Collection.childLowest

    def _getBackAttr(self):
        return Collection.childHighest

    def _getListItemsAttr(self):
        return Collection.children

    def _preChildDelete(self, child):
        # Private interface for child to inform its parent that it is
        # about to be deleted.  Remove the child from our list.
        self.detachChild(child)

    def _selectedNodesChanged(self):
        """ Ownership of this collection or one of its children changed """
        layer = self.getRenderLayer()
        if layer:
            layer._selectedNodesChanged(self)
        self.itemChanged()

    def _selectorChanged(self):
        """Selector of this collection changed.

        Identical to _selectedNodesChanged(), except that the itemChanged()
        notification is given with selectorChanged=True."""
        layer = self.getRenderLayer()
        if layer:
            layer._selectedNodesChanged(self)
        self.itemChanged(selectorChanged=True)

    def _refreshRendering(self):
        ''' Some changes impose to refresh the rendering for the visible layer only. '''
        parent = self.parent()
        if parent:
            parent._refreshRendering()

    def getLayerNumIsolatedChildren(self):
        return OpenMaya.MPlug(
            self.thisMObject(), Collection.layerNumIsolatedChildren).asInt()

    def _getNumIsolatedChildrenPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Collection.numIsolatedChildren)

    def getNumIsolatedChildren(self, includeSelf=False):
        nic = self._getNumIsolatedChildrenPlug().asInt()
        if includeSelf and self.isIsolateSelected():
            nic += 1
        return nic

    def _getNumIsolatedAncestorsPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Collection.numIsolatedAncestors)

    def getNumIsolatedAncestors(self):
        return self._getNumIsolatedAncestorsPlug().asInt()

    def _computeIsolatedAncestors(self):
        return reduce(
            lambda nb, c: nb + 1 if c.isIsolateSelected() else nb,
            self.ancestorCollections(), 0)

    # See comments in RenderLayer._updateIsolateSelected.
    def _updateNumIsolatedChildren(self, val):
        # Use a command to support the undo mechanism
        if val != 0:
            newVal = self.getNumIsolatedChildren() + val
            cmds.setAttr(self._getNumIsolatedChildrenPlug().name(), newVal)

    def _updateNumIsolatedAncestors(self, val):
        # Use a command to support the undo mechanism
        if val != 0:
            newVal = self.getNumIsolatedAncestors() + val 
            cmds.setAttr(self._getNumIsolatedAncestorsPlug().name(), newVal)

    def _updateIsolateSelected(self, val):
        self._updateAncestorsIsolatedChildren(val)
        self._updateChildrenIsolatedAncestors(val)

    def _updateAncestorsIsolatedChildren(self, val):
        layer = self.getRenderLayer()
        if layer:
            layer._updateIsolateSelected(val)
        for c in self.ancestorCollections():
            c._updateNumIsolatedChildren(val)

    def _updateChildrenIsolatedAncestors(self, val, includeSelf=False):
        # Tell descendants there has been a change in their ancestors'
        # isolate select.
        for c in traverse.depthFirst(self, collections):
            if c is self and not includeSelf:
                continue
            c._updateNumIsolatedAncestors(val)
            
    def _connectLayerIsolatedChildren(self, layer):
        # Connect subtree to layer's isolated children attribute.
        if layer:
            for c in traverse.depthFirst(self, collections):
                c._connectSelfLayerIsolatedChildren(layer)

    def _disconnectLayerIsolatedChildren(self, layer):
        # Disconnect subtree from layer's isolated children attribute.
        if layer:
            for c in traverse.depthFirst(self, collections):
                c._disconnectSelfLayerIsolatedChildren(layer)

    def _connectSelfLayerIsolatedChildren(self, layer):
        if layer:
            # Use existing command for undo / redo purposes.
            cmds.connectAttr(layer.name() + '.numIsolatedChildren',
                             self.name() + '.parentNumIsolatedChildren')

    def _disconnectSelfLayerIsolatedChildren(self, layer):
        if layer:
            # Use existing command for undo / redo purposes.
            cmds.disconnectAttr(layer.name() + '.numIsolatedChildren',
                                self.name() + '.parentNumIsolatedChildren')

    def _importChild(self, childName, nodeType, selArgs=None):
        name = cmds.createNode(nodeType, name=childName, skipSelect=True)
        child = utils.nameToUserNode(name)
        if isinstance(child, Collection):
            child._createSelector(None, selArgs)
        self.appendChild(child)
        return child

    def activate(self):
        '''
        Called when this list item is inserted into the list.
        Override this method to do any scene specific initialization.
        '''
        self.getSelector().activate()

    def deactivate(self):
        '''
        Called when this list item is removed from the list.
        Override this method to do any scene specific teardown.
        '''
        # Handle unknown selector type (e.g. from unavailable plugin)
        # gracefully.
        if self.getSelectorType() is not None:
            self.getSelector().deactivate()

    def _encodeProperties(self, dict):
        super(Collection, self)._encodeProperties(dict)
        dict[self._getSelfEnabledPlug().partialName(useLongNames=True)] = self.isSelfEnabled()
        dict[self._getIsolatePlug().partialName(useLongNames=True)] = self.isIsolateSelected()
        
        if self.getSelectorType() == selector.BasicSelector.kTypeName: # backward comp with 2016 R2
            selectorDict = dict
        else:
            selectorDict = {}
            dict[jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME] = { self.getSelectorType() : selectorDict }
        self.getSelector()._encodeProperties(selectorDict)
        
        dict[jsonTranslatorGlobals.CHILDREN_ATTRIBUTE_NAME] = jsonTranslatorUtils.encodeObjectArray(self.getChildren())

    def _decodeChildren(self, children, mergeType, prependToName):
        jsonTranslatorUtils.decodeObjectArray(children,
                                              jsonTranslatorUtils.MergePolicy(self.getChild, 
                                                                              self._importChild, 
                                                                              mergeType, 
                                                                              prependToName))

    def _decodeProperties(self, dict, mergeType, prependToName):
        super(Collection, self)._decodeProperties(dict, mergeType, prependToName)
        if self._getSelfEnabledPlug().partialName(useLongNames=True) in dict:
            self.setSelfEnabled(dict[self._getSelfEnabledPlug().partialName(useLongNames=True)])

        if self._getIsolatePlug().partialName(useLongNames=True) in dict:
            self.setIsolateSelected(dict[self._getIsolatePlug().partialName(useLongNames=True)])
        
        if jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME not in dict: # backward comp with 2016 R2
            self.setSelectorType(selector.BasicSelector.kTypeName)
            selectorProperties = dict
        else:
            selectorType = dict[jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME].keys()[0]
            if self.getSelectorType() != selectorType:
                self.setSelectorType(selectorType)
            selectorProperties = dict[jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME].values()[0]
        self.getSelector()._decodeProperties(selectorProperties)

        if jsonTranslatorGlobals.CHILDREN_ATTRIBUTE_NAME in dict:
            self._decodeChildren(dict[jsonTranslatorGlobals.CHILDREN_ATTRIBUTE_NAME],
                                 mergeType, 
                                 prependToName)

    def acceptImport(self):
        super(Collection, self).acceptImport()
        for child in self.getChildren():
            child.acceptImport()
            
    def isSelfAcceptableChild(self):
        """Overridden instances that return False, prevent copy/paste of the collection type to itself."""
        return True

    def isAcceptableChild(self, modelOrData):
        """ Check if the model could be a child"""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            isOverride = modelOrData.typeName() in _overrideTypes
            parentTypeName = modelOrData.parentTypeName
        else:
            isOverride = isinstance(modelOrData, override.Override)
            parentTypeName = modelOrData.parent().typeName()
        return isOverride and parentTypeName == self.typeName() or (modelOrData.typeName() == self.typeName() and self.isSelfAcceptableChild())
    def isTopLevel(self):
        """Is the collection's parent a render layer?"""
        # Don't have access to renderLayer.RenderLayer, type check on
        # Collection instead.
        return not isinstance(self.parent(), Collection)

    def ancestorCollections(self):
        """Return this collection's ancestors.

        Neither the collection itself, nor the render layer, are included
        in the ancestors.  Therefore, a top-level collection has no
        ancestors."""

        parent = self.parent()
        while isinstance(parent, Collection):
            yield parent
            parent = parent.parent()

    def isEmptyRecursive(self):
        """ Return whether or not the collection or any of its parents is empty """
        # Base Case 1: if the current collection's selector is empty, then the
        # collection is obviously empty, meaning that there is no need to look
        # at its parents.
        # Base Case 2: if the current collection's parent is not a Collection,
        # than False will be returned since we already established that the
        # current collection is not empty and it has no parent Collection.
        # Recursive Case: if the current collection does not have an empty
        # selector and has a parent Collection, than we return whether or not
        # any of its parents are empty. (any one parent Collection with an
        # empty selector results in the current Collection being empty)
        return self.getSelector().isEmpty() or \
               (isinstance(self.parent(), Collection) and self.parent().isEmptyRecursive())

    def isTraversingConnections(self):
        return self.getSelector().isTraversingConnections()

class LightsCollection(Collection):
    """
    LightsCollection node.

    A collection node specific for grouping light sources
    and overrides on those light sources.

    This collection should have all light sources as member by default. All nodes 
    matching the light classification should be returned by the selector
    on this collection.

    """

    kTypeId = typeIDs.lightsCollection
    kTypeName = 'lightsCollection'

    @staticmethod
    def creator():
        return LightsCollection()

    @staticmethod
    def initializer():
        # Inherit all attributes from parent class
        LightsCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(LightsCollection, self).__init__()

    def typeId(self):
        return LightsCollection.kTypeId

    def typeName(self):
        return LightsCollection.kTypeName

    @staticmethod
    def containsNodeName(nodeName):
        import maya.app.renderSetup.lightEditor.model.typeManager as typeMgr
        node = commonUtils.nameToNode(nodeName)
        # TODO: For improved separation of concerns, we should untangle the light editor data model 
        # and the render setup data model at some point. Logged as MAYA-84151.
        return ((typeMgr.isLight(node) or typeMgr.isLightEditorItem(node)) if node else False)

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(selector.LightsCollectionSelector.kTypeName)

        # Make it select all light sources in the scene
        self.getSelector().setPattern("*")
        self.getSelector().setFilterType(selector.Filters.kLights)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def createCollection(self, collectionName):
        """ Add a lights child collection to the Collection. """
        return self._createCollection(collectionName, LightsChildCollection.kTypeName)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection.
           
           We want to prevent copying LightsChildCollections in the same 
           LightsCollection at the expense of not being able to copy 
           LightsChildCollections between different LightsCollections.
        """
        return False

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)


class LightsChildCollection(Collection):
    """
        LightsChildCollection node.

        A child collection node specific for one single light source
        and overrides on this light source.
    
    """

    kTypeId = typeIDs.lightsChildCollection
    kTypeName = 'lightsChildCollection'

    @staticmethod
    def creator():
        return LightsChildCollection()

    @staticmethod
    def initializer():
        # Inherit all attributes from parent class
        LightsChildCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(LightsChildCollection, self).__init__()

    def typeId(self):
        return LightsChildCollection.kTypeId

    def typeName(self):
        return LightsChildCollection.kTypeName

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(selector.LightsCollectionSelector.kTypeName)
        
        # Only accepts light sources.
        self.getSelector().setFilterType(selector.Filters.kLights)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection.
        
           Pasting is prevented because the Light Editor considers only the 
           first override in the LightsChildCollection. Additionally dragging 
           is prevented between overrides in LightsChildCollections to prevent 
           dragging between incompatible LightsChildCollection types 
           (ie. point light, spot light)
        """
        return False


class RenderSettingsCollection(Collection):
    """
    Render Settings Collection node.

    This collection has an ordered list of children, and a static & const selector
    to determine nodes to which the children apply. The list of nodes is based
    on the selected renderer at the time of creation.
    
    MAYA-66757:
    - A base collection will be needed to factorize commonalities and segregate differences.
    - A static selector is needed which could be the existing static selection or an object set.
    - The name is read-only.
    - The selector content is read-only
    - The render name should be part of the collection so that the settings are clearly linked 
      to the used renderer, or linked using a plug

    """

    kTypeId = typeIDs.renderSettingsCollection
    kTypeName = 'renderSettingsCollection'

    # Type of selector created by this collection
    kSelectorTypeName = selector.SimpleSelector.kTypeName
    
    # The number of isolate selected children in a Render Settings Collection
    numIsolatedRenderSettingsChildren = OpenMaya.MObject()

    @staticmethod
    def creator():
        return RenderSettingsCollection()

    @staticmethod
    def initializer():
        # A render settings collection is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other attributes.
        RenderSettingsCollection.inheritAttributesFrom(Collection.kTypeName)

        # Setup our attribute for keeping track of the number of isolated render settings children
        RenderSettingsCollection.numIsolatedRenderSettingsChildren = computeEnabled.createHiddenIntAttribute("numIsolatedRenderSettingsChildren", "nrc")
        RenderSettingsCollection.addAttribute(RenderSettingsCollection.numIsolatedRenderSettingsChildren)

    def __init__(self):
        super(RenderSettingsCollection, self).__init__()

    @staticmethod
    def containsNodeName(nodeName):
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        return nodeName in renderSettings.getDefaultNodes()

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(self.kSelectorTypeName)

        # Set the default nodes as static selection
        # Note: Some renderers could return nodes which do not exist yet.
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        self.getSelector().staticSelection.setWithoutExistenceCheck(renderSettings.getDefaultNodes())
        self.getSelector().setFilterType(selector.Filters.kAll)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def typeId(self):
        return RenderSettingsCollection.kTypeId

    def typeName(self):
        return RenderSettingsCollection.kTypeName

    def appendChild(self, child):
        if type(child) != RenderSettingsChildCollection and isinstance(child, Collection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsCollection, self).appendChild(child)

    def attachChild(self, pos, child):
        if isinstance(child, Collection) and not isinstance(child, RenderSettingsChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsCollection, self).attachChild(pos, child)

    def createCollection(self, collectionName):
        """ Add a child collection to the Collection. """
        return self._createCollection(collectionName, RenderSettingsChildCollection.kTypeName)

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection."""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            isOverride = modelOrData.typeName() in _overrideTypes
            parentTypeName = modelOrData.parentTypeName
        else:
            isOverride = isinstance(modelOrData, override.Override)
            parentTypeName = modelOrData.parent().typeName()

        return modelOrData.typeName() == RenderSettingsChildCollection.kTypeName or \
            modelOrData.typeName() not in _specialCollectionTypes and \
            (isOverride and parentTypeName in [RenderSettingsCollection.kTypeName, RenderSettingsChildCollection.kTypeName]) or \
            (modelOrData.typeName() == self.typeName() and self.isSelfAcceptableChild() and self.typeName() != RenderSettingsCollection.kTypeName)
    
    def _getOverrideType(self, plg, overrideType):
        overrideType = super(RenderSettingsCollection, self)._getOverrideType(plg, overrideType)
        return {  typeIDs.absOverride.id() : typeIDs.absUniqueOverride,
                  typeIDs.relOverride.id() : typeIDs.relUniqueOverride,
                  typeIDs.connectionOverride.id() : typeIDs.connectionUniqueOverride }[overrideType.id()]

    def _getNumIsolatedRenderSettingsChildrenPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), RenderSettingsCollection.numIsolatedRenderSettingsChildren)

    # The passed in value is an integer offset on the number of isolate
    # selected children in this layer.
    def _updateIsolateSelected(self, val):
        # Use a command to support the undo mechanism
        if val != 0:
            newVal = self._getNumIsolatedRenderSettingsChildrenPlug().asInt() + val
            cmds.setAttr(self._getNumIsolatedRenderSettingsChildrenPlug().name(), newVal)


class RenderSettingsChildCollection(Collection):
    """
    Render Settings Sub Collection node.
    """

    kTypeId = typeIDs.renderSettingsChildCollection
    kTypeName = 'renderSettingsChildCollection'

    # Type of selector created by this collection
    kSelectorTypeName = selector.SimpleSelector.kTypeName

    @staticmethod
    def creator():
        return RenderSettingsChildCollection()

    @staticmethod
    def initializer():
        # A render settings collection is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other attributes.
        RenderSettingsChildCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(RenderSettingsChildCollection, self).__init__()

    @staticmethod
    def containsNodeName(nodeName):
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        return nodeName in renderSettings.getDefaultNodes()

    def getRenderSettingsChildCollections(self):
        return self.getChildren(cls=RenderSettingsChildCollection)

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(self.kSelectorTypeName)

        # Set the default nodes as static selection
        # Note: Some renderers could return nodes which do not exist yet.
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        self.getSelector().staticSelection.setWithoutExistenceCheck(renderSettings.getDefaultNodes())
        self.getSelector().setFilterType(selector.Filters.kAll)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def typeId(self):
        return RenderSettingsChildCollection.kTypeId

    def typeName(self):
        return RenderSettingsChildCollection.kTypeName

    def superTypeName(self):
        return Collection.kTypeName

    def appendChild(self, child):
        if type(child) != RenderSettingsChildCollection and isinstance(child, Collection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsChildCollection, self).appendChild(child)

    def attachChild(self, pos, child):
        if isinstance(child, Collection) and not isinstance(child, RenderSettingsChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsChildCollection, self).attachChild(pos, child)

    def _createCollection(self, collectionName, typeName):
        col = create(collectionName, typeName, parent=self)
        self.appendChild(col)
        return col

    def createCollection(self, collectionName):
        """ Add a child collection to the Collection. """
        return self._createCollection(collectionName, RenderSettingsChildCollection.kTypeName)

    def compute(self, plug, dataBlock):
        return super(RenderSettingsChildCollection, self).compute(plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection."""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            isOverride = modelOrData.typeName() in _overrideTypes
            parentTypeName = modelOrData.parentTypeName
        else:
            isOverride = isinstance(modelOrData, override.Override)
            parentTypeName = modelOrData.parent().typeName()

        return modelOrData.typeName() not in _specialCollectionTypes and \
            (isOverride and parentTypeName in [RenderSettingsCollection.kTypeName, RenderSettingsChildCollection.kTypeName]) or \
            (modelOrData.typeName() == self.typeName() and self.isSelfAcceptableChild())

    def _getOverrideType(self, plg, overrideType):
        overrideType = super(RenderSettingsChildCollection, self)._getOverrideType(plg, overrideType)
        return typeIDs.absUniqueOverride if overrideType == typeIDs.absOverride else typeIDs.relUniqueOverride

    def _getRenderSettingsCollection(self):
        ancestors = self.ancestors()
        for a in ancestors:
            if type(a) is RenderSettingsCollection:
                return a
        return None

    def _updateAncestorsIsolatedChildren(self, val):
        rsc = self._getRenderSettingsCollection()
        if rsc:
            rsc._updateIsolateSelected(val)
        for c in self.ancestorCollections():
            c._updateNumIsolatedChildren(val)

    def _connectSelfLayerIsolatedChildren(self, layer):
        if layer and type(self) is RenderSettingsChildCollection:
            rsc = self._getRenderSettingsCollection()
            # Use existing command for undo / redo purposes.
            cmds.connectAttr(rsc.name() + '.numIsolatedRenderSettingsChildren',
                             self.name() + '.parentNumIsolatedChildren')

    def _disconnectSelfLayerIsolatedChildren(self, layer):
        if layer:
            rsc = self._getRenderSettingsCollection()
            # Use existing command for undo / redo purposes.
            cmds.disconnectAttr(rsc.name() + '.numIsolatedRenderSettingsChildren',
                                self.name() + '.parentNumIsolatedChildren')

    def getRenderSettingsChildCollectionByName(self, renderSettingsChildCollectionName, nested=False):
        for rscc in nodeList.forwardListNodeClassGenerator(self, cls=RenderSettingsChildCollection):
            if rscc.name() == renderSettingsChildCollectionName:
                return rscc
            elif nested:
                rscc2 = rscc.getRenderSettingsChildCollectionByName(renderSettingsChildCollectionName, True)
                if rscc2:
                    return rscc2
        return None

    def isTraversingConnections(self):
        return False

class AOVCollection(Collection):
    """
    AOV (arbitrary output variable) parent collection node.
    """

    kTypeId = typeIDs.aovCollection
    kTypeName = 'aovCollection'

    
    @staticmethod
    def creator():
        return AOVCollection()

    @staticmethod
    def initializer():
        # An AOV collection is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other attributes.
        AOVCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(AOVCollection, self).__init__()

    @staticmethod
    def containsNodeName(nodeName):
        callbacks = rendererCallbacks.getCallbacks(rendererCallbacks.CALLBACKS_TYPE_AOVS)
        try:
            callbacks.getAOVName(nodeName)
            return True
        except:
            return False

    def _createSelector(self, parent=None, selArgs=None):
        # Selector type name argument is ignored.
        self._createAndConnectSelector('')
        
    def _createSelectorNode(self, typeName, selectorName, selArgs):
        # Ignore the argument selector type name: get the AOV collection
        # selector from the AOV renderer callback.
        callbacks = rendererCallbacks.getCallbacks(rendererCallbacks.CALLBACKS_TYPE_AOVS)
        return callbacks.getCollectionSelector(selectorName)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def typeId(self):
        return AOVCollection.kTypeId

    def typeName(self):
        return AOVCollection.kTypeName

    def appendChild(self, child):
        if isinstance(child, Collection) and not isinstance(child, AOVChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(AOVCollection, self).appendChild(child)

    def attachChild(self, pos, child):
        if isinstance(child, Collection) and not isinstance(child, AOVChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(AOVCollection, self).attachChild(pos, child)

    # This should never be called, as AOVCollections are created in renderLayer.py in aovCollectionInstance()
    def _createCollection(self, collectionName, typeName):
        raise RuntimeError(kIncorrectChildType % typeName)

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """ Check if the model could be a child"""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            parentTypeName = modelOrData.parentTypeName
        else:
            parentTypeName = modelOrData.parent().typeName()
        return parentTypeName == self.typeName() and modelOrData.typeName() == AOVChildCollection.kTypeName

class AOVChildCollection(Collection):
    """
        AOV (arbitrary output variable) Child Collection node.
    """

    kTypeId = typeIDs.aovChildCollection
    kTypeName = 'aovChildCollection'

    @staticmethod
    def creator():
        return AOVChildCollection()

    @staticmethod
    def initializer():
        # Inherit all attributes from parent class
        AOVChildCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(AOVChildCollection, self).__init__()

    def containsNodeName(self, nodeName):
        return nodeName in self.getSelector().getAbsoluteNames()

    def typeId(self):
        return AOVChildCollection.kTypeId

    def typeName(self):
        return AOVChildCollection.kTypeName

    def _createSelector(self, parent=None, selArgs=None):
        # Selector type name argument is ignored.
        self._createAndConnectSelector('', selArgs)
        
    def _createSelectorNode(self, typeName, selectorName, selArgs):
        # Ignore the argument selector type name: get the AOV child
        # collection selector from the AOV renderer callback.
        #
        # selArgs is a dictionary for selector argument 
        # construction.  It must contain a value for 'aovName'.
        callbacks = rendererCallbacks.getCallbacks(rendererCallbacks.CALLBACKS_TYPE_AOVS)
        return callbacks.getChildCollectionSelector(selectorName, selArgs['aovName'])

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isSelfAcceptableChild(self):
        """This code prevents copy/paste of AOV child collections to themselves/other AOV child collections."""
        return False
        

@undo.chunk('Create collection')
@namespace.root
def create(name, nodeType=Collection.kTypeName, parent=None, **selArgs):
    """ Create a collection.

    Returns the MPxNode object corresponding to the created
    collection node.  A RuntimeError is raised in case of error.
    The selArgs keyword arguments are passed along to the selector creation.

    This function is undoable.
    
    """
    # collection names should never contain namespace delimiter or other invalid characters
    # collections belong to current namespace (i.e. root)
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    if isinstance(nodeType, basestring):
        typeName = nodeType
    else:
        typeName = cmds.objectType(typeFromTag=nodeType.id())

    # To avoid writing a command to implement collection creation,
    # re-use existing name-based commands for undo / redo purposes, since
    # collection creation is not performance-critical.  If the name
    # flag is specified, it cannot be an empty string.

    returnCollectionName = cmds.createNode(
        typeName, name=name, skipSelect=True) if name else \
        cmds.createNode(typeName, skipSelect=True)
    collection = utils.nameToUserNode(returnCollectionName)

    collection._createSelector(parent=parent, selArgs=selArgs)

    return collection


@undo.chunk('Delete collection')
def delete(collection):
    """Remove the argument collection from the scene.

    All overrides and sub-collections in the collection are removed."""
    
    # Inform our parent (if any) of upcoming delete.
    # This will remove the collection from its parent,
    # and will trigger deactivation of the collection
    # causing it and the selector to stop listening to scene and attribute changes.
    # Need to call _preChildDelete before removing children, otherwise we lose the parenting information 
    # to the children which may be used by the parent (ex: renderLayers use that information
    # to determine if they need to be refreshed).
    parent = collection.parent()
    if parent:
        parent._preChildDelete(collection)
    
    # Delete the children.
    for child in collection.getChildren():
        if isinstance(child, Collection):
            delete(child)
        else:
            override.delete(child)

    # Deleting the selector means unhooking the selector node
    # from the collection and removing it from the scene.
    collection._deleteSelector()

    # Deleting the node will remove it from the scene.
    utils.deleteNode(collection)


@undo.chunk('Unapply a collection')
def unapply(collection):
    ''' Command to unapply a collection '''
    if isinstance(collection, Collection):
        for c in collection.getChildren():
            unapply(c)
    else:
        # End of recursion so unapply the override
        #  using a command
        override.UnapplyCmd.execute(collection)

def getAllCollectionClasses():
    """ Returns the list of Collection subclasses """
    return commonUtils.getSubClasses(Collection)
_specialCollectionTypes = { c.kTypeName for c in getAllCollectionClasses() if c != Collection }
_overrideTypes = { o.kTypeName for o in overrideUtils.getAllOverrideClasses() }
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
