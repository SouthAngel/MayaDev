"""
    This module defines private class and functions related to RenderSetup.
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)


import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya
import maya.app.renderSetup.model.undo as undo
import maya.app.renderSetup.model.namespace as namespace
import maya.app.renderSetup.model.renderLayerSwitchInfo as renderLayerSwitchInfo
import maya.app.renderSetup.common.guard as guard

import time
import logging

logger = logging.getLogger(__name__)

kCmdPrivate = maya.stringTable['y_renderSetupPrivate.kCmdPrivate' ]
kSwitchVisibleRenderLayer = maya.stringTable['y_renderSetupPrivate.kSwitchVisibleRenderLayer' ]

def _renderSetupInstance():
    # Avoid cyclic dependency between this module and renderSetup.
    import maya.app.renderSetup.model.renderSetup as renderSetup
    return renderSetup.instance()

class SwitchVisibleRenderLayerCmd(OpenMaya.MPxCommand):
    """Command to switch the visible layer.

    This command is a private implementation detail of this module and should
    not be called otherwise.
    """

    kCmdName = 'renderSetupSwitchVisibleRenderLayer'

    # Command data.  Must be set before creating an instance of the command
    # and executing it.  Ownership of this data is taken over by the
    # instance of the command.
    
    newLayer = None

    def isUndoable(self):
        return True

    def doIt(self, args):
        # Completely ignore the MArgList argument, as it's unnecessary:
        # arguments to the commands are passed in Python object form
        # directly to the command's constructor.

        if self.newLayer is None:
            cmds.warning(kCmdPrivate % self.kCmdName)
            return

        self.oldLayer = _renderSetupInstance().getVisibleRenderLayer()        
        self.redoIt()

    @staticmethod   
    def execute(newLayer):
        """ Switch to given RenderLayer """
        SwitchVisibleRenderLayerCmd.newLayer = newLayer
        with undo.CtxMgr(kSwitchVisibleRenderLayer % newLayer.name()):
            with namespace.RootNamespaceGuard():
                cmds.renderSetupSwitchVisibleRenderLayer()
        SwitchVisibleRenderLayerCmd.newLayer = None

    @staticmethod
    def creator():
        return SwitchVisibleRenderLayerCmd(SwitchVisibleRenderLayerCmd.newLayer)

    def __init__(self, newLayer):
        super(SwitchVisibleRenderLayerCmd, self).__init__()
        self.newLayer = newLayer
        self.oldLayer = None
        self.savedLayerCache = None

    def _switchToLayer(self, oldLayer, newLayer):
        # renderLayer.RenderLayer._updateLegacyRenderLayerVisibility compares
        # its cache with its current members.  On undo/redo, we do not want this
        # comparison to fail, because it will trigger the commands twice 
        # (once in _updateLegacyRenderLayerVisibility itself and once because
        # they are in the undo/redo chunk).  This incorrectly causes the redo
        # stack to be cleared and replaced with a new command.
        # 
        # To avoid this, we save the cache to reassign it in case of undo/redo.
        # The first time it's done (through the doIt method), it will go
        # into the _updateLegacyRenderLayerVisibility condition, as desired.
        # 
        # In short, we avoid using commands in undoIt/redoIt since they would
        # be added on the undo/redo stack, but only use commands during doIt.
        startLayerSwitch = time.clock()
        with renderLayerSwitchInfo.SwitchLayerContext(oldLayer, newLayer):
            self._saveAndRestoreCache(oldLayer, newLayer)

            try:
                oldLayer.unapply()
            except Exception as e:
                OpenMaya.MGlobal.displayError(
                    'Unapply layer %s failed: %s' % (oldLayer.name(), str(e)))
                raise

            try:
                newLayer.apply()
            except Exception as e:
                OpenMaya.MGlobal.displayError(
                    'Apply layer %s failed: %s' % (newLayer.name(), str(e)))
                raise

            newLayer._updateLegacyRenderLayerVisibility()
            newLayer.makeVisible()
            oldLayer.itemChanged()
            newLayer.itemChanged()

            _renderSetupInstance()._notifyActiveLayerObservers()
        endLayerSwitch = time.clock()
        interval = endLayerSwitch - startLayerSwitch
        logger.debug('Switch layer took %s seconds.', interval)

    def _saveAndRestoreCache(self, oldLayer, newLayer):
        # First time through (doIt), no member cache to restore.
        if self.savedLayerCache is not None:
            newLayer.setMemberNodesCache(self.savedLayerCache)
        self.savedLayerCache = oldLayer.getMemberNodesCache()

    def redoIt(self):        
        self._switchToLayer(self.oldLayer, self.newLayer)

    def undoIt(self):
        self._switchToLayer(self.newLayer, self.oldLayer)

class PostApplyCmd(OpenMaya.MPxCommand):
    """Command to apply collection or override when the layer is already visible.
    This should apply the overrides in the right order, i.e. apply override nodes
    must be inserted at the right position in the apply chain.

    This command is a private implementation detail of this module and should
    not be called otherwise.
    """

    kCmdName = 'renderSetupPostApply'

    # Command data.  Must be set before creating an instance of the command
    # and executing it.  Ownership of this data is taken over by the
    # instance of the command.
    
    applicable = None

    def isUndoable(self):
        return True

    def doIt(self, args):
        # Completely ignore the MArgList argument, as it's unnecessary:
        # arguments to the commands are passed in Python object form
        # directly to the command's constructor.
        if self.applicable is None:
            cmds.warning(kCmdPrivate % self.kCmdName)
            return
        self.redoIt()

    @classmethod   
    def execute(cls, applicable):
        """ Applies an applicable (collection/override) after the layer was already set visible. """
        cls.applicable = applicable
        with undo.CtxMgr("Apply %s" % applicable.name()):
            with namespace.RootNamespaceGuard():
                cmds.renderSetupPostApply()
        cls.applicable = None

    @classmethod
    def creator(cls):
        return cls(cls.applicable)

    def __init__(self, applicable):
        super(PostApplyCmd, self).__init__()
        self.applicable = applicable

    @guard.environ('MAYA_RENDER_SETUP_OVERRIDE_CONNECTABLE', '1')
    def redoIt(self):
        self.applicable.postApply()

    @guard.environ('MAYA_RENDER_SETUP_OVERRIDE_CONNECTABLE', '1')
    def undoIt(self):
        self.applicable.unapply()


def moveModel(modelToMove, destinationModel, destinationPosition):
    ''' Helper method to move a model from a location to antoher location '''
    with undo.CtxMgr('Move %s to %s at position %d' % (modelToMove.name(), destinationModel.name(), destinationPosition)):
        sourceModel = modelToMove.parent()
        sourceModel.detachChild(modelToMove)
        destinationModel.attachChild(destinationPosition, modelToMove)
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
