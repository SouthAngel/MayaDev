""" File Loading Monitoring module.

    This module monitors file loads (including imports and reference load) and 
	displays warning messages if it discovers that new loaded files are not 
	compatible with the current renderSetup mode
	
	Implementation details:
	In order to determine if the loaded file is compatible with the current Maya state
	we first determine the type the loaded file based on its content. Then depending 
	on the current Maya RenderSetup mode error messages are displayed if incompatibilities
	are identified
	
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)


import maya.cmds as cmds
import maya.mel as mel
import maya.api.OpenMaya as OpenMaya
import maya.app.renderSetup.model.legacyRenderLayer as legacyRenderLayer
import maya.app.renderSetup.model.renderLayer as renderLayer
import maya.app.renderSetup.model.renderSetup as renderSetup
import maya.app.renderSetup.model.applyOverride as applyOverride
import maya.app.renderSetup.model.renderLayerSwitchInfo as renderLayerSwitchInfo
import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.common.guard as guard

import os

import maya.OpenMaya as OpenMaya1_0


# Module variable
# Handle for callbacks invoked during file load, file import, file reference
callbacks = []

# List all error messages														  
kErrorSwitchToRenderLayer = maya.stringTable['y_fileLoadMonitor.kErrorSwitchToRenderLayer' ]
kErrorSwitchToRenderSetup = maya.stringTable['y_fileLoadMonitor.kErrorSwitchToRenderSetup' ]
kWarningVisibleRenderLayer = maya.stringTable['y_fileLoadMonitor.kWarningVisibleRenderLayer' ]
kErrorCombiningLegacyToNew = maya.stringTable['y_fileLoadMonitor.kErrorCombiningLegacyToNew' ]
kErrorCombiningNewToLegacy = maya.stringTable['y_fileLoadMonitor.kErrorCombiningNewToLegacy' ]


class _FileLoadMonitor(object):
	"""
	Class that counts the types of nodes that are to be watched and/or cleaned
	up as they are added in the scene.
	"""
	
	watchedNodeTypes = ["renderLayer", renderLayer.RenderLayer.kTypeName, applyOverride.ApplyOverride.kTypeName, renderSetup.RenderSetup.kTypeName]

	def reset(self):
		self.renderSetupLayerCount = 0
		self.applyOverrideCount = 0
		self.newRenderLayerNodesSet = set()
		self.newRSNodeSet = set()

	def __init__(self):
		super(_FileLoadMonitor, self).__init__()
		self.reset()
		self.nodeAddedCBIDs = []

	def start(self):
		self.reset()
		for nodeType in _FileLoadMonitor.watchedNodeTypes:
			cbid = OpenMaya.MDGMessage.addNodeAddedCallback(self._countNodes, nodeType)
			if cbid != 0:
				self.nodeAddedCBIDs.append(cbid)

	def _countNodes(self, mayaObj, clientData):
		node = OpenMaya.MFnDependencyNode(mayaObj)
		if node.object().apiType() == OpenMaya.MFn.kPluginDependNode:
			node = node.userNode()
			if node.typeName() == renderLayer.RenderLayer.kTypeName:
				self.renderSetupLayerCount += 1
			elif node.typeName() == applyOverride.ApplyOverride.kTypeName:
				self.applyOverrideCount += 1
			elif node.typeName() == renderSetup.RenderSetup.kTypeName:
				# Caveat: keep track of the nodes, as they may get renamed
				self.newRSNodeSet.add(node)
		elif node.object().apiType() == OpenMaya.MFn.kRenderLayer:
			# Caveat: keep track of the nodes, as they may get renamed
			self.newRenderLayerNodesSet.add(node)
	
	def stop(self):
		for cbid in self.nodeAddedCBIDs:
			OpenMaya.MMessage.removeCallback(cbid)
		self.nodeAddedCBIDs = []



def _getErrorSwitchToRenderLayerIfNeeded():
	# If we have a render layer manager with render layers (not connected to render setup layers)
	# in the scene, then return an error warning the user that the combination of render setup and 
	# legacy render layers is not supported.
	renderLayerManagers = cmds.ls(type="renderLayerManager")
	for renderLayerManager in renderLayerManagers:
		size = cmds.getAttr(renderLayerManager + ".renderLayerId", size=True)
		allRenderLayers = (cmds.listConnections(renderLayerManager + ".renderLayerId[" + str(i) + "]")[0] for i in range(0, size))
		numRenderLayers = len([rsl for rsl in (legacyRenderLayer.renderSetupLayer(rl) for rl in allRenderLayers) if rsl is None])

		# It's ok to import or reference a file that has a render layer manager and one
		# legacy render layer (the default one). If the number of legacy render layers that
		# aren't used for render setup is greater than one, we have an intentional use of
		# legacy render layers and we should flag it.
		if numRenderLayers > 1:
			return kErrorSwitchToRenderLayer
	return None

def initialize():
	# This method must be called when the plugin is loaded
	# It registers listening callback for file load activities

	# Written to global variable
	global callbacks
	global _nodeCounter

	_nodeCounter = _FileLoadMonitor()

	# Register file load callbacks
	callbacks.append(OpenMaya.MSceneMessage.addCallback(OpenMaya.MSceneMessage.kBeforeFileRead, onReadStart))
	callbacks.append(OpenMaya.MSceneMessage.addCallback(OpenMaya.MSceneMessage.kAfterFileRead, onReadEnd))

	# Register file import/reference callbacks
	callbacks.append(OpenMaya.MSceneMessage.addCallback(OpenMaya.MSceneMessage.kAfterImport, onImportOrReferenceEnd, renderLayerSwitchInfo.IMPORT))
	callbacks.append(OpenMaya.MSceneMessage.addCallback(OpenMaya.MSceneMessage.kAfterCreateReference, onImportOrReferenceEnd, renderLayerSwitchInfo.REFERENCE))
	callbacks.append(OpenMaya.MSceneMessage.addCallback(OpenMaya.MSceneMessage.kAfterLoadReference, onImportOrReferenceEnd, renderLayerSwitchInfo.REFERENCE))

def finalize():
	# This method must be called when the plugin is unloaded
	# Unregistering callbacks
	global callbacks
	for callback in callbacks:
		OpenMaya.MSceneMessage.removeCallback(callback)
	callbacks = []

def onReadStart( _ ):
	# File load callback
	# Invoked when a file load is initiated but also on Import and Reference Load
	_nodeCounter.start()


def onReadEnd( _ ):
	# File loaded callback
	# Invoked at the end of a load, import or reference load
	# This callback validates if the content of the  loaded file is compatible with
	# current Maya RenderSetup mode.

	# Determine if the newly loaded file is a renderSetup or Render Layer type file
	# based on the content of the newly loaded file
	
	# The presence of certain types of nodes is determined by making the difference 
	# between the actual count of a specific type of nodes and the count we had at the 
	# beginning of the file load operation
	
	global _nodeCounter
	_nodeCounter.stop()
	
	renderSetupLayerCount = _nodeCounter.renderSetupLayerCount
	renderLayerCount = len(_nodeCounter.newRenderLayerNodesSet)
	applyOverrideCount = _nodeCounter.applyOverrideCount

	isRSfile = False  # true if the loaded file is a renderSetup file
	isRLfile = False  # true if the loaded file is a legacy render layer file
	hasAppliedOverrides = False # true if the loaded file is a renderSetup file with applied overrides.

	if renderSetupLayerCount > 0:
		# If the file contains renderSetupLayers it is a renderSetup file
		isRSfile = True
		hasAppliedOverrides = applyOverrideCount > 0
	elif renderLayerCount > 1: 
		# If the file contains renderLayers but no renderSetupLayers it is a renderLayer file
		# A difference of 1 layer does not qualify a file as being a renderLayerFile. That 
		# difference represent the defaultRenderLayer. There are 2 reasons why the difference count
		# would be 1: 
		#   - on file load the defaultRenderLayer has not been created yet when we did the preLoad inventory
		#	  so initialRenderLayerCount will be 0 but the defaultRenderLayer of the newly loaded file
		#     got loaded and created at the time the final LayerInventory was done
		#	- on file import, the initialRenderLayerCount is 1 but the import involves the load of a 
		#	  second defaultRenderLayer. That last layer gets removed at the end of the load but not 
		#     before the current callback gets invoked
		# This behavior seems subject to change so it should be one of the first thing to check if 
		# the associated regression test starts failing
		isRLfile = True

	# Determine if current operation is a clean file load in an empty scene
	# or an addition to a main scene (import or reference load)
	isNewScene = not OpenMaya1_0.MFileIO.isImportingFile() and not OpenMaya1_0.MFileIO.isReferencingFile()

	# Allows batch rendering of legacy render layer and render setup files 
	# regardless of whether we are in render setup or legacy render layer
	# mode.  Only valid on file open, not on file import or load of 
	# deferred file reference: loading deferred references should not
	# affect the main file mode.  If we were in render setup mode, we
	# should stay in render setup mode, and vice versa for legacy render
	# layer mode. Note: this only applies to being in batch mode when
	# Maya is started by the Render executable.
	if os.getenv("MAYA_STARTED_FROM_RENDER") and cmds.about(batch=True) and isNewScene:
		cmds.mayaHasRenderSetup(edit=True, enableCurrentSession=not isRLfile)

	# Early exit if the new file contains no RenderLayer or RenderSetups
	if not isRSfile and not isRLfile:
		return

	# Identify the message to output, if any
	errorMsg = None
	warningMsg = None

	if mel.eval( "mayaHasRenderSetup()" ) > 0:
		
		# Render Setup Mode
		if isRLfile:
			if renderSetup.hasInstance():
				# Appending to a scene already containing renderSetupLayers, disabling Maya RenderSetup mode is not a solution
				errorMsg = kErrorCombiningLegacyToNew
			else:
				errorMsg = _getErrorSwitchToRenderLayerIfNeeded()
				if errorMsg is not None: 
					from maya.app.renderSetup.model.renderLayer import DefaultRenderLayer
					defaultLayer = DefaultRenderLayer()
					if not defaultLayer.isVisible(): # MAYA-83988
						errorMsg += maya.stringTable['y_fileLoadMonitor.kFileSwitchToDefaultRenderLayer' ]                    
						with guard.EnvironGuardCtx('MAYA_ENABLE_LEGACY_RENDER_LAYERS', '1'): # use legacy way to switch layer to remove adjustments
							cmds.editRenderLayerGlobals(currentRenderLayer=defaultLayer._getLegacyNodeName())

		elif isRSfile and not isNewScene and hasAppliedOverrides:
				# If there are apply overrides during a file import/reference,
				# cleaning up the scene could be significantly slow, so a
				# warning message is printed.
				warningMsg = kWarningVisibleRenderLayer

	else:
		# RenderLayer mode
		if isRSfile:
			# Since each renderSetupLayer has a renderLayer attached to it, 
			# we substract here to get the number of renderLayers in the scene
			# prior to the import/reference
			if (len(cmds.ls(type="renderLayer")) - renderSetupLayerCount ) > 2 :
				# Appending to a scene already containing RenderLayers, enabling Maya RenderSetup mode is not a solution 
				# We allow a count of 2 because of the 2 defaultRenderLayers.
				errorMsg = kErrorCombiningNewToLegacy
			else:			
				errorMsg = kErrorSwitchToRenderSetup


	# Print out identified Error or Warning message
	if errorMsg:
		OpenMaya.MGlobal.displayError( errorMsg )

		# Force the display of the Maya File Load pop-up at the end of the read operation
		OpenMaya1_0.MFileIO.setError()

	elif warningMsg:
		OpenMaya.MGlobal.displayWarning( warningMsg )

def onImportOrReferenceEnd( data ):

	global _nodeCounter

	if not cmds.mayaHasRenderSetup():
		return

	def cleaningUpScene(newRSNodeNamesSet, newLegacyRenderLayerNamesSet):
		for rsName in newRSNodeNamesSet:
			rs = utils.nameToUserNode(rsName)
			for layer in rs.getRenderLayers():
				if layer.hasApplyOverridesRecursive():
					with renderLayerSwitchInfo.UnapplyLayerImportRefContext(layer, data):
						overrides = utils.getOverridesRecursive(layer)
						for ov in overrides:
							ov.unapply()
			renderSetup.delete(rs)

		# Delete the extra legacy render layers as they are not needed in 
		# Render Setup mode if the corresponding Render Setup and Render 
		# Setup Layers have been deleted. We only delete the legacy render 
		# layer nodes, as the corresponding render layer managers are also 
		# deleted as a result.

		# Delete all imported legacy render layer nodes that are not
		# the default one
		for lrl in newLegacyRenderLayerNamesSet:
			if lrl != 'defaultRenderLayer':
				try:
					legacyRenderLayer.delete(lrl)
				except ValueError:
					# renderLayers might already be deleted as part of the 
					# RenderSetup Nodes cleanup
					pass


	# for loops because list comprehensions are very flaky with
	# nodes	
	newLegacyRenderLayerNamesSet = []
	for node in _nodeCounter.newRenderLayerNodesSet:
		newLegacyRenderLayerNamesSet.append(node.name())

	newRSNodeNamesSet = []
	for node in _nodeCounter.newRSNodeSet:
		newRSNodeNamesSet.append(node.name())

	if newLegacyRenderLayerNamesSet or newRSNodeNamesSet:
		cleaningUpScene(newRSNodeNamesSet,newLegacyRenderLayerNamesSet)
	# caveat: reset explicitly here. This is problematic in cases of deferred references
	# where we don't get a File Read Start or End and we don't get a AfterLoadRefence on 
	# cmds.file("somefile.ma", r=True) 
	_nodeCounter.reset()
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
