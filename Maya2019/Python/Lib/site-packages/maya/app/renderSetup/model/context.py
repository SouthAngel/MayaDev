'''
This module centralizes the treatment of applying/unapplying/updating 
layers/collections/overrides.

RenderLayers, Collections and Overrides are DG nodes they should technically be 
well-behaved, i.e. they should depend only on their local input attributes to 
compute consistently the same outputs.

In practice, they don't because some collections are traversing connections to 
populate their content and yet these connections may change because of 
previously applied overrides that will insert nodes in the unique global graph 
and/or edit connections in it. This module is tracking apply/unapply/connection 
override update in a global way (context) to insure that collection's content 
are correctly evaluated when they are applied.

Example: if we have something like this:

renderLayer1
  - collection1 with pSphere1
    - collection1_shaders1 gathering shaders assigned to pSphere1 (lambert1)
      - abs override color to yellow
    - materialOverride1 assigning blinn1 to pSphere1
    - collection1_shaders2 gathering shaders assigned to pSphere1 
      (blinn1 if materialOverrides is enabled, lambert1 otherwise)
      - abs override color to green

On apply, collection1_shaders2 must reevaluate its content depending on whether
or not materialOverride1 is enabled. On the other hand, collection1_shaders1 
remains unchanged because it is evaluated before materialOverride1.

This context module ensures that collection1_shaders1 doesn't listen to 
materialOverride1 (on apply, on enable/disable, on connection change) but 
collection1_shaders2 does. 

On apply: 
 > apply renderLayer1 
   > evaluate collection1 content
   > deactivate collection1's selector
   > apply collection1
     > evaluate collection1_shader1 content
     > deactivate collection1_shaders1's selector
     > apply collection1_shaders1
       > override lambert1's color to yellow
     > assign blinn1 to pSphere1
     > evaluate collection1_shader2 content
     > deactivate collection1_shaders2's selector
     > apply collection1_shaders2
       > override blinn1's color to green
   > reactivate all selectors from the first applied element (i.e. renderLayer1)

Now, if renderLayer1 is visible,
materialOverride1 update (enable/disable/connection changed) should:
 > create a PivotGuard on materialOverride1. This will deactivate all the 
   selectors BEFORE materialOverride1 but let the ones after activated.
 > update materialOverride1
 > look if a collection's selector AFTER that materialOverride1 was dirtied as
   they may need to reevaluate their content due to the connection change). 
   In this case, collection1_shaders2 selector will have been dirtied.
   It will then create a PivotGuard around collection1_shaders2 and reapply 
   the partially reapply the layer with that pivot collection.
   The PivotGuard guarantees that collection1 and collection1_shaders1 selectors
   are deactivated and protect these collections from being unapplied/reapplied, 
   since they would remain unchanged anyway.
 
'''

import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.model.traverse as traverse
import maya.app.renderSetup.model.sceneObservable as sceneObservable
import maya.app.renderSetup.common.guard as guard
import maya.api.OpenMaya as OpenMaya
import maya.app.renderSetup.model.renderLayerSwitchInfo as renderLayerSwitchInfo
import itertools

def _getRoot(element):
    '''
    Returns the last non-None ancestor of the given node or None if the node
    has no parent.
    '''
    from maya.app.renderSetup.model.renderLayer import RenderLayer
    while element:
        parent = element.parent()
        if not parent or isinstance(element, RenderLayer):
            return element
        element = parent

def _getRenderLayer(element):
    '''
    Returns the node if it is already a render layer.
    Returns the render layer of the given node otherwise or None if the node
    doesn't have a render layer.
    '''
    from maya.app.renderSetup.model.renderLayer import RenderLayer
    while element and not isinstance(element,RenderLayer):
        element = element.parent()
    return element

def _getCollectionsBefore(pivot):
    '''
    Returns all the collections before a given node pivot.
    (in application order)
    '''
    from maya.app.renderSetup.model.collection import Collection
    parent = pivot.parent()
    root = _getRoot(parent)
    for child in traverse.depthFirst(root, traverse.nodeListChildren):
        if child == pivot:
            return
        if isinstance(child, Collection):
            yield child

class BlackList(object):
    '''
    Static class to hold black listed collection or override names.
    This is used when layer needs to be partially reapplied to skip over
    blacklisted overrides and overrides in blacklisted collections.
    '''
    _names = set()
    
    @staticmethod
    def add(names):
        BlackList._names.update(names)
    
    @staticmethod
    def remove(names):
        BlackList._names.difference_update(names)
    
    @staticmethod
    def accepts(override):
        if override.name() in BlackList._names:
            return False
        parent = override.parent()
        return parent is None or parent.name() not in BlackList._names
    
    @staticmethod
    def names():
        return BlackList._names
    
class BlackListGuard:
    '''
    Guard context to black list some collection and/or override names
    in a "with" statement.
    '''
    def __init__(self, names):
        self.names = names
        
    def __enter__(self):
        # make sure we keep the names by expanding generators
        self.names = tuple(self.names)
        BlackList.add(self.names)
        
    def __exit__(self, type, value, traceback):
        BlackList.remove(self.names)

def getSelectors(collections):
    '''Returns all the known selector from the collections iterable.'''
    # collection.Collection interface raises if there is no selector, or if 
    # it is of unknown type.
    return (c.getSelector() for c in collections \
            if c.getSelectorType() is not None)

def getCollections(layers):
    '''Returns all the non-blacklisted collections from the layers iterable.'''
    for layer in layers:
        for c in utils.getCollectionsRecursive(layer):
            if c.name() not in BlackList.names():
                yield c

def getRenderLayers():
    '''Returns all the render layers.'''
    # Avoid cyclic dependency between this module and renderSetup.
    import maya.app.renderSetup.model.renderSetup as renderSetup
    return renderSetup.instance().getRenderLayers()

def stateGuards(ignoreReferenceEdit=True, enableSceneObservers=False):
    def decorator(f):
        @guard.state(OpenMaya.MFnReference.ignoreReferenceEdits, OpenMaya.MFnReference.setIgnoreReferenceEdits, ignoreReferenceEdit)
        @guard.state(sceneObservable.sceneObserversEnabled, sceneObservable.enableSceneObservers, enableSceneObservers)
        def stateGuardsWrapper(*args, **kwargs):
            return f(*args, **kwargs)
        return stateGuardsWrapper
    return decorator

class PivotGuard:
    '''
    Protects every override that is before the pivot in application order from
    being unapplied or applied. Also deactivate all the selectors before pivot.
    The pivot can be either a collection or an override.
    This is useful for partially reapplying a layer from a certain point.
    '''
    
    def __init__(self, pivot):
        self.pivot = pivot
        # Silence pylint warning.
        self.collections = None
        
    def enter(self):
        self.collections = [c for c in _getCollectionsBefore(self.pivot) \
                            if c.name() not in BlackList.names()]
        BlackList.add((c.name() for c in self.collections))
        for collection in self.collections:
            collection.getSelector().deactivate()
    
    def exit(self):
        BlackList.remove((c.name() for c in self.collections))
        for collection in self.collections:
            collection.getSelector().activate()
    
    def __enter__(self):
        self.enter()

    def __exit__(self, type, value, traceback):
        self.exit()

class StackContext(object):
    '''
    The stack context keeps track of the application/unapplication/update
    of nodes. The first StackContext calls initiate and conclude. 
    This helps handling complex operations that might need to do some work
    at the very beginning and the very end.
    '''
    stack = []
    
    @staticmethod
    def empty():
        return len(StackContext.stack) == 0
    
    def __init__(self, element):
        self.element = element
        self.custom = None
    
    def __enter__(self):
        StackContext.stack.append(self.element)
        if len(StackContext.stack) == 1:
            self.initiate()

    def __exit__(self, type, value, traceback):
        StackContext.stack.pop()
        if StackContext.empty():
            self.conclude()
    
    def initiate(self): # called only for the first node stacked
        pass
    
    def conclude(self): # called only for the first node stacked
        pass

class PivotContext(StackContext):
    changed = None
    
    def __init__(self,element):
        super(PivotContext,self).__init__(element)
        self.guard = None
        self.layer = None
        self.neededUpdate = None
    
    def initiate(self):
        self.guard = None
        self.layer = _getRenderLayer(self.element)
        if self.element.overridesConnections() and self.layer is not None and \
           self.layer.isVisible():
            PivotContext.changed = set()
            self.neededUpdate = self.layer.needsApplyUpdate
            self.guard = PivotGuard(self.element)
            self.guard.enter()
    
    def conclude(self):
        if self.guard is not None:
            # resolve pivot as the first dirtied collection in the layer
            cols = itertools.ifilter(lambda c: c.getRenderLayer() == self.layer,
                                     (s.owner() for s in PivotContext.changed))
            PivotContext.changed = None
            pivot =  reduce(lambda out,x: x if x < out else out, 
                            cols, next(cols, None))
            self.guard.exit()
            if pivot is not None:
                with PivotGuard(pivot):
                    self.layer.unapply()
                    self.layer.apply()
                self.layer.needsApplyUpdate = self.neededUpdate

def selectionChanged(f):
    '''Decorator for Selectors to allow the context to keep track of dirtied 
    selectors in a PivotContext.'''
    def selectionChangedWrapper(*args,**kwargs):
        if PivotContext.changed is not None:
            PivotContext.changed.add(args[0])
        f(*args,**kwargs)
    return selectionChangedWrapper


##############################################################################
#                              LAYER CONTEXTS
##############################################################################
#
# Layer contexts makes sure that irrelevent collection's selector stop 
# listening to scene changes upon applied/unapplied/updated (for performance)
# Reactivate all selectors on conclude.
#
# IMPORTANT: Unapply/Apply layer always come in pair. I.e. whenever a layer 
# is applied it IMPLIES that another one just got unapplied. 
# That explains why UnapplyLayerContext.conclude doesn't activate selectors
# and ApplyLayerContext.initiate doesn't deactivate them.
# That's because UnapplyLayerContext.initiate and ApplyLayerContext.initiate 
# always come together and will do the deactivation/activation.
#
##############################################################################

########### APPLY LAYER #############

class ApplyLayerContext(StackContext):
    
    def initiate(self):
        # THIS DOESN'T NEED TO DEACTIVATE SELECTORS
        # (see LAYER CONTEXTS comments for details)
        pass
    
    def conclude(self):
        # reactivate all selectors
        for s in getSelectors(getCollections(getRenderLayers())):
            s.activate()
        self.element.needsApplyUpdate = False

def applyLayer(f):
    @stateGuards()
    def applyLayerWrapper(*args, **kwargs):
        with ApplyLayerContext(args[0]):
            f(*args, **kwargs)
    return applyLayerWrapper

########## UNAPPLY LAYER ############

class UnapplyLayerContext(StackContext):
    
    def initiate(self):
        for s in getSelectors(getCollections(getRenderLayers())):
            s.deactivate()
    
    def conclude(self):
        # THIS MUST NOT REACTIVATE SELECTORS
        # (see LAYER CONTEXTS comments for details)
        for s in getSelectors(getCollections(getRenderLayers())):
            if s.isTraversingConnections():
                s.selectionChanged() # dirty caches that could be wrong
        self.element.needsApplyUpdate = False

def unapplyLayer(f):
    @stateGuards()
    def unapplyLayerWrapper(*args, **kwargs):
        with UnapplyLayerContext(args[0]):
            f(*args, **kwargs)
    return unapplyLayerWrapper

########### UPDATE LAYER ############
    
UpdateLayerContext = ApplyLayerContext

class UpdateLayerContext(PivotContext):
    '''This context shall be used to update connection overrides in a layer.
    This is not equivalent to doing a layer switch from a layer to the same
    layer.'''
    def initiate(self):
        super(UpdateLayerContext,self).initiate()
        # deactivate selector in other layers (for performance)
        layers = itertools.ifilter(lambda l: l is not self.element, 
                                   getRenderLayers())
        for s in getSelectors(getCollections(layers)):
            s.deactivate()
    
    def conclude(self):
        # reactivate all selectors
        for s in getSelectors(getCollections(getRenderLayers())):
            s.activate()
        super(UpdateLayerContext,self).conclude()
    
def updateLayer(f):
    @stateGuards()
    def updateLayerWrapper(*args, **kwargs):
        with UpdateLayerContext(args[0]):
            f(*args, **kwargs)
    return updateLayerWrapper


##############################################################################
#                            COLLECTION CONTEXTS
##############################################################################
#
# Collection contexts makes sure that collection's selector stop 
# listening to scene changes upon applied/unapplied/updated (for correctness)
#
##############################################################################

######### APPLY COLLECTION ##########

class ApplyCollectionContext(PivotContext):
    
    def __enter__(self):
        super(ApplyCollectionContext,self).__enter__()
        selector = self.element.getSelector()
        selector.names() # pull names to update cache if needed
        selector.deactivate()
    
    def initiate(self):
        super(ApplyCollectionContext,self).initiate()
    
    def conclude(self):
        self.element.getSelector().activate()
        for c in utils.getCollectionsRecursive(self.element):
            c.getSelector().activate()
        super(ApplyCollectionContext,self).conclude()

def applyCollection(f):
    @stateGuards()
    def applyCollectionWrapper(*args, **kwargs):
        with ApplyCollectionContext(args[0]):
            f(*args, **kwargs)
    return applyCollectionWrapper

######## UNAPPLY COLLECTION #########

class UnapplyCollectionContext(PivotContext):
    
    def initiate(self):
        for s in getSelectors(getCollections(getRenderLayers())):
            s.deactivate()
    
    def conclude(self):
        for s in getSelectors(getCollections(getRenderLayers())):
            s.activate()
            if s.isTraversingConnections():
                s.selectionChanged()

def unapplyCollection(f):
    @stateGuards()
    def unapplyCollectionWrapper(*args, **kwargs):
        with UnapplyCollectionContext(args[0]):
            f(*args, **kwargs)
    return unapplyCollectionWrapper

######### UPDATE COLLECTION #########

UpdateCollectionContext = ApplyCollectionContext

def updateCollection(f):
    @stateGuards()
    def updateCollectionWrapper(*args, **kwargs):
        with UpdateCollectionContext(args[0]):
            f(*args, **kwargs)
    return updateCollectionWrapper


##############################################################################
#                             OVERRIDE CONTEXTS
##############################################################################
#
# Override contexts makes sure that overrides aren't 
# applied/unapplied/updated if they are black listed
#
##############################################################################

########## APPLY OVERRIDE ###########

ApplyOverrideContext = PivotContext

def applyOverride(f):
    @stateGuards()
    def applyOverrideWrapper(*args, **kwargs):
        ovr = args[0]
        with renderLayerSwitchInfo.ApplyOverrideContext(ovr):
            if BlackList.accepts(ovr):
                with ApplyOverrideContext(ovr):
                    f(*args, **kwargs)
    return applyOverrideWrapper

######### UNAPPLY OVERRIDE ##########
    
UnapplyOverrideContext = PivotContext

def unapplyOverride(f):
    # since there are cases where selectors caches can be wrong due to being 
    # evaluated when the scene is not in the "state" it should be when treating 
    # the collection they belong to, enabling scene observation on unapply 
    # override will dirty caches again so they will be correctly recomputed 
    # when reapplied
    @stateGuards()
    def unapplyOverrideWrapper(*args, **kwargs):
        ovr = args[0]
        with renderLayerSwitchInfo.UnapplyOverrideContext(ovr):
            if BlackList.accepts(ovr):
                with UnapplyOverrideContext(ovr):
                    f(*args, **kwargs)
    return unapplyOverrideWrapper

########## UPDATE OVERRIDE ##########

UpdateOverrideContext = PivotContext
    
def updateOverride(f):
    @stateGuards()
    def updateOverrideWrapper(*args, **kwargs):
        if BlackList.accepts(args[0]):
            with UpdateOverrideContext(args[0]):
                f(*args, **kwargs)
    return updateOverrideWrapper


##############################################################################
#                        APPLY OVERRIDE CONTEXTS
##############################################################################
#
# The wrappers on the apply override nodes are mainly there to prevent 
# "renderLayerSwitchInfo" stuff to spread everywhere in the code.
#
##############################################################################

def applyApplyOverride(f):
    def applyApplyOverrideWrapper(*args, **kwargs):
        with renderLayerSwitchInfo.ApplyApplyOverrideContext():
            f(*args, **kwargs)
    return applyApplyOverrideWrapper

def unapplyApplyOverride(f):
    def unapplyApplyOverrideWrapper(*args, **kwargs):
        with renderLayerSwitchInfo.UnapplyApplyOverrideContext():
            f(*args, **kwargs)
    return unapplyApplyOverrideWrapper

def updateApplyOverride(f):
    @guard.state(sceneObservable.sceneObserversEnabled, sceneObservable.enableSceneObservers, True)
    def updateApplyOverrideWrapper(*args, **kwargs):
        f(*args, **kwargs)
    return updateApplyOverrideWrapper

##############################################################################
#                          CHANGE ENABLED HANDLER
##############################################################################
#
# The logic for enabled change on a root node is this:
#
# All the connection overrides descendant of the root node that change their 
# enabled state on the enabled change should update. The others should be black 
# listed.
#
# The root node is then updated with the blacklisted connection overrides.
# UpdateCollectionContext uses a PivotGuard. Thus, any collection selector's 
# reporting a selection change in the PivotContext will make the layer 
# partially reapply with a pivot on the first collection that changed.
#
##############################################################################

def beforeEnabled(node):
    @staticmethod
    def beforeEnabledWrapper(state):
        ovs = [(o, o.isEnabled()) for o in utils.getOverridesRecursive(node) \
               if o.overridesConnections()]
        state.set((node.isEnabled(), ovs))
    return beforeEnabledWrapper

def afterEnabled(node):
    @staticmethod
    def afterEnabledWrapper(state):
        prevEnabled, ovs = state.release()
        if prevEnabled is not node.isEnabled():
            sameEnabled = (o[0].name() for o in ovs if o[0].isEnabled() == o[1])
            with BlackListGuard(sameEnabled):
                node.update()
    return afterEnabledWrapper


##############################################################################
#                          CHANGE ISOLATED HANDLER
##############################################################################
#
# The logic for isolate selected change is this:
#
# All the connection overrides that change their enabled state on the 
# isolate selected change should update. The others should be black listed.
#
# The layer is then updated with the blacklisted connection overrides.
# UpdateLayerContext uses a PivotGuard. Thus, any collection selector's 
# reporting a selection change in the PivotContext will make the layer 
# partially reapply with a pivot on the first collection that changed.
#
##############################################################################

def beforeIsolated(node):
    layer = node.getRenderLayer()
    if layer is None or not layer.isVisible():
        return None
    @staticmethod
    def beforeIsolatedWrapper(state):
        ovs = [(o, o.isEnabled()) for o in utils.getOverridesRecursive(layer) \
               if o.overridesConnections()]
        state.set(ovs)
    return beforeIsolatedWrapper

def afterIsolated(node):
    layer = node.getRenderLayer()
    if layer is None or not layer.isVisible():
        return None
    @staticmethod
    def afterIsolatedWrapper(state):
        ovs = state.release()
        sameEnabled = (o[0].name() for o in ovs if o[0].isEnabled() == o[1])
        with BlackListGuard(sameEnabled):
            layer.update()
    return afterIsolatedWrapper
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
