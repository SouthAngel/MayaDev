"""
    The file must contain all user preferences related to the Render Setup
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)


import maya.cmds as cmds
import os
from distutils.dir_util import copy_tree

import maya.app.renderSetup.model.observable as observable
import maya.app.renderSetup.common.errorAndWarningDeferrer as errorAndWarningDeferrer

# When true puts the UI in edit mode after a render setup object creation 
kOptionVarEditMode = 'renderSetup_editMode'

# The default path to find the user render setup template files 
kOptionVarUserTemplateDirectory = 'renderSetup_userTemplateDirectory'

# The default path to find the global render setup template files 
kOptionVarGlobalTemplateDirectory = 'renderSetup_globalTemplateDirectory'

# The default path to find the user render setup presets files 
kOptionVarUserPresetsDirectory = 'renderSetup_userPresetsDirectory'

# The default path to find the global render setup presets files 
kOptionVarGlobalPresetsDirectory = 'renderSetup_globalPresetsDirectory'

# Error message to display when the global template path does not exist
kGlobalTemplatePathInvalid = maya.stringTable['y_renderSetupPreferences.kGlobalTemplatePathInvalid' ]

# Error message to display when the global presets path does not exist
kGlobalPresetsPathInvalid = maya.stringTable['y_renderSetupPreferences.kGlobalPresetsPathInvalid' ]


def getEditMode():
    if not cmds.optionVar(exists=kOptionVarEditMode):
        cmds.optionVar(intValue=(kOptionVarEditMode, 1))

    return cmds.optionVar(query=kOptionVarEditMode)==1


def setEditMode(value):
    return cmds.optionVar(intValue=(kOptionVarEditMode, 1 if value else 0))


def _getUserDirectory(userDirectoryOptionVar, defaultUserDirectoryName):
    if not cmds.optionVar(exists=userDirectoryOptionVar):
        dstPath = os.path.join(os.getenv('MAYA_APP_DIR'), defaultUserDirectoryName)
        if not os.path.exists(dstPath):
            os.mkdir(dstPath)
        cmds.optionVar(stringValue=(userDirectoryOptionVar, dstPath))
    userDir = cmds.optionVar(query=userDirectoryOptionVar)
    
    # copy all the predefined templates or presets to the user directory 
    if not cmds.optionVar(exists=userDirectoryOptionVar+'_contents'):
        fromDirectory = os.path.join(os.path.join(os.getenv('MAYA_LOCATION'), 'presets'), defaultUserDirectoryName)
        if os.path.exists(fromDirectory):
            copy_tree(fromDirectory, userDir)
        cmds.optionVar(stringValue=(userDirectoryOptionVar+'_contents', fromDirectory))

    userDir = userDir.replace('\\', '/')
    return userDir


def _getGlobalDirectory(globalDirectoryOptionVar):
    if cmds.optionVar(exists=globalDirectoryOptionVar):
        path = cmds.optionVar(query=globalDirectoryOptionVar)
        path = path.replace('\\', '/')
        if os.path.exists(path):
            return path
    return None
    

def getUserTemplateDirectory():
    return _getUserDirectory(kOptionVarUserTemplateDirectory, 'RSTemplates')


def getGlobalTemplateDirectory():
    return _getGlobalDirectory(kOptionVarGlobalTemplateDirectory)


def getGlobalTemplateDirectoryWithoutCheck():
    """ For asynchronous purpose, we want to check if the path
    really exists AFTER getting the path string """
    if cmds.optionVar(exists=kOptionVarGlobalTemplateDirectory):
        return cmds.optionVar(query=kOptionVarGlobalTemplateDirectory)
    return None


def getUserPresetsDirectory():
    return _getUserDirectory(kOptionVarUserPresetsDirectory, 'Presets')


def getGlobalPresetsDirectory():
    return _getGlobalDirectory(kOptionVarGlobalPresetsDirectory)
    

def getFileExtension():
    return 'json'


class BaseSetting(object):
    """ Accessor and mutator class methods to be used by derived classes
    for various Render Setup Options/Settings.
    All of those Render Setup Options have to implement their own boolean
    variables kEnvVar, kOptionVar and kDefault to be derived properly from this
    base class.
    Manipulate the environment and option variables that toggle
    the setting on or off. If an environment variable is set, we
    ignore the option variable.
    Else, take care of toggling the setting on or off when asked.
    This class should be considered abstract and should not be used as is
    (only the derived classes are usable), hence why its variables are None."""

    # Those three variables have to be set in the derived classes.
    # NOTE: we assume they are all boolean variables.
    kEnvVar = None
    kOptionVar = None
    kDefault = None

    # No need for an instance of this class, it is only encapsulating methods to
    # access and set various settings. (this is to make pylint happy)
    def __init__(self):
        pass

    @classmethod
    def hasEnvVar(cls):
        return os.getenv(cls.kEnvVar) != None

    @classmethod
    def getEnvVar(cls):
        """" Return the value of the environment variable
        or None if it is unset. The user can use an environment variable
        to override user preferences and enable/disable the setting."""
        if not cls.hasEnvVar():
            return None
        return int(os.getenv(cls.kEnvVar)) == 1

    @classmethod
    def setEnvVar(cls, val):
        if val is None:
            cls.unsetEnvVar()
        else:
            os.environ[cls.kEnvVar] = "1" if val else "0"

    @classmethod
    def unsetEnvVar(cls):
        if cls.hasEnvVar():
            del os.environ[cls.kEnvVar]

    @classmethod
    def hasOptionVar(cls):
        return cmds.optionVar(exists=cls.kOptionVar)

    @classmethod
    def getOptionVar(cls):
        if not cls.hasOptionVar():
            return None
        return cmds.optionVar(query=cls.kOptionVar) == 1

    @classmethod
    def setOptionVar(cls, val):
        if val is None:
            cls.unsetOptionVar()
        else:
            cmds.optionVar(intValue=(cls.kOptionVar, 1 if val else 0))

    @classmethod
    def unsetOptionVar(cls):
        if cls.hasOptionVar():
            cmds.optionVar(remove=cls.kOptionVar)

    @classmethod
    def isEnabled(cls):
        """ Return whether or not the setting is enabled according
        to the corresponding environment variable or user preference """
        if cls.hasEnvVar():
            return cls.getEnvVar()
        if cls.hasOptionVar():
            return cls.getOptionVar()
        # There is a default value for each setting when both the envVar and
        # the optionVar are unset.
        return cls.kDefault

    @classmethod
    def toggleOptionVar(cls):
        #This class method is called when the user toggles the setting on/off.
        cls.setOptionVar(not cls.getOptionVar() if cls.hasOptionVar() else not cls.kDefault)

class UntitledCollectionsSetting(BaseSetting):
    """ Accessor and mutator static/class methods for
    Untitled Collections setting.
    """
    kEnvVar = "MAYA_RENDER_SETUP_USE_UNTITLED_COLLECTIONS"
    kOptionVar = 'renderSetup_useUntitledCollections'
    kDefault = True

class IncludeAllLightsSettingContextManager:
    """ Make sure to update visible layer membership when the value of
        the setting include all lights changes during a set/unset of the
        optionVar or the envVar.
    """
    def __init__(self):
        self.beforeSetIsEnabled = None

    @staticmethod
    def updateVisibleLayerMembership():
        # We have to update the visible layer membership right away so that the
        # user sees the changes made by toggling the checkbox.
        import maya.app.renderSetup.model.renderSetup as renderSetup
        rs = renderSetup.instance()
        if not rs.getDefaultRenderLayer().isVisible():
            rs.getVisibleRenderLayer()._startMembershipUpdate()

    def __enter__(self):
        self.beforeSetIsEnabled = IncludeAllLightsSetting.isEnabled()

    def __exit__(self, exc_type, exc_val, exc_tb):
        #If the value of the setting changed, we have to update membership.
        if(IncludeAllLightsSetting.isEnabled() != self.beforeSetIsEnabled):
            IncludeAllLightsSettingContextManager.updateVisibleLayerMembership()

def includeAllLightsSettingDecorator(f):
    """ Use the IncludeAllLightsSetting's context manager. """
    def wrapper(*args, **kwargs):
        with IncludeAllLightsSettingContextManager():
            return f(*args, **kwargs)
    return wrapper

class IncludeAllLightsSetting(BaseSetting):
    """ Accessor and mutator static/class methods for
        Include All Lights setting.
    """
    kEnvVar = "MAYA_RENDER_SETUP_INCLUDE_ALL_LIGHTS"
    kOptionVar = 'renderSetup_includeAllLights'
    kDefault = True

    @classmethod
    @includeAllLightsSettingDecorator
    def setEnvVar(cls, val):
        super(IncludeAllLightsSetting, cls).setEnvVar(val)

    @classmethod
    @includeAllLightsSettingDecorator
    def unsetEnvVar(cls):
        super(IncludeAllLightsSetting, cls).unsetEnvVar()

    @classmethod
    @includeAllLightsSettingDecorator
    def setOptionVar(cls, val):
        super(IncludeAllLightsSetting, cls).setOptionVar(val)

    @classmethod
    @includeAllLightsSettingDecorator
    def unsetOptionVar(cls):
        super(IncludeAllLightsSetting, cls).unsetOptionVar()

class DisplayRSNodesSettingContextManager:
    """ Make sure to change the visibility of render setup nodes in editors
        if needed during a set/unset of the corresponding optionVar or envVar.
    """
    def __init__(self):
        self.beforeSetIsEnabled = None

    def __enter__(self):
        self.beforeSetIsEnabled = DisplayRSNodesSetting.isEnabled()

    def __exit__(self, exc_type, exc_val, exc_tb):
        # If the value of the setting changed, we have to set the visibility
        # of the render setup nodes to the new value.
        if(DisplayRSNodesSetting.isEnabled() != self.beforeSetIsEnabled):
            import maya.app.renderSetup.model.initialize as init
            init.setVisibilityNodes(DisplayRSNodesSetting.isEnabled(), init.renderSetupNodeNamesToShowInOutliner)

def displayRSNodesSettingDecorator(f):
    """ Use the DisplayRSNodesSetting's context manager. """
    def wrapper(*args, **kwargs):
        with DisplayRSNodesSettingContextManager():
            return f(*args, **kwargs)
    return wrapper

class DisplayRSNodesSetting(BaseSetting):
    """ Accessor and mutator static/class methods for
        Display Render Setup Nodes setting.
        By default, we hide render setup nodes from the editors.
    """
    kEnvVar = "MAYA_RENDER_SETUP_DISPLAY_RS_NODES"
    kOptionVar = 'renderSetup_displayRSNodes'
    kDefault = False

    @classmethod
    @displayRSNodesSettingDecorator
    def setEnvVar(cls, val):
        super(DisplayRSNodesSetting, cls).setEnvVar(val)

    @classmethod
    @displayRSNodesSettingDecorator
    def unsetEnvVar(cls):
        super(DisplayRSNodesSetting, cls).unsetEnvVar()

    @classmethod
    @displayRSNodesSettingDecorator
    def setOptionVar(cls, val):
        super(DisplayRSNodesSetting, cls).setOptionVar(val)

    @classmethod
    @displayRSNodesSettingDecorator
    def unsetOptionVar(cls):
        super(DisplayRSNodesSetting, cls).unsetOptionVar()

class AlwaysListVisibleLayerSetting(BaseSetting):
    """ Accessor and mutator static/class methods for
    Always list visible layer setting.
    """
    kOptionVar = 'renderSetup_alwaysListVisibleLayer'
    kDefault = True

    optionChangeObservable = observable.Observable()

    @classmethod
    def addOptionChangeObserver(cls, obsMethod):
        cls.optionChangeObservable.addItemObserver(obsMethod)

    @classmethod
    def removeOptionChangeObserver(cls, obsMethod):
        cls.optionChangeObservable.removeItemObserver(obsMethod)

    @classmethod
    def hasOptionChangeObserver(cls, obsMethod):
        return cls.optionChangeObservable.hasItemObserver(obsMethod)

    @classmethod
    def _notifyOptionChangeObserver(cls):
        cls.optionChangeObservable.itemChanged()

    @classmethod
    def hasEnvVar(cls):
        return False

    @classmethod
    def getEnvVar(cls):
        return None

    @classmethod
    def setEnvVar(cls, val):
        return

    @classmethod
    def setOptionVar(cls, val):
        super(AlwaysListVisibleLayerSetting, cls).setOptionVar(val)
        cls._notifyOptionChangeObserver()


class ExportRenderSettingsAOVs(BaseSetting):
    """ Accessor and mutator static/class methods for
    Export Render Settings AOVs.
    """
    kEnvVar = "MAYA_RENDER_SETUP_DISABLE_RENDER_SETTINGS_AOVS_EXPORT"
    kOptionVar = 'renderSetup_exportRenderSettingsAOVs'
    kDefault = True
    kToggled = False

    @classmethod 
    def setToggled(cls, value):
        """ When the user checks/unchecks the box this value will update.
        This value will override environment variables temporarily. """
        cls.kToggled = value

    @classmethod
    def isEnabled(cls):
        """ Return whether or not the setting is enabled according
        to the corresponding environment variable or user preference """
        if not cls.kToggled and cls.hasEnvVar():
            return not cls.getEnvVar()
        if cls.hasOptionVar():
            return cls.getOptionVar()
        # There is a default value for each setting when both the envVar and
        # the optionVar are unset.
        return cls.kDefault

def initialize():
    # If the env. variable exists, override the optionVar value containing the global template path
    #
    defaultGlobalTemplatePath = os.getenv('MAYA_RENDER_SETUP_GLOBAL_TEMPLATE_PATH')
    if defaultGlobalTemplatePath is not None:
        if os.path.exists(defaultGlobalTemplatePath):
            cmds.optionVar(stringValue=(kOptionVarGlobalTemplateDirectory, defaultGlobalTemplatePath))
        else:
            errorAndWarningDeferrer.instance().registerWarning(kGlobalTemplatePathInvalid % defaultGlobalTemplatePath)
    
    # If the env. variable exists, override the optionVar value containing the global preset path
    #
    defaultGlobalPresetsPath = os.getenv('MAYA_RENDER_SETUP_GLOBAL_PRESETS_PATH')
    if defaultGlobalPresetsPath is not None:
        if os.path.exists(defaultGlobalPresetsPath):
            cmds.optionVar(stringValue=(kOptionVarGlobalPresetsDirectory, defaultGlobalPresetsPath))
        else:
            errorAndWarningDeferrer.instance().registerWarning(kGlobalPresetsPathInvalid % defaultGlobalPresetsPath)
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
