"""Render setup model undo support.

   This module provides a context manager that provides for convenient undo
   macro commands (called "chunks" in Maya terminology).  It ensures that
   only the top-level call to the undo context manager will open and close
   a chunk, thus providing a single, named entry on the undo stack."""

import maya.api.OpenMaya as OpenMaya

from maya import cmds

class CtxMgr:
    """Safe way to manage group undo chunks using the 'with' command.
    It will close the chunk automatically on exit from the block
    
    Example:
        with CtxMgr('Create Poly Cubes'):
            cmds.polyCube()
            cmds.polyCube()
        cmds.undo() # Will undo both polyCube() creation calls."""

    # Shamelessly adapted from apiMPxComponentShapeTest.py.

    openChunk = True
    
    def __init__(self, name='unnamedOperation'):
        self.name = name
        self.closeChunk = False

    def __enter__(self):
        if CtxMgr.openChunk:
            self.closeChunk = True
            CtxMgr.openChunk = False
            cmds.undoInfo(openChunk=True, chunkName=self.name)
        return None

    def __exit__(self, type, value, traceback):
        if self.closeChunk:
            cmds.undoInfo(closeChunk=True)
            CtxMgr.openChunk = True

def chunk(chunkName):
    """Undo decorator to name and group in a single chunk all commands
    inside the decorated callable."""

    # Decorator functions always take a single argument (usually the
    # decorated function), so we need to use a layered approach so we can
    # also pass in the undo chunk name.
    #
    # The top-level decorator function ("chunk") is only there to pass in
    # the undo chunk name as its single argument.  It returns the actual
    # decorator function ("decorator").  decorator is the function doing
    # the decorating: its single argument is the decorated function, and it
    # returns the wrapper ("wrapper") function, which is used instead of
    # the decorated function.  Where the decorated function would have been
    # called, wrapper is now called instead, and it uses the CtxMgr context
    # to group all undoable commands into a single, named undo chunk.

    def decorator(f):
        def wrapper(*args, **kwargs):
            with CtxMgr(chunkName):
                return f(*args, **kwargs)
        return wrapper
    return decorator

class SuspendUndo:
    """Safe way to suspend and resume undo logging using the 'with' command.
    It will automatically resume undo on exit from the block
    
    Example:
        with SuspendUndo():
            cmds.polyCube()
            cmds.polyCube()
        cmds.undo() # Will not undo the creation calls."""

    # Shamelessly adapted from above.
    
    def __init__(self):
        self.previouslySuspended = False

    def __enter__(self):
        self.previouslySuspended = not cmds.undoInfo(query=True, state=True)
        if not self.previouslySuspended:
            cmds.undoInfo(stateWithoutFlush=False)
        return None

    def __exit__(self, type, value, traceback):
        if not self.previouslySuspended:
            cmds.undoInfo(stateWithoutFlush=True)

def suspend():
    """Undo decorator to suspend and resume undo for all commands
    inside the decorated callable."""

    def decorator(f):
        def wrapper(*args, **kwargs):
            with SuspendUndo():
                return f(*args, **kwargs)
        return wrapper
    return decorator

#==============================================================================
# CLASS NotifyPostRedoCmd
#==============================================================================

class NotifyPostRedoCmd(OpenMaya.MPxCommand):
    """Helper command notify after redo.

    This command is a private implementation detail of this module and should
    not be called otherwise."""

    kCmdName = 'notifyPostRedo'

    # Command data.  Must be set before creating an instance of the command
    # and executing it.
    callable = None

    def isUndoable(self):
        return True

    def doIt(self, args):
        # Completely ignore the MArgList argument, as it's unnecessary:
        # arguments to the commands are passed in Python object form
        # directly to the command's constructor.

        if self.callable is None:
            cmds.warning(kCmdPrivate % self.kCmdName)
        else:
            self.redoIt()

    @staticmethod
    def execute(callable):
        NotifyPostRedoCmd.callable = callable
        cmds.notifyPostRedo()
        NotifyPostRedoCmd.callable = None

    @staticmethod
    def creator():
        return NotifyPostRedoCmd(NotifyPostRedoCmd.callable)

    def __init__(self, callable):
        super(NotifyPostRedoCmd, self).__init__()
        self.callable = callable

    def redoIt(self):
        self.callable()

    def undoIt(self):
        pass

#==============================================================================
# CLASS NotifyPostUndoCmd
#==============================================================================

class NotifyPostUndoCmd(OpenMaya.MPxCommand):
    """Helper command notify after undo.

    This command is a private implementation detail of this module and should
    not be called otherwise."""

    kCmdName = 'notifyPostUndo'

    # Command data.  Must be set before creating an instance of the command
    # and executing it.
    callable = None

    def isUndoable(self):
        return True

    def doIt(self, args):
        # Completely ignore the MArgList argument, as it's unnecessary:
        # arguments to the commands are passed in Python object form
        # directly to the command's constructor.

        if self.callable is None:
            cmds.warning(kCmdPrivate % self.kCmdName)
        else:
            self.redoIt()

    @staticmethod
    def execute(callable):
        NotifyPostUndoCmd.callable = callable
        cmds.notifyPostUndo()
        NotifyPostUndoCmd.callable = None

    @staticmethod
    def creator():
        return NotifyPostUndoCmd(NotifyPostUndoCmd.callable)

    def __init__(self, callable):
        super(NotifyPostUndoCmd, self).__init__()
        self.callable = callable

    def redoIt(self):
        pass

    def undoIt(self):
        self.callable()

#==============================================================================
# CLASS NotifyDecoratorCmd
#==============================================================================

class Pointer(object):
    def __init__(self):
        self.pointee = None
    def release(self):
        out = self.pointee
        self.pointee = None
        return out
    def set(self,v):
        self.pointee = v

class NotifyDecoratorCmd(OpenMaya.MPxCommand):
    '''See NotifyDecorateMgr for meaningful usage of this command example.'''
    
    kCmdName = 'notifyDecorator'

    # Command data.  Must be set before creating an instance of the command
    # and executing it.
    onRedo = None
    onUndo = None
    state = None

    def isUndoable(self):
        return True

    def doIt(self, args):
        # Completely ignore the MArgList argument, as it's unnecessary:
        # arguments to the commands are passed in Python object form
        # directly to the command's constructor.
        if self.state is None:
            cmds.warning(kCmdPrivate % self.kCmdName)
        else:
            self.redoIt()

    @staticmethod
    def execute(onRedo, onUndo, state):
        NotifyDecoratorCmd.onRedo = onRedo
        NotifyDecoratorCmd.onUndo = onUndo
        NotifyDecoratorCmd.state = state
        cmds.notifyDecorator()
        NotifyDecoratorCmd.onRedo = None
        NotifyDecoratorCmd.onUndo = None
        NotifyDecoratorCmd.state = None

    @staticmethod
    def creator():
        return NotifyDecoratorCmd(NotifyDecoratorCmd.onRedo, NotifyDecoratorCmd.onUndo, NotifyDecoratorCmd.state)

    def __init__(self, onRedo, onUndo, state):
        super(NotifyDecoratorCmd, self).__init__()
        self.onRedo = onRedo
        self.onUndo = onUndo
        self.state = state

    def redoIt(self):
        if self.onRedo is not None:
            self.onRedo(self.state)

    def undoIt(self):
        if self.onUndo is not None:
            self.onUndo(self.state)

class NotifyCtxMgr:
    """Safe way to manage group undo chunks using the 'with' command.

    It will close the chunk automatically on exit from the block.
    Supports post undo and post redo notification callables.
    
    Example:
        with NotifyCtxMgr('Create Poly Cubes', postRedo, postUndo):
            cmds.polyCube()
            cmds.polyCube()
        # Will undo both polyCube() creation calls, and call postUndo.
        cmds.undo()

    If a single callable is given, it will be called post undo and post redo."""
    
    def __init__(self, name, postRedo, postUndo=None):
        self.name = name
        self.openChunk = True
        self.closeChunk = False
        self.postRedo = postRedo
        self.postUndo = postUndo if postUndo else postRedo

    def __enter__(self):
        if self.openChunk:
            self.closeChunk = True
            self.openChunk = False
            cmds.undoInfo(openChunk=True, chunkName=self.name)
            # On undo, this is run last.
            NotifyPostUndoCmd.execute(self.postUndo)
        return None

    def __exit__(self, type, value, traceback):
        if self.closeChunk:
            # On redo, this is run last.
            NotifyPostRedoCmd.execute(self.postRedo)
            cmds.undoInfo(closeChunk=True)
            NotifyCtxMgr.openChunk = True

class NotifyDecorateMgr:
    '''
    Safe way to manage group pre/post calls operations around a command 
    using the 'with' statement.
    The NotifyDecorateMgr takes three arguments:
        - name: name of the undo chunk.
        - pre : a callable will always be executed before the command. 
        - post: a callable will always be executed after the command. 
        
    # IMPORTANT: 'pre' is always called first and 'post' is always called last,
    # no matter if the wrapped command is being done, undone or redone.

    The 'pre' and 'post' callables take one argument: a state pointer.
    The state has only two functions:
     - set(value) : store 'value' in the state object.
     - release() : clears the state object and return the stored value.
    
    This allows one to perform some checks before a command is performed, 
    store it temporarily and get it back after the command was performed.
    
    Example:
        def before(state):
            state.set(getMyState())
        
        def after(state):
            previous = state.release()
            doSomeAppropriateUpdateGivenPreviousState(previous)
        
        # Following block will call 'before' callable, create both poly cubes,
        # and call 'after' callable in that order.
        
        with NotifyDecorateMgr('a name', before, after):
            cmds.polyCube()
            cmds.polyCube()
        
        # Undo will call 'before' callable, undo both the poly cube creations
        # and call 'after' callable in that order.
        
        cmds.undo()
        
        # Redo will call 'before' callable, redo both the poly cube creations
        # and call 'after' callable in that order.
        
        cmds.undo()
    '''
    
    def __init__(self, name, pre, post):
        self.name = name
        self.openChunk = True
        self.closeChunk = False
        self.pre = pre
        self.post = post
        self.state = Pointer()

    def __enter__(self):
        if self.openChunk:
            self.closeChunk = True
            self.openChunk = False
            cmds.undoInfo(openChunk=True, chunkName=self.name)
            NotifyDecoratorCmd.execute(self.pre, self.post, self.state)
        return None

    def __exit__(self, type, value, traceback):
        if self.closeChunk:
            NotifyDecoratorCmd.execute(self.post, self.pre, self.state)
            cmds.undoInfo(closeChunk=True)
            NotifyDecorateMgr.openChunk = True

def notify(chunkName, postRedo, postUndo=None):
    """Undo decorator to name and group in a single chunk all commands
    inside the decorated callable.

    The postRedo and postUndo callables are called at end of redo (and do),
    and at end of undo, respectively.  If a single callable is given, it
    will be called both at end of redo and at end of undo."""

    # See chunk() comments.
    def decorator(f):
        def wrapper(*args, **kwargs):
            with NotifyCtxMgr(chunkName, postRedo, postUndo):
                return f(*args, **kwargs)
        return wrapper
    return decorator
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
