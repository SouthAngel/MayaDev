'''
    This module handles scene observation.

    It listens to Maya scene change events and it forwards them to the
    registered callbacks when global observation is enabled (sceneObserversEnabled).
'''

from maya.app.renderSetup.model.observableProxy import ObservableProxy, ObservableDGProxy, ObservableDagProxy
import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.common.guard as guard

import maya.api.OpenMaya as OpenMaya
import maya.OpenMaya as OpenMaya1_0

import time
import logging

logger = logging.getLogger(__name__)

_renderSetup_sceneObserversEnabled = True

def enableSceneObservers(value):
    global _renderSetup_sceneObserversEnabled
    _renderSetup_sceneObserversEnabled = value

def sceneObserversEnabled():
    global _renderSetup_sceneObserversEnabled
    return _renderSetup_sceneObserversEnabled

def isInSceneChangeCallback():
    return instance().isInSceneChangeCallback()

class SceneObservable(object):

    # Callbacks forward the arguments received from the Maya callback.  In the
    # case of file referencing callbacks, the arguments are forwarded in string
    # form.  clientData is not forwarded, since it's always None.
    NODE_ADDED         = 'NodeAdded'          # args = obj
    NODE_REMOVED       = 'NodeRemoved'        # args = obj
    NODE_RENAMED       = 'NodeRenamed'        # args = obj, oldName
    NODE_REPARENTED    = 'NodeReparented'     # args = msgType, child, parent
    CONNECTION_CHANGED = 'ConnectionChanged'  # args = srcPlug, dstPlug, made
    REFERENCE_LOADED   = 'ReferenceLoaded'    # args = reference node name, resolvedRefPath string
    REFERENCE_UNLOADED = 'ReferenceUnloaded'  # args = reference node name, resolvedRefPath string
    REFERENCE_REMOVED  = 'ReferenceRemoved'   # No args.
    REFERENCE_CREATED  = 'ReferenceCreated'   # args = reference node name, resolvedRefPath string.
    BEFORE_REFERENCE_LOAD   = 'BeforeReferenceLoad'   # args = reference node name, resolvedRefPath string
    BEFORE_REFERENCE_UNLOAD = 'BeforeReferenceUnload' # args = reference node name, resolvedRefPath string
    BEFORE_REFERENCE_REMOVE = 'BeforeReferenceRemove' # args = reference node name, resolvedRefPath string
    BEFORE_REFERENCE_CREATE = 'BeforeReferenceCreate' # No args.
    FILE_IMPORTED      = 'FileImported'               # No args.
    BEFORE_FILE_IMPORT = 'BeforeFileImport'           # No args.
    FILE_OPENED        = 'FileOpened'                 # No args.
    BEFORE_FILE_OPEN   = 'BeforeFileOpen'             # No args.
    FILE_EXPORTED      = 'FileExported'               # No args.
    BEFORE_FILE_EXPORT = 'BeforeFileExport'           # No args.

    def __init__(self):
        self._observables = None
        self._isInSceneChangeCallback = False
        self._cbIds = []
        # workaround to avoid unwanted notifications on nodes that are not yet done being created
        self._aboutToCreate = None
        # Maya does not send load / unload notifications on reference add /
        # remove.  Do so ourselves, and keep track of the reference information.
        self._refInfo = None
        # Only file new observation testing code should change this value.
        self._deactivateOnFileNew = True
        # we use this to avoid unwanted events during duplication
        # duplication 1) creates all nodes 2) rename all nodes
        # we use _duplicating to send ADDED messages when nodes are renamed to avoid more expensive rename message handling
        self._duplicating = False
        self._duringDuplicateRenamedObserver = False

        # Avoid Pylint attribute-defined-outside-init.
        self.startReferenceLoad   = None
        self.startReferenceUnload = None

        self.activate()
    
    def _enabled(f):
        '''Decorator that calls the decorated function only if scene observation is enabled.'''
        def wrapper(*args, **kwargs):
            if sceneObserversEnabled():
                return f(*args, **kwargs)
        return wrapper

    def isInSceneChangeCallback(self):
        return self._isInSceneChangeCallback
    
    def __del__(self):
        self.deactivate()

    def activated(self):
        return self._observables is not None

    def activate(self):
        '''Create callbacks to listen to scene changes.'''
        if self.activated():
            return
        self._aboutToCreate = set()
        
        self._observables = {
            SceneObservable.NODE_ADDED: ObservableDGProxy(
                SceneObservable.NODE_ADDED,
                OpenMaya.MDGMessage.addNodeAddedCallback,
                (self._nodeAddedCB, "dependNode")),
            SceneObservable.NODE_REMOVED: ObservableDGProxy(
                SceneObservable.NODE_REMOVED,
                OpenMaya.MDGMessage.addNodeRemovedCallback,
                (self._nodeRemovedCB, "dependNode")),
            SceneObservable.NODE_RENAMED: ObservableDGProxy(
                SceneObservable.NODE_RENAMED,
                OpenMaya.MNodeMessage.addNameChangedCallback,
                (OpenMaya.MObject.kNullObj, self._nodeRenamedCB)),
            SceneObservable.CONNECTION_CHANGED: ObservableDGProxy(
                SceneObservable.CONNECTION_CHANGED,
                OpenMaya.MDGMessage.addConnectionCallback,
                (self._connectionChangedCB,)),
            SceneObservable.NODE_REPARENTED: ObservableDagProxy(
                SceneObservable.NODE_REPARENTED,
                [OpenMaya.MDagMessage.kChildAdded, 
                 OpenMaya.MDagMessage.kChildRemoved, 
                 OpenMaya.MDagMessage.kInstanceAdded, 
                 OpenMaya.MDagMessage.kInstanceRemoved], self._nodeReparentedCB)
        }

        # Not worth using ref-counting proxy observables for infrequent events
        # like referencing events, so use plain base class ObservableProxy.
        self._observables.update({ key: ObservableProxy() for key in 
                                   [SceneObservable.BEFORE_REFERENCE_LOAD,
                                    SceneObservable.REFERENCE_LOADED,
                                    SceneObservable.BEFORE_REFERENCE_UNLOAD,
                                    SceneObservable.REFERENCE_UNLOADED,
                                    SceneObservable.BEFORE_REFERENCE_REMOVE,
                                    SceneObservable.REFERENCE_REMOVED,
                                    SceneObservable.BEFORE_REFERENCE_CREATE,
                                    SceneObservable.REFERENCE_CREATED,
                                    SceneObservable.BEFORE_FILE_IMPORT,
                                    SceneObservable.FILE_IMPORTED,
                                    SceneObservable.BEFORE_FILE_EXPORT,
                                    SceneObservable.FILE_EXPORTED]})

        # All the following Maya core callbacks are exposed in this class'
        # interface with identical semantics, except for
        # kAfterCreateReferenceAndRecordEdits.  This last callback is used
        # to provide the reference node and reference path arguments for our
        # reference created notification; this data is not provided by the
        # Maya core callback.  It is also used as an implementation detail
        # of our support for generating before and after load reference
        # messages on create reference, which the Maya core does not provide.
        referenceCallbacks = {
            OpenMaya.MSceneMessage.kBeforeLoadReference   : self._beforeLoadReferenceCB,
            OpenMaya.MSceneMessage.kAfterLoadReference    : self._afterLoadReferenceCB,
            OpenMaya.MSceneMessage.kBeforeUnloadReference : self._beforeUnloadReferenceCB,
            OpenMaya.MSceneMessage.kAfterUnloadReference  : self._afterUnloadReferenceCB,
            OpenMaya.MSceneMessage.kBeforeRemoveReference : self._beforeRemoveReferenceCB,
            OpenMaya.MSceneMessage.kAfterCreateReferenceAndRecordEdits : self._afterCreateReferenceAndRecordEditsCB } 
        
        self._cbIds = []

        for type, callback in referenceCallbacks.iteritems():
            self._cbIds.append(OpenMaya.MSceneMessage.addReferenceCallback(type, callback))
            
        # Add file open observation.
        self._observables.update({ key: ObservableProxy() for key in 
                                   [SceneObservable.BEFORE_FILE_OPEN,
                                    SceneObservable.FILE_OPENED] })
        
        fileOpenCallbacks = [
            (OpenMaya.MSceneMessage.kBeforeOpen, self._beforeOpenCB),
            (OpenMaya.MSceneMessage.kAfterOpen, self._afterOpenCB)
        ]

        for (msg, cb) in fileOpenCallbacks:
            self._cbIds.append(OpenMaya.MSceneMessage.addCallback(msg, cb))
    
        # After remove reference can't receive the reference node as an
        # argument to the callback, since it's been removed.  Similar
        # argument for before create reference.
        basicCallbacks = {
            OpenMaya.MSceneMessage.kAfterRemoveReference : self._afterRemoveReferenceCB,
            OpenMaya.MSceneMessage.kBeforeCreateReference: self._beforeCreateReferenceCB,
            OpenMaya.MSceneMessage.kBeforeImport: self._beforeImportCB,
            OpenMaya.MSceneMessage.kAfterImport : self._afterImportCB,
            OpenMaya.MSceneMessage.kBeforeExport: self._beforeExportCB,
            OpenMaya.MSceneMessage.kAfterExport : self._afterExportCB }

        for type, callback in basicCallbacks.iteritems():
            self._cbIds.append(OpenMaya.MSceneMessage.addCallback(
                type, callback))
        
        self._cbIds.append(OpenMaya.MModelMessage.addBeforeDuplicateCallback(self._beforeDuplicate))
        self._cbIds.append(OpenMaya.MModelMessage.addAfterDuplicateCallback(self._afterDuplicate))

    def deactivate(self):
        '''Removes callbacks to listen to scene changes'''
        if self.activated():
            for _, obs in self._observables.iteritems():
                obs.deactivate()
            self._observables = None
        for id in self._cbIds:
            OpenMaya.MMessage.removeCallback(id)
        self._cbIds = []
    
    def register(self, eventType, observer):
        '''Add a callback for the given event(s).'''
        if not self.activated():
            self.activate()
        self._observables[eventType].addItemObserver(observer)

    def unregister(self, eventType, observer):
        '''Removes a callback for the given event(s).'''
        if not self.activated():
            return
        self._observables[eventType].removeItemObserver(observer)

    def beforeNew(self):
        '''Infrastructure method called on file new.
        
        This method should not be called by SceneObservable clients.
        '''
        if self._deactivateOnFileNew:
            self.deactivate()
    
    @_enabled
    @guard.member('_isInSceneChangeCallback', True)
    def _notifyObservers(self, **kwArgs):
        if self.activated() and not OpenMaya1_0.MFileIO.isReadingFile() and not OpenMaya1_0.MFileIO.isReferencingFile():
            eventType = kwArgs['eventType']
            del kwArgs['eventType']
            self._observables[eventType].itemChanged(**kwArgs)

    def _isValid(self, obj):
        '''Check if obj is a valid object to send notifications for.'''
        return OpenMaya.MObjectHandle(obj).hashCode() not in self._aboutToCreate and utils.canOverrideNode(obj)

    @_enabled
    def _nodeAddedCB(self, obj, clientData):
        self._aboutToCreate.difference_update((OpenMaya.MObjectHandle(obj).hashCode(),))
        if not utils.canOverrideNode(obj):
            return
        if not self._duplicating:
            self._notifyObservers(eventType=SceneObservable.NODE_ADDED, obj=obj)
    
    @_enabled
    def _nodeRemovedCB(self, obj, clientData):
        if not utils.canOverrideNode(obj):
            return
        self._notifyObservers(eventType=SceneObservable.NODE_REMOVED, obj=obj)

    @_enabled
    def _nodeRenamedCB(self, obj, oldName, clientData):
        # Note: The oldName is a node name and not an absolute path
        if len(oldName) == 0:
            # node name is never empty after the node is done being created
            # => if this happens, then we know this node is in process of being created
            # => ignore events to this node until it is created
            self._aboutToCreate.add(OpenMaya.MObjectHandle(obj).hashCode())
            return
        
        if not self._isValid(obj) or oldName==OpenMaya.MFnDependencyNode(obj).name():
            return
        if self._duplicating:
            self._notifyObservers(eventType=SceneObservable.NODE_ADDED, obj=obj)
        else:
            self._notifyObservers(eventType=SceneObservable.NODE_RENAMED, obj=obj, oldName=oldName)
    
    @_enabled
    def _nodeReparentedCB(self, msgType, child, parent, clientData):
        if not self._isValid(child.node()):
            return
        self._notifyObservers(eventType=SceneObservable.NODE_REPARENTED, msgType=msgType, child=child, parent=parent)

    @_enabled
    def _connectionChangedCB(self, srcPlug, dstPlug, made, clientData):
        if not utils.canOverrideNode(srcPlug.node()) or not utils.canOverrideNode(dstPlug.node()):
            return
        self._notifyObservers(eventType=SceneObservable.CONNECTION_CHANGED, srcPlug=srcPlug, dstPlug=dstPlug, made=made)
    
    @_enabled
    def _beforeLoadReferenceCB(self, referenceNode, resolvedRefPath, clientData):
        self.startReferenceLoad = time.clock()
        self._notifyObservers(
            eventType=SceneObservable.BEFORE_REFERENCE_LOAD, 
            referenceNode=OpenMaya.MFnReference(referenceNode).name(), 
            resolvedRefPath=resolvedRefPath.expandedFullName())

    @_enabled
    def _afterLoadReferenceCB(self, referenceNode, resolvedRefPath, clientData):
        self._notifyObservers(
            eventType=SceneObservable.REFERENCE_LOADED,
            referenceNode=OpenMaya.MFnReference(referenceNode).name(),
            resolvedRefPath=resolvedRefPath.expandedFullName())
        endReferenceLoad = time.clock()
        interval = endReferenceLoad - self.startReferenceLoad
        logger.debug('Load reference took %s seconds.', interval)

    @_enabled
    def _beforeUnloadReferenceCB(self, referenceNode, resolvedRefPath, clientData):
        self.startReferenceUnload = time.clock()
        self._notifyObservers(
            eventType=SceneObservable.BEFORE_REFERENCE_UNLOAD,
            referenceNode=OpenMaya.MFnReference(referenceNode).name(),
            resolvedRefPath=resolvedRefPath.expandedFullName())

    @_enabled
    def _afterUnloadReferenceCB(self, referenceNode, resolvedRefPath, clientData):
        self._notifyObservers(
            eventType=SceneObservable.REFERENCE_UNLOADED, 
            referenceNode=OpenMaya.MFnReference(referenceNode).name(), 
            resolvedRefPath=resolvedRefPath.expandedFullName())
        endReferenceUnload = time.clock()
        interval = endReferenceUnload - self.startReferenceUnload
        logger.debug('Unload reference took %s seconds.', interval)
        
    @_enabled
    def _beforeRemoveReferenceCB(self, referenceNode, resolvedRefPath, clientData):
        refPath = resolvedRefPath.expandedFullName()
        refFn = OpenMaya.MFnReference(referenceNode)
        refName = refFn.name()
        self._notifyObservers(
            eventType=SceneObservable.BEFORE_REFERENCE_REMOVE, 
            referenceNode=refName, resolvedRefPath=refPath)

        # If reference was loaded, send an unload notification as well.
        # Maya does not do this.
        if refFn.isLoaded():
            self._notifyObservers(
                eventType=SceneObservable.BEFORE_REFERENCE_UNLOAD, 
                referenceNode=refName, resolvedRefPath=refPath)

            # Capture name, path of reference to pass it to the after
            # remove reference callback.
            self._refInfo = (refName, refPath)

    @_enabled
    def _afterRemoveReferenceCB(self, clientData):

        # If we sent a before unload notification on remove reference, send an
        # after unload notification as well.
        if self._refInfo is not None:
            (refName, refPath) = self._refInfo
            self._notifyObservers(eventType=SceneObservable.REFERENCE_UNLOADED,
                                  referenceNode=refName,
                                  resolvedRefPath=refPath)
            self._refInfo = None

        self._notifyObservers(eventType=SceneObservable.REFERENCE_REMOVED)
        
    @_enabled
    def _beforeCreateReferenceCB(self, clientData):
        self._notifyObservers(eventType=SceneObservable.BEFORE_REFERENCE_CREATE)
        
    @_enabled
    def _afterCreateReferenceAndRecordEditsCB(
            self, referenceNode, resolvedRefPath, clientData):
        # Contrary to API documentation, creation of a non-deferred
        # reference does NOT send reference loaded notifications.  Fake it
        # here: the plain after create reference notification bizarrely
        # doesn't have the reference node and resolved path arguments, so
        # use the "record edits" version.
        refPath = resolvedRefPath.expandedFullName()
        # The afterCreateReference/afterCreateReferenceAndRecordEdits callbacks
        # can pass a null reference node if the reference operation was aborted
        # via callbacks (eg. beforeCreateReferenceCheck). Exit early in this
        # scenario.
        try:
            refFn = OpenMaya.MFnReference(referenceNode)
        except RuntimeError:
            return
        refName = refFn.name()
        if refFn.isLoaded():
            # Awkwardly, we generate the before reference loaded message
            # AFTER the reference is actually loaded.  This is because we
            # are compensating for the fact that the Maya core does not
            # generate these messages, and must use the after create
            # reference support to do so.  The before create reference
            # message does not provide the reference node or reference
            # path, since they haven't been created yet.
            self._notifyObservers(
                eventType=SceneObservable.BEFORE_REFERENCE_LOAD,
                referenceNode=refName, resolvedRefPath=refPath)
            self._notifyObservers(
                eventType=SceneObservable.REFERENCE_LOADED,
                referenceNode=refName, resolvedRefPath=refPath)
        
        self._notifyObservers(
            eventType=SceneObservable.REFERENCE_CREATED,
            referenceNode=refName, resolvedRefPath=refPath)
    
    @_enabled
    def _beforeImportCB(self, clientData):
        self._notifyObservers(eventType=SceneObservable.BEFORE_FILE_IMPORT)
        
    @_enabled
    def _afterImportCB(self, clientData):
        self._notifyObservers(eventType=SceneObservable.FILE_IMPORTED)
        
    @_enabled
    def _beforeExportCB(self, clientData):
        self._notifyObservers(eventType=SceneObservable.BEFORE_FILE_EXPORT)
        
    @_enabled
    def _afterExportCB(self, clientData):
        self._notifyObservers(eventType=SceneObservable.FILE_EXPORTED)
        
    @_enabled
    def _beforeDuplicate(self, clientData):
        self._duplicating = True
        # See __init__() comments: during duplication, we block off node
        # added notifications, and have node renamed notifications generate
        # node added.  This requires us to have at least one node renamed
        # observer.  If we don't, we add one ourselves here.
        if self._observables[SceneObservable.NODE_RENAMED].nbObservers() == 0 \
           and self._observables[SceneObservable.NODE_ADDED].nbObservers() > 0:
            self._duringDuplicateRenamedObserver = True
            self.register(SceneObservable.NODE_RENAMED, 
                          self._duringDuplicateOnNodeRenamed)

    @_enabled
    def _afterDuplicate(self, clientData):
        self._duplicating = False
        if self._duringDuplicateRenamedObserver:
            self._duringDuplicateRenamedObserver = False
            self.unregister(SceneObservable.NODE_RENAMED, 
                            self._duringDuplicateOnNodeRenamed)

    def _duringDuplicateOnNodeRenamed(self, obj, oldName):
        # See _beforeDuplicate comments.
        pass

    @_enabled
    def _beforeOpenCB(self, clientData):
        self._notifyObservers(eventType=SceneObservable.BEFORE_FILE_OPEN)

    @_enabled
    def _afterOpenCB(self, clientData):
        self._notifyObservers(eventType=SceneObservable.FILE_OPENED)
        
_sceneObservable = None

def instance():

    global _sceneObservable
    
    if _sceneObservable is None:
        _sceneObservable = SceneObservable()

    return _sceneObservable
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
