import maya.app.renderSetup.model.observable as observable

class ProgressObservable(observable.SingletonObservable):
    """ When an operation has a high chance of taking time to complete, this
        class should be used to track information on its progress.
        The goal is to register observers that care about the progress of
        long operations so that they react to the incremental steps being done.
        The consumer has to take ownership of the singleton and give it back
        once the operation is complete.
    """

    class StartProgressNotification():
        def __init__(self):
            # Unused. Keep Pylint happy
            pass
    class EndProgressNotification():
        def __init__(self):
            # Unused. Keep Pylint happy
            pass

    def __init__(self):
        super(ProgressObservable, self).__init__()
        self.progress = 0
        # Multiple callers can notify observers that a long operation has
        # started and ended, but only the top level caller will be taken care
        # of, as we assume they are all for the same operation.
        self.callerCount = 0

    def startProgress(self):
        """ Allows a consumer to take ownership of this singleton.
            Should always be called before notifyItemObserver and endProgress.
        """
        if not self.inProgress():
            self.itemChanged(self.StartProgressNotification)
        self.callerCount += 1

    def notifyItemObserver(self, progress, info):
        """ Whenever the owner wants to notify observers of progress being done
            on the way to completing the long operation, this should be called
            with the percentage of progress already done and the info on the
            'suboperation' being computed.
        """
        self.progress = progress
        self.itemChanged(self.progress, info)

    def endProgress(self):
        """ This should always be called once the long operation is complete.
            This ceases ownership of the singleton for others to use it.
        """
        self.progress = 1
        if self.topLevelCaller():
            self.itemChanged(self.EndProgressNotification)
        self.callerCount -= 1

    def inProgress(self):
        """ As soon as the first caller calls startProgress, callerCount gets
            incremented, meaning that an operation is in progress.
        """
        return self.callerCount > 0

    def topLevelCaller(self):
        """ The first caller to call startProgress is the top level one, and
            the only one that gets taken care of. An assumption has to be made
            that the number of startProgress and endProgress calls is
            symmetrical. The ProgressCtxMgr helps to make that assumption true.
        """
        return self.callerCount == 1

class ProgressCtxMgr(object):
    """ This context manager can be used to encapsulate code containing
        a long operation. It allows the consumer to take ownership of the
        progress bar temporarily (on __exit__ ownership is given back to be
        used by other consumers).
    """
    def __init__(self):
        pass
    def __enter__(self):
        ProgressObservable().startProgress()
    def __exit__(self, exc_type, exc_val, exc_tb):
        ProgressObservable().endProgress()

def progress(f):
    """ This is a clean way to encapsulate the whole function f as a long op"""
    def wrapper(*args, **kwargs):
        with ProgressCtxMgr():
            return f(*args, **kwargs)
    return wrapper

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
