from PySide2.QtCore import *
from PySide2.QtGui import QColor, QFont, QFontMetrics, QGuiApplication, QStandardItem, QStandardItemModel
from PySide2.QtWidgets import QApplication

import weakref

import maya.cmds as cmds
import maya.mel as mel
import maya.api.OpenMaya as OpenMaya
import maya.app.renderSetup.model.applyOverride as applyOverride
import maya.app.renderSetup.model.renderSetupPrivate as renderSetupPrivate
import maya.app.renderSetup.model.undo as undo
import maya.app.renderSetup.common.guard as guard
import maya.app.renderSetup.views.pySide.standardItem as standardItem
import maya.app.renderSetup.views.utils as utils
import maya.app.renderSetup.views.proxy.renderSetup as rsProxy
import maya.app.renderSetup.views.proxy.renderSetupRoles as renderSetupRoles
from maya.app.renderSetup.views.proxy.renderSetupProxyStrings import *

import maya.app.renderSetup.lightEditor.model.editor as editorModel
import maya.app.renderSetup.lightEditor.model.item as itemModel
import maya.app.renderSetup.lightEditor.views.proxyFactory as proxyFactory
from maya.app.renderSetup.views.labelColorConstants import colors 

LIGHT_EDITOR_TYPE_IDX    = rsProxy.MAX_TYPE_IDX + 1
LIGHT_ITEM_BASE_TYPE_IDX = rsProxy.MAX_TYPE_IDX + 2
LIGHT_ITEM_TYPE_IDX      = rsProxy.MAX_TYPE_IDX + 3
LIGHT_GROUP_TYPE_IDX     = rsProxy.MAX_TYPE_IDX + 4

LIGHT_EDITOR_TYPE        = QStandardItem.UserType + LIGHT_EDITOR_TYPE_IDX
LIGHT_ITEM_BASE_TYPE     = QStandardItem.UserType + LIGHT_ITEM_BASE_TYPE_IDX
LIGHT_ITEM_TYPE          = QStandardItem.UserType + LIGHT_ITEM_TYPE_IDX
LIGHT_GROUP_TYPE         = QStandardItem.UserType + LIGHT_GROUP_TYPE_IDX

LIGHT_TEXT_COLOR                    = QColor(238,238,238)
DISABLED_LIGHT_TEXT_COLOR           = QColor(165,165,165)
LIGHT_TEXT_COLOR_OVERRIDEN_BY_US    = QColor(229, 105, 41)
LIGHT_TEXT_COLOR_LOCKED             = QColor(92,104,116)
LIGHT_TEXT_COLOR_ANIMATED           = QColor(255,0,0)
DEFAULT_LIGHT_GROUP_COLOR           = QColor(81,81,81)
DEFAULT_LIGHT_ITEM_COLOR            = QColor(71,71,71)

LIGHT_EDITOR_MIME_TYPE = "application/lightEditor"

def getProxy(dataModel):
    data = None
    if dataModel.hasOpaqueData(rsProxy.PROXY_OPAQUE_DATA):
        data = dataModel.getOpaqueData(rsProxy.PROXY_OPAQUE_DATA)
    return None if data is None else data()

class LabelColor(object):
    ''' Base class for all the proxy classes to offer the label color option '''

    def setLabelColor(self, label):
        self._model.setLabelColor(label)

    def getLabelColor(self):
        label = self._model.getLabelColor()
        if label in colors:
            color = colors[label]
            return QColor(*color)
        else:
            return self.getDefaultColor()

class LightItemProxyBase(LabelColor, standardItem.StandardItem):

    def __init__(self, model):
        super(LightItemProxyBase, self).__init__(model.name())
        self._model = model

        # Trying to add emitDataChanged as the bound method fails with
        # "'builtin_function_or_method' object has no attribute 'im_self'".
        # Most likely Python extension objects have this characteristic.
        # Use an intermediate Python method as a workaround.
        self._model.addItemObserver(self.modelChanged)
        self._modelDirty = False

        self._model.addOpaqueData(rsProxy.PROXY_OPAQUE_DATA, weakref.ref(self))

    def genericTypeIdx(self):
        # Constant for all derived classes
        return LIGHT_ITEM_BASE_TYPE_IDX

    def aboutToDelete(self):
        """Cleanup method to be called immediately before the object is deleted."""
        self._model.removeItemObserver(self.modelChanged)
        self._model.removeOpaqueData(rsProxy.PROXY_OPAQUE_DATA)

        for i in range(self.rowCount()):
            self.child(i).dispose()

    def delete(self):
        # listItemRemoved() data model list observation will take care of
        # removing ourself from our UI parent.
        itemModel.deleteItem(self._model)

    def isCopyable(self):
        return self._model.isCopyable()
            
    # Obsolete interface.
    dispose = aboutToDelete

    @property
    def model(self):
        """Get the data model object for this proxy item."""
        return self._model

    # The next function (isModelDirty) is a workaround.
    # It should not be necessary but it is currently because we set tooltips in the treeview
    # and that triggers emitDataChanged which triggers the rebuild or repopulate of the property editor.
    # The proper fix will be to use columns in the treeview where each column has its own static tooltip
    # and the tooltips should no longer be dynamically set by the delegate (views/renderSetupDelegate.py)
    # depending on the lastHitAction
    def isModelDirty(self):
        return self._modelDirty

    @guard.member('_modelDirty', True)
    def modelChanged(self, *posArgs, **kwArgs):
        self.emitDataChanged()

    def isActive(self):
        return False

    def getDefaultColor(self):
        return DEFAULT_LIGHT_ITEM_COLOR

    def data(self, role):
        if role == Qt.DisplayRole:
            return self._model.name()
        elif role == Qt.EditRole:
            return self._model.name()
        elif role == Qt.TextColorRole:
            return QGuiApplication.palette().text().color()
        elif role == Qt.FontRole:
            font = QApplication.font()
            if self._model.getImportedStatus():
                font.setStyle(QFont.StyleItalic)
                font.setWeight(QFont.Bold)
            return font
        elif role == Qt.TextAlignmentRole:
            return Qt.AlignLeft | Qt.AlignVCenter
        elif role == Qt.SizeHintRole:
            return QSize(0, utils.dpiScale(30))
        elif role == Qt.BackgroundRole:
            return self.getLabelColor() if self._model.isEnabled() \
                else self.getDefaultColor()
        elif role == Qt.ForegroundRole:
            return LIGHT_TEXT_COLOR if self._model.isSelfEnabled() \
                else DISABLED_LIGHT_TEXT_COLOR
        elif role == renderSetupRoles.NODE_TYPE_STR:
            return "%s:" % (mel.eval('interToUI(\"%s\")' % self._model.typeName()))
        elif role == renderSetupRoles.NODE_COLOR_BAR:
            return QColor(124, 194, 144)
        elif role == renderSetupRoles.NODE_ENABLED:
            return self._model.isEnabled()
        elif role == renderSetupRoles.NODE_SELF_ENABLED:
            return self._model.isSelfEnabled()
        elif role == renderSetupRoles.NODE_ISOLATE_SELECTED:
            return self._model.isIsolateSelected()
        elif role == renderSetupRoles.NODE_FLAGS:
            return Qt.ItemIsSelectable | Qt.ItemIsEditable | Qt.ItemIsEnabled | Qt.ItemIsDragEnabled
        elif role == renderSetupRoles.NODE_EDITABLE:
            return True
        elif role == renderSetupRoles.NODE_SHOULD_DISPLAY_NAME:
            return True
        else:
            return super(LightItemProxyBase, self).data(role)

    def setData(self, value, role):
        if role == renderSetupRoles.NODE_SELF_ENABLED:
            self._model.setSelfEnabled(value)
        elif role == renderSetupRoles.NODE_ISOLATE_SELECTED:
            self._model.setIsolateSelected(value)
        elif role == Qt.EditRole:
            self._model.rename(value)
        else:
            super(LightItemProxyBase, self).setData(value, role)

    def equalsDragType(self, dragType):
        return False
        
    def handleDragMoveEvent(self, event):
        event.ignore()

    def handleDropEvent(self, event, sceneView):
        pass

    def onClick(self, view):
        pass

    def onDoubleClick(self, view):
        pass

    def findProxyItem(self, name):
        if self.data(Qt.EditRole) == name:
            return self
        else:
            count = self.rowCount()
            for i in range(0, count):
                item = self.child(i, 0)
                result = item.findProxyItem(name)
                if result:
                    return result
            return None

    def headingWidth(self, heading):
        fm = QFontMetrics(self.data(Qt.FontRole))
        return fm.width(heading)

    def supportsAction(self, action, numIndexes):
        actions = set(
            [rsProxy.SET_ENABLED_ACTION, rsProxy.SET_ISOLATE_SELECTED_ACTION, rsProxy.DELETE_ACTION])
        if numIndexes == 1:
            actions |= set([rsProxy.RENAME_ACTION])
        return action in actions

    def getActionButton(self, column):
        if column == 0:
            return rsProxy.SET_ENABLED_ACTION
        elif column == 1:
            return rsProxy.SET_ISOLATE_SELECTED_ACTION
        return None

    def getActionButtonCount(self):
        return 2

    def isDropAllowed(self, destinationModel):
        return destinationModel.isAcceptableChild(self._model)


class LightItemProxy(LightItemProxyBase):
    """ The class provides the Qt model counterpart for the LightItem """
    """ It should forward any LightItem property request to the model,
        and handle any UI specific data """
        
    def __init__(self, model):
        super(LightItemProxy, self).__init__(model)

    def type(self):
        return QStandardItem.UserType + self.typeIdx()

    def typeIdx(self):
        return LIGHT_ITEM_TYPE_IDX

    def delete(self):
        # Delete the corresponding light source node which if successful will 
        # also delete the light item. Also catch any runtime errors doing so.
        # That way, if the light source deletion fails, we keep the light item
        # as well. Deletion can fail for referenced or otherwise locked nodes.
        try:
            xform = self._model.getLightTransform()
            cmds.delete(OpenMaya.MFnDagNode(xform).fullPathName())
        except:
            pass

    def data(self, role):
        if role == Qt.DisplayRole:
            return self.model.getLightName()
        elif role == Qt.EditRole:
            return self.model.getLightName()
        elif role == Qt.TextColorRole:
            return LIGHT_TEXT_COLOR
        elif role == renderSetupRoles.NODE_COLOR_BAR:
            return QColor(204,203,129)
        elif role == renderSetupRoles.NODE_TYPE_STR:
            return self.model.getLightType()
        elif role == renderSetupRoles.NODE_REBUILD_UI_WHEN_CHANGED:
            return self._model.needUIRebuildWhenChanged
        else:
            return super(LightItemProxy, self).data(role)

    def columnData(self, role, column):
        if role == Qt.DisplayRole:
            return self.model.getAttrValue(column)

        elif role == Qt.TextColorRole:
            plg = self.model.getAttrPlug(column)
            if not plg or not plg.plug.isDestination:
                return LIGHT_TEXT_COLOR

            source = plg.plug.source()
            fn = OpenMaya.MFnDependencyNode(source.node())

            # Check if override applied
            if isinstance(fn.userNode(), applyOverride.ApplyOverride):
                return LIGHT_TEXT_COLOR_OVERRIDEN_BY_US

            # Check if animated
            if fn.object().hasFn(OpenMaya.MFn.kAnimCurve):
                return LIGHT_TEXT_COLOR_ANIMATED

            return LIGHT_TEXT_COLOR

        else:
            return super(LightItemProxy, self).data(role)

    def acceptsDrops(self, attribute):
        return False

class LightGroupProxy(rsProxy.DataModelListObserver, LightItemProxyBase):
    """ The class provides the Qt model counterpart for the LightGroup """
    """ It should forward any LightGroup property request to the model,
        and handle any UI specific data """
        
    def __init__(self, model):
        super(LightGroupProxy, self).__init__(model)

        # Build first, then add ourselves as a list observer after,
        # otherwise we'll observe ourselves adding items to our list.
        self._build()

        self.addListObserver(self._model)

    def _build(self):
        # Load the current children
        for child in self._model.getChildren():
            proxy = self.createListItemProxy(child)
            self.appendRow(proxy)

    def aboutToDelete(self):
        """Cleanup method to be called immediately before the object is deleted."""
        super(LightGroupProxy, self).aboutToDelete()
        self.removeListObserver(self._model)

    # Obsolete interface.
    dispose = aboutToDelete

    def type(self):
        return QStandardItem.UserType + self.typeIdx()

    def typeIdx(self):
        return LIGHT_GROUP_TYPE_IDX

    def getDefaultColor(self):
        return DEFAULT_LIGHT_GROUP_COLOR

    def data(self, role):
        if role == Qt.ForegroundRole:
            return LIGHT_TEXT_COLOR
        elif role == renderSetupRoles.NODE_COLOR_BAR:
            return QColor(150, 150, 150)
        elif role == renderSetupRoles.NODE_FLAGS:
            return Qt.ItemIsSelectable | Qt.ItemIsEditable | Qt.ItemIsEnabled | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled
        elif role == renderSetupRoles.NODE_TYPE_STR:
            return "Light Group"
        else:
            return super(LightGroupProxy, self).data(role)

    def attachChild(self, override, pos):
        self.model.attachChild(pos, override)

    def acceptsDrops(self, attribute):
        return True

    def createListItemProxy(self, listItem):
        return proxyFactory.create(listItem)


class LightEditorProxy(rsProxy.DataModelListObserver, QStandardItemModel):
    """ The class provides the Qt model counterpart for the LightEditor model """

    def __init__(self, parent=None):
        super(LightEditorProxy, self).__init__(parent=parent)

        self._registered = False
        self._register()
        self.refreshModel()

        self.dropMimeDataFailure = False

    @property
    def model(self):
        """Get the data model object for this proxy item.
        If the data model object does not exist, None is returned."""
        return editorModel.instance() if editorModel.hasInstance() else None

    def aboutToDelete(self):
        """Cleanup method to be called immediately before the object is deleted."""
        self.resetModel()

    # Obsolete interface.
    dispose = aboutToDelete

    def __eq__(self, o):
        # The default QStandardItem:__eq__() method is not implemented
        # https://bugreports.qt.io/browse/PYSIDE-74
        return id(self)==id(o)
    
    def __ne__(self, o):
        # The default QStandardItem:__ne__() method is not implemented
        # https://bugreports.qt.io/browse/PYSIDE-74
        return not self.__eq__(o)

    def child(self, row, column=0):
        # LightEditorProxy is a QStandardItemModel, not a QStandardItem,
        # but needs to be treated as a QStandardItem by the data model list
        # observation code.
        return self.item(row, column)

    def _register(self):
        # Observe data model
        #
        # Unfortunately, this class does not behave as CollectionProxy
        # or RenderLayerProxy, and does not respond correctly to list
        # observation.  Entered as MAYA-59899.
        # 
        if editorModel.hasInstance() and not self._registered:
            self.addListObserver(editorModel.instance())
            self._registered = True

    def _unregister(self):
        if editorModel.hasInstance() and self._registered:
            self.removeListObserver(editorModel.instance())
            self._registered = False

    def _redraw(self, *args, **kwargs):
        self.layoutChanged.emit()

    def _buildHeader(self):
        header = QStandardItem(parent=self)
        header.setText("Light Editor 2.0")
        self.setHorizontalHeaderItem(0, header)

    def _buildTree(self):
        if editorModel.hasInstance():
            children = editorModel.instance().getChildren()
            for child in children:
                proxy = self.createListItemProxy(child)
                self.appendRow(proxy)

    def attachChild(self, child, pos):
        self.model.attachChild(pos, child)

    def resetModel(self):
        self._unregister()
        for idx in range(self.rowCount()):
            self.child(idx).dispose()
        self.clear()

    def refreshModel(self):
        self._register()
        self._buildHeader()
        self._buildTree()

    def type(self):
        return QStandardItem.UserType + self.typeIdx()

    def typeIdx(self):
        return LIGHT_EDITOR_TYPE_IDX

    def supportedDropActions(self):
        return Qt.MoveAction

    def mimeTypes(self):
        return [ LIGHT_EDITOR_MIME_TYPE ]

    def mimeData(self, indices):
        ''' This method builds the mimeData if the selection is correct '''

        # On drag start, prepare to pass the names of the dragged items to the drop mime data handler
        self.dropMimeDataFailure = False

        # Check that all selected entries have the same generic type
        genericModelTypeIdx  = None
        for index in indices:
            item = self.itemFromIndex(index)
            # Accept only item of the same 'generic' type
            if genericModelTypeIdx is None or genericModelTypeIdx==item.genericTypeIdx():
                genericModelTypeIdx = item.genericTypeIdx()
            else:
                self.dropMimeDataFailure = True
                break

        # Prepare the entries to move
        mimeData = QMimeData()
        if not self.dropMimeDataFailure:
            encodedData = QByteArray()
            stream      = QDataStream(encodedData, QIODevice.WriteOnly)
            for index in indices:
                item = self.itemFromIndex(index)
                stream.writeString(item.data(Qt.EditRole))
            mimeData.setData(LIGHT_EDITOR_MIME_TYPE, encodedData)

        return mimeData

    def dropMimeData(self, mimeData, action, row, column, parentIndex):
        if self.dropMimeDataFailure:
            # The mimeData parsing faced a type mismatch
            OpenMaya.MGlobal.displayError(kSelectionTypeError)
            return False

        self.dropMimeDataFailure = False

        if action == Qt.IgnoreAction:
            return False

        if not mimeData.hasFormat(LIGHT_EDITOR_MIME_TYPE) or column > 0:
            self.dropMimeDataFailure = True
            return False
            
        # row is -1 when dropped on a parent item and not between rows.
        #   In that case we want to insert at row 0
        if row == -1:
            row = 0

        # Parse the mime data that was passed to us (a list of item string names)
        encodedData = mimeData.data(LIGHT_EDITOR_MIME_TYPE)
        stream      = QDataStream(encodedData, QIODevice.ReadOnly)

        destinationModel = editorModel.instance() if not parentIndex.isValid() else self.itemFromIndex(parentIndex)._model

        # Is the drop allowed ?
        items = []
        while not stream.atEnd():
            name = stream.readString()
            item = self.findProxyItem(name)

            if (not item.isDropAllowed(destinationModel)):
                # Forbid the complete drop
                self.dropMimeDataFailure = True
                return False
            else:
                items.append(item)

        # Perform the drop
        try:
            with undo.CtxMgr(kDragAndDrop % (destinationModel.name(), row)):
                i = 0
                for item in items:
                    # If moving down within the same parent, the drop row must be
                    # decremented by one, as we're vacating one row.
                    destinationPosition = row + i
                    if item._model.parent() == destinationModel and row > item.row():
                        destinationPosition -= 1

                    renderSetupPrivate.moveModel(item._model, destinationModel, destinationPosition)

                    i += 1
        except Exception as ex:
            OpenMaya.MGlobal.displayError(kDragAndDropFailed % str(ex))
            self.dropMimeDataFailure = True

        return not self.dropMimeDataFailure

    def flags(self, index):
        if not index.isValid():
            return Qt.ItemIsDropEnabled
        item = self.itemFromIndex(index)
        if not item:
            return Qt.NoItemFlags
        return item.data(renderSetupRoles.NODE_FLAGS)

    def findProxyItem(self, name):
        count = self.rowCount()
        for i in range(0, count):
            index = self.index(i, 0)
            item = self.itemFromIndex(index)
            result = item.findProxyItem(name)
            if result is not None:
                return result
        return None

    def createListItemProxy(self, listItem):
        return proxyFactory.create(listItem)
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
