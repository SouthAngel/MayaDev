from maya.app.flux.ae.Template import Template
from maya.app.flux.ae.Custom import Custom
import maya.app.flux.ae.ui as faeui
from maya.app.flux.imports import *
import maya.app.flux.core as fx
from maya.app.flux.core import pix

import maya
import time

import MASH.api

fx.loadStringResources(__name__)
str_res=lambda name:fx.getStringResource(__name__,name)

import maya.app.type.TypeAnimTextWidget as TypeAnimTextWidget
import maya.app.type.plugin as typePlugin

class AEtypeTemplate(Template):
    def buildUI(self, nodeName):
        self.addCustom(MyCustom(nodeName))

class MyCustom(Custom):
    def buildUI(self, nodeName):
        start = time.time()
        self.fontDictionary = {}
        self.registerExternalNode('extrudeNode', self.getExtrudeNode)
        self.registerExternalNode('remeshNode', self.getRemeshNode)
        self.registerExternalNode('animationNode', self.getAnimationNode)

        self.modernExtrude = False
        if cmds.nodeType(self.getExtrudeNode()) != "vectorExtrude":
            self.modernExtrude = True

        self.supportedDefaultShaders = ['blinn', 'lambert', 'phong', 'phongE', 'rampShader']
        self.alignIcons = ['TypeAlignLeft', 'TypeAlignCentre', 'TypeAlignRight']
        self.lockUpdates = False
        self.preventSecondaryUpdate = False
        self.bevelIgnore = []

        self.createCustomWidgets()
        self.updateMaterialSplitBtn()

        with self.horizontalLayout():
            self.addWidget(self.font_menu)
            self.addSpacing(pix(2))
            self.addWidget(self.font_style_menu)
            self.addSpacing(pix(2))
            self.addWidget(self.writingSystemMenu)
        self.addWidget(self.textEdit)
        
        with self.tabLayout():

            with self.newTab('kText'):
                with self.indentLayout('kAlignment'):
                    self.addWidget(self.alignRadio)
                self.addSlider('fontSize', label='kFontSize')
                self.addSlider('tracking', label='kTracking')
                self.addSlider('kerningScale', label='kKerningScale')
                self.addSlider('leadingScale', label='kLeadingScale')
                self.addSlider('spaceWidthScale', label='kSpaceWidthScale')
                self.addSpacing(pix(2))
                with self.indentLayout(self.strRes('kTypeManipulator')):
                    self.addWidget(self.manipReplacementBtn)
                self.addSpacing(pix(2))

            with self.newTab('kGenerator'):
                self.addEnum('generator', label='kGenerator')

                with self.horizontalLayout(ref='typeAnimText'):
                    self.addWidget(self.typeAnimTextWidget)

                with self.stackedLayout(ref='generatorStack'):
                    with self.page():
                        pass

                    with self.page():
                        self.addSlider('length', label= 'kLength')
                        self.addSlider('changeRate', label= 'kChangeRate')

                    with self.page():
                        self.addSlider('length', label= 'kLength')
                        self.addSlider('decimalPlaces', label= 'kDecimalPlaces')
                        self.addSlider('changeRate', label= 'kChangeRate')

                    with self.page():
                        self.addEnum('randomizerMode', label='kRandomMode')
                        self.addSlider('randomSeed', label= 'kRandomSeed')
                        self.addSlider('length', label= 'kLength')
                        self.addSlider('changeRate', label= 'kChangeRate')

                        with self.verticalLayout(ref='decimalPlaces'):
                            self.addSlider('decimalPlaces', label= 'kDecimalPlaces')

                    with self.page():
                        self.addEnum('randomizerMode', label='kRandomMode')
                        self.addCheckbox('reverse', label= 'kReverseOrder')
                        self.addSlider('delay', label= 'kDelayFrames')
                        self.addCheckbox('random', label= 'kRandomiseDelay')
                        self.addSlider('randomSeed', label= 'kRandomSeed')
                        self.addSlider('percent', label= 'kScramblePercent')

                    with self.page():
                        self.addTextField('pythonExpression', label= 'kPythonExpression')
                

            with self.newTab('kGeometry'):

                with self.frameLayout('kMeshSettings', True):
                    self.addSlider('curveResolution', label= 'kCurveResolution')
                    self.addCheckbox('removeColinear', label= 'kFilterCollinearPoints' )
                    self.addSlider('colinearAngle', label= 'kCollinearAngle')
                    self.addCheckbox('enableDistanceFilter', label= 'kFilterByDistance')
                    self.addSlider('pointDistanceFilter', label= 'kDistance')
                    self.addCheckbox('deleteCaps', label= 'kDeleteCaps', node='extrudeNode')
                    with self.indentLayout(''):
                        self.addWidget(self.createCurveBtn)
                    self.addSpacing(pix(2))

                    with self.frameLayout('kDeformableType'):
                        self.addCheckbox('deformableType', label='kDeformableType')
                        self.addSlider('maxDivisions', label= 'kMaxEdgeDivisions')
                        self.addSlider('maxEdgeLength', label= 'kMaxEdgeLength')
                        self.addSlider('refineThreshold', label= 'kRefineThreshold', node='remeshNode')
                        self.addSlider('reduceThreshold', label= 'kReduceThreshold', node='remeshNode')
                        self.addSlider('maxTriangleCount', label= 'kMaxTriangleCount', node='remeshNode') 

                with self.frameLayout('kExtrusion', True):
                    self.addCheckbox('enableExtrusion', label='kEnableExtrusion', node='extrudeNode')
                    self.createFalloffCurve('extrudeCurve')
                    self.addSlider('extrudeDistance', label= 'kExtrudeDistance', node='extrudeNode')
                    self.addSlider('extrudeOffset', label='kExtrudeOffset', node='extrudeNode')
                    self.addSlider('extrudeDivisions', label= 'kExtrudeDivisions', node='extrudeNode')
                    self.addEnum('mode', label= 'kMode', node='extrudeNode')

                with self.frameLayout('kBevels', True, ref='bevels'):
                    with self.indentLayout(''):
                        self.enableBevel = qt.QCheckBox(self.strRes('kEnableFrontBevel'))
                        self.enableBevel.clicked.connect(self.enableBevelClicked)
                        self.addWidget(self.enableBevel)

                    self.addRadio('bevelStyle', label='kBevelStyle', labels=['kOuterBevel', 'kInnerBevel'], node='extrudeNode')

                    with self.horizontalLayout(ref='enableBackBevel'):
                        self.addCheckbox('enableBackBevel', label= 'kEnableBackBevel', node='extrudeNode')
                    with self.horizontalLayout(ref='rearBevelUsesFront'):
                        self.addCheckbox('rearBevelUsesFront', label= 'kUseFrontBevel', node='extrudeNode')

                    self.bevelChoiceGrp = qt.QButtonGroup()
                    self.frontBevelRadioBtn = qt.QRadioButton(self.strRes('Front Bevel'))
                    self.frontBevelRadioBtn.clicked.connect(self.switchFrontBevel)
                    self.backBevelRadioBtn = qt.QRadioButton(self.strRes('kBackBevel'))
                    self.backBevelRadioBtn.clicked.connect(self.switchBackBevel)
                    self.bevelChoiceGrp.addButton(self.frontBevelRadioBtn,0)
                    self.bevelChoiceGrp.addButton(self.backBevelRadioBtn,1)
                    self.frontBevelRadioBtn.setChecked(True)

                    if self.modernExtrude:
                        with self.frameLayout(fx.res('kBevelProfile'), True):
                            with self.stackedLayout(ref='outerFrontBevel'):
                                with self.page():
                                    pass
                                with self.page():
                                    with self.indentLayout('', ref='showFrontBackBevelOption'):
                                        self.addWidget(self.frontBevelRadioBtn)
                                        self.addWidget(self.backBevelRadioBtn)

                            with self.stackedLayout(ref='frontBackBevel'):
                                with self.page():
                                    self.createFalloffCurve('frontBevelCurve')
                                    self.addSlider('bevelDistance', label='kBevelDistance', node='extrudeNode')
                                    self.addSlider('bevelOffset', label='kBevelOffset', node='extrudeNode')
                                    self.addSlider('bevelDivisions', label='kBevelDivisions', node='extrudeNode')
                                with self.page():
                                    self.createFalloffCurve('backBevelCurve')
                                    self.addSlider('backBevelDistance', label= 'kBevelDistance', node='extrudeNode')
                                    self.addSlider('backBevelOffset', label= 'kBevelOffset', node='extrudeNode')
                                    self.addSlider('backBevelDivisions', label= 'kBevelDivisions', node='extrudeNode')
                    else:
                        # Legacy layout
                        with self.frameLayout('kOuterBevel', True, ref='outerBevel'):
                            self.createFalloffCurve('outerBevelCurve')
                            self.addSlider('outerBevelDistance', label= 'kBevelDistance', node='extrudeNode')
                            self.addSlider('extrudeOffset', label= 'kExtrudeOffset', node='extrudeNode')
                            self.addSlider('outerBevelDivisions', label= 'kBevelDivisions', node='extrudeNode')

                        with self.frameLayout('kFrontBevel', True, ref='frontBevel'):
                            self.createFalloffCurve('frontBevelCurve')
                            self.addSlider('bevelDistance', label='kBevelDistance', node='extrudeNode')
                            self.addSlider('bevelOffset', label='kExtrudeOffset', node='extrudeNode')
                            self.addSlider('bevelDivisions', label='kBevelDivisions', node='extrudeNode')

                        with self.frameLayout('kBackBevel', True, ref='backBevel'):
                            self.addCheckbox('enableBackBevel', label= 'kEnableBackBevel', node='extrudeNode')
                            self.addCheckbox('rearBevelUsesFront', label= 'kUseFrontBevel', node='extrudeNode')
                            self.createFalloffCurve('backBevelCurve')
                            self.addSlider('backBevelDistance', label= 'kBevelDistance', node='extrudeNode')
                            self.addSlider('backBevelOffset', label= 'kBevelOffset', node='extrudeNode')
                            self.addSlider('backBevelDivisions', label= 'kBevelDivisions', node='extrudeNode')

                #self.setLayoutHidden('outerBevel', True)

            with self.newTab('kTexturing'):
                with self.indentLayout('kDefaultShader'):
                    self.addWidget(self.shaderComboBox)
                    self.addSpacing(pix(5))
                    self.addWidget(self.materialSplitBtn)
                    self.addWidget(self.materialJoinBtn)

                a = self.addNavigation(label='kCapsShader')
                b = self.addNavigation(label='kBevelShader')
                c = self.addNavigation(label='kExtrudeShader')
                self.setupNavigationControls([a,b,c])

            with self.newTab('kAnimation'):
                self.onLayoutVisibilityChange(self.animationTabChanged)
                self.addCheckbox('enableAnimation', label='kAnimate', node='animationNode')
                with self.verticalLayout(ref='animateLayout'):
                    self.addEnum('animationMode', label='kAnimationMode', node='animationNode')

                    self.animPosControl = self.addVector('animationPosition', label='kTranslate', node='animationNode')
                    self.animRotControl = self.addVector('animationRotation', label='kRotate', node='animationNode')
                    self.animScaleControl = self.addVector('animationScale', label='kScale', node='animationNode')

                    with self.indentLayout(''):
                        self.addWidget(self.shellAnimationBtn)
                        self.addSpacing(pix(10))
                        self.addWidget(self.shellAnimOption)

                    self.addSpacing(pix(2)) 

                    with self.frameLayout('kAnimationPivots', True):
                        self.addCheckbox('enablePivotDisplay', label='kDisplayPivotPoints', node='animationNode')
                        with self.horizontalLayout():
                            self.addSlider('xPivotLocation', label='kXPivot', node='animationNode')
                            self.createLocalPivotBtn('x')

                        with self.horizontalLayout():
                            self.addSlider('yPivotLocation', label='kYPivot', node='animationNode')
                            self.createLocalPivotBtn('y')

                        with self.horizontalLayout():
                            self.addSlider('zPivotLocation', label='kZPivot', node='animationNode')
                            self.createLocalPivotBtn('z')

                    with self.frameLayout('kDelay', True):
                        self.addCheckbox('reverseOrder', label='kReverseOrder', node='animationNode')
                        self.addSlider('offsetFrames', label='kDelayFrames', node='animationNode')
                        self.addCheckbox('randomDelay', label='kRandomiseDelay', node='animationNode')
                        self.addSlider('randomSeed', label='kRandomSeed', node='animationNode')

                self.addSpacing(pix(2))
                with self.indentLayout(fx.res('kConnectToMASH')):
                    self.mashconnection = fx.SingleNodeInputWidget('MASH_Waiter', self.createAndConnectToMash, self.getAcceptableNodesForMASH)
                    self.mashconnection.setFixedWidth(pix(260))
                    self.mashconnection.setNode(self.getMashConnection())
                    self.mashconnection.accepted.connect(self.connectToMash)
                    self.addWidget(self.mashconnection)
                    self.addStretch()
                self.addSpacing(pix(2))
                with self.indentLayout(''):
                    self.addWidget(self.addShellDynamicsBtn)
                self.addSpacing(pix(2))

        self.createAttributeListener('deformableType', self.deformableTypeChanged)
        self.createAttributeListener('bevelStyle', self.bevelStyleChanged, node='extrudeNode')
        self.createAttributeListener('textInput', self.updateTextValues)
        self.createAttributeListener('currentFont', self.updateFont)
        self.createAttributeListener('currentStyle', self.updateFontStyle)
        self.createAttributeListener('writingSystem', self.updateWritingSystem)
        self.createAttributeListener('enableExtrusion', self.extrudeEnableChanged, node='extrudeNode')
        self.createAttributeListener('enableBackBevel', self.backBevelEnabledChanged, node='extrudeNode')
        self.createAttributeListener('rearBevelUsesFront', self.backBevelEnabledChanged, node='extrudeNode')
        self.createAttributeListener('generator', self.generatorChanged)
        self.createAttributeListener('enableAnimation', self.updateAnimateEnabled, node='animationNode')
        self.createAttributeListener('randomizerMode', self.updateDecimalPlaces)
        self.updateBevelVisibility()
        self.extrudeEnableChanged()
        self.backBevelEnabledChanged()
        self.generatorChanged()
        self.updateAnimateEnabled()
        self.updateDecimalPlaces()
        self.updateMASHShortcuts()
        self.fixAnimLegacyConnections()
        self.updateShellAnimOption()

    def isAnimConnLegacy(self):
        return cmds.isConnected(self.name + '.animationPosition', 
                        self.getAnimationNode() + '.animationPosition')

    def fixAnimLegacyConnections(self):
        kwargs = {'node': 'animationNode'}
        if self.isAnimConnLegacy():
            kwargs = {}

        self.setControlAttr(self.animPosControl, 'animationPosition', **kwargs)
        self.setControlAttr(self.animRotControl, 'animationRotation', **kwargs)
        self.setControlAttr(self.animScaleControl, 'animationScale', **kwargs)

    def animationTabChanged(self, visible):
        if visible:
            selection = cmds.ls(sl=True) or []
            selection += [self.getAnimationNode(), self.name]
            cmds.select(*selection)

    def getAcceptableNodesForMASH(self):
        nodes = cmds.ls(typ='MASH_Waiter')
        filteredNodes = []
        for node in nodes:
            hasDynamics = False

            allnodes = MASH.api.getAllNodesInNetwork(node)

            for mashNode in allnodes:
                if cmds.nodeType(mashNode) == 'MASH_Dynamics':
                    hasDynamics = True
                    break

            if not hasDynamics:
                filteredNodes.append(node)

        return filteredNodes


    def updateMASHShortcuts(self):
        mashNode = self.getMashConnection()
        transformNode = cmds.listConnections( self.name + '.transformMessage', d=True, s=True)[0]
        connections = cmds.listConnections(transformNode + '.worldMatrix', d=True, s=True) or []
        hasDynamics = False
        for c in connections:
            if cmds.nodeType(c) == 'MASH_DynamicsInitialState':
                hasDynamics = True

        self.mashconnection.setNode(mashNode)

        self.mashconnection.setEnabled(not hasDynamics)
        self.addShellDynamicsBtn.setEnabled(not hasDynamics and not mashNode)

    def getMashConnection(self):
        shellDeformer = cmds.listConnections (self.name+".animationMessage", d=True, s=False, p=False)
        if shellDeformer:
            conn = cmds.listConnections(shellDeformer[0]+".inputPoints")
            if conn:
                return conn[0]
        return None

    def addShellDynamics(self):
        import MASH.dynamicsUtils as dynamics
        
        transformNode = cmds.listConnections( self.name + '.transformMessage', d=True, s=True)[0]
        cmds.select(transformNode)
        dynamics.shellDynamicsEntry(name='MASH_' + self.name)

        self.updateMASHShortcuts()

    def createAndConnectToMash(self):
        import MASH.api as mapi
        cmds.select(clear=True)
        mashNetwork = mapi.Network()
        mashNetwork.createNetwork(name='MASH_' + self.name)
        self.connectToMash(mashNetwork.waiter)

    def connectToMash(self, name):
        if name:
            import MASHtoVector
            transformNode = cmds.listConnections( self.name + '.transformMessage', d=True, s=True)[0]
            cmds.select(clear=True)
            cmds.select(name, ne=True, add=True)
            cmds.select(transformNode, add=True)
            MASHtoVector.connectToVector()
            self.mashconnection.setNode(self.getMashConnection())

            self.updateMASHShortcuts()

    def updateDecimalPlaces(self):
        value = cmds.getAttr(self.name + '.randomizerMode')
        self.setLayoutHidden('decimalPlaces', value!=2)

    def updateAnimateEnabled(self):
        value = cmds.getAttr(self.getAnimationNode() + '.enableAnimation')
        self.setLayoutEnabled('animateLayout', value)

    def generatorChanged(self):
        value = cmds.getAttr(self.name + '.generator')
        if value == 6:
            value = 3
        elif value == 8:
            value = 4
        elif value == 9:
            value = 5
        self.setIndex('generatorStack', value)
        self.setLayoutHidden('typeAnimText', not (value == 3 or value == 4))

    def backBevelEnabledChanged(self):
        a = cmds.getAttr(self.getExtrudeNode() + '.enableBackBevel')
        b = not cmds.getAttr(self.getExtrudeNode() + '.rearBevelUsesFront')
        hidden = not (a and b)

        self.setLayoutHidden('showFrontBackBevelOption', hidden)
        if hidden:
            self.frontBevelRadioBtn.setChecked(True)
            self.switchFrontBevel()

        self.setLayoutHidden('rearBevelUsesFront', not a)

    def enableBevelClicked(self):
        if not self.isBevelEnabled():
            self.enableBevelStyle()
        else:
            self.disableAllBevels()

    def disableAllBevels(self):
        a = cmds.getAttr(self.getExtrudeNode() + '.enableFrontBevel')
        b = cmds.getAttr(self.getExtrudeNode() + '.enableBackBevel')
        c = cmds.getAttr(self.getExtrudeNode() + '.enableOuterBevel')

        if a == 1:
            cmds.setAttr(self.getExtrudeNode() + '.enableFrontBevel', 0)
        
        if b == 1:
            cmds.setAttr(self.getExtrudeNode() + '.enableBackBevel', 0)

        if c == 1:
            cmds.setAttr(self.getExtrudeNode() + '.enableOuterBevel', 0)

    def enableBevelStyle(self):
        style = cmds.getAttr(self.getExtrudeNode() + '.bevelStyle')
        if style == 2:
            cmds.setAttr(self.getExtrudeNode() + '.enableOuterBevel', 0)
            cmds.setAttr(self.getExtrudeNode() + '.enableFrontBevel', 1)
        else:
            cmds.setAttr(self.getExtrudeNode() + '.enableFrontBevel', 0)
            cmds.setAttr(self.getExtrudeNode() + '.enableBackBevel', 0)
            cmds.setAttr(self.getExtrudeNode() + '.enableOuterBevel', 1)

    def extrudeEnableChanged(self):
        enabled = cmds.getAttr(self.getExtrudeNode() + '.enableExtrusion')
        self.setLayoutEnabled('bevels', enabled)

    def switchFrontBevel(self):
        self.setIndex('frontBackBevel', 0)

    def switchBackBevel(self):
        self.setIndex('frontBackBevel', 1)

    def isBevelEnabled(self):
        a = cmds.getAttr(self.getExtrudeNode() + '.enableOuterBevel')
        b = cmds.getAttr(self.getExtrudeNode() + '.enableFrontBevel')
        return (a or b)
        
    def bevelStyleChanged(self):
        self.updateBevelVisibility()
        self.enableDisableBevels()

    def updateBevelVisibility(self):
        value = cmds.getAttr(self.getExtrudeNode() + '.bevelStyle')

        if self.modernExtrude:
            if value == 1:
                self.setIndex('outerFrontBevel', 0)
                self.setIndex('frontBackBevel', 0)
            else:
                self.setIndex('outerFrontBevel', 1)
                self.setIndex('frontBackBevel', self.bevelChoiceGrp.checkedId())

            self.setLayoutHidden('enableBackBevel', value == 1)
            
            if self.isBevelEnabled():
                self.enableBevel.setChecked(True)
            else:
                self.enableBevel.setChecked(False)
        else:
            self.setLayoutHidden('outerBevel', value==0)
            self.setLayoutHidden('frontBevel', value==1)
            self.setLayoutHidden('backBevel', value==1)

    def enableDisableBevels(self):
        if self.isBevelEnabled():
            self.enableBevelStyle()
        else:
            self.disableAllBevels()
                        

    def setupNavigationControls(self, navigations):
        self.navigations = navigations
        transformNode = cmds.listConnections( self.name+'.transformMessage', d=True, s=True)[0]
        shadingAttributes = getShaderFromObject(transformNode)
        materialNumber = len(shadingAttributes)

        if materialNumber == 3:
            shaderList = getVectorShadingGroups (self.name, self.getExtrudeNode())
            
            if len(shaderList) == 0:
                
                for i in xrange (3):
                    self.setControlEnabled(self.navigations[i], False)
                    cmds.attrNavigationControlGrp(self.navigations[i], e=True, attribute=shadingAttributes[i])
            else:
                for i in xrange (3):
                    self.setControlEnabled(self.navigations[i], True)
                    cmds.attrNavigationControlGrp(self.navigations[i], e=True, attribute=shaderList[i])

        elif materialNumber == 2:
            for i in xrange (3):
                self.setControlLabel(self.navigations[i], self.strRes('kTypeShader'))
            cmds.attrNavigationControlGrp(self.navigations[0], e=True, attribute=shadingAttributes[0])
            cmds.attrNavigationControlGrp(self.navigations[1], e=True, attribute=shadingAttributes[1])
        else:
            self.setControlLabel(self.navigations[0], self.strRes('kTypeShader'))
            self.setControlEnabled(self.navigations[1], False)
            self.setControlEnabled(self.navigations[2], False)
            if shadingAttributes:
                cmds.attrNavigationControlGrp(self.navigations[0], e=True, attribute=shadingAttributes[0])

        self.updateMaterialSplitBtn()

    def getShader(self, index):
        shaderList = getVectorShadingGroups (self.name, self.getExtrudeNode())
        return shaderList[index].split('.')[0]

    def deformableTypeChanged(self):
        value = cmds.getAttr(self.name + '.deformableType')
        cmds.setAttr(self.getRemeshNode() + '.nodeState', not value)

    def createCustomWidgets(self):
        self.textEdit = qt.QTextEdit()
        self.textEdit.setToolTip(self.strRes('kEnterType'))
        self.textEdit.setAcceptRichText(False)
        self.textEdit.setFixedHeight(pix(100))
        self.textEdit.textChanged.connect(self.textChanged)

        comboStyle = '''
            QComboBox {
                border: %dpx solid rgba(93,93,93,255);
                border-radius: %dpx;
            }

            QComboBox::drop-down {
                background: rgba(93,93,93,255);
                width: %dpx;
            }

            QComboBox::down-arrow {
                width: %d;
                height: %d;
                border-left: %dpx solid rgba(93,93,93,255);
                border-right: %dpx solid rgba(93,93,93,255);
                border-top: %dpx solid rgba(187,187,187,255);
            }
            ''' % (pix(1), pix(2), pix(18), pix(0), pix(0), pix(4), pix(4), pix(4))

        self.font_menu = qt.QFontComboBox()
        self.font_menu.setStyleSheet(comboStyle)
        self.font_menu.setToolTip(self.strRes('kChooseFont' ))
        self.font_menu.setFontFilters(qt.QFontComboBox.ScalableFonts)
        self.font_menu.currentIndexChanged.connect(self.fontChanged)

        self.font_style_menu = qt.QComboBox()
        self.font_style_menu.setStyleSheet(comboStyle)
        self.font_style_menu.setToolTip(self.strRes('kChooseFont'))
        self.font_style_menu.setEditable(True)
        self.font_style_menu.currentIndexChanged.connect(self.fontStyleChanged)

        self.writingSystemMenu = qt.QComboBox()
        self.writingSystemMenu.setStyleSheet(comboStyle)
        self.writingSystemMenu.setToolTip(self.strRes('kChooseWritingSystem'))
        self.writingSystemMenu.setEditable(True)
        self.writingSystemMenu.currentIndexChanged.connect(self.writingSystemChanged)

        self.lockUpdates = True
        self.setupWritingSystems()
        self.initFontDictionary()
        self.loadStyleList()
        self.lockUpdates = False

        self.alignRadio = faeui.RadioImageGroup(self.alignIcons)
        self.alignRadio.clicked.connect(self.alignClicked)
        self.createAttributeListener('alignmentMode', self.alignChanged)     

        self.manipReplacementBtn = fx.ImageButton('TypeMoveTool')
        self.manipReplacementBtn.setToolTip(self.strRes('kTransformType'))
        self.manipReplacementBtn.clicked.connect(self.manipReplacementClicked)
        self.createContextListener(self.contextChanged)

        self.shellAnimationBtn = faeui.IconButton(self.strRes('kSetKeys'), 'setKeyframe')
        self.shellAnimationBtn.setToolTip(self.strRes('kSetKeysTransRotScale')) 
        self.shellAnimationBtn.clicked.connect(self.shellAnimationClicked)

        self.shellAnimOption = qt.QCheckBox(self.strRes('kAutoUpdateOnSetKey'))
        self.shellAnimOption.stateChanged.connect(self.shellAnimOptionChanged)

        self.connToMashBtn = faeui.IconButton(fx.res('kConnectToMASH'), 'out_MASH_Waiter')
        self.connToMashBtn.clicked.connect(self.connectToMash)

        self.addShellDynamicsBtn = faeui.IconButton(fx.res('kAddDynamics'), 'out_MASH_Dynamics')
        self.addShellDynamicsBtn.clicked.connect(self.addShellDynamics)

        self.shaderComboBox = qt.QComboBox()
        for shader in self.supportedDefaultShaders:
            self.shaderComboBox.addItem(shader)

        self.materialSplitBtn = fx.ImageButton('TypeSeparateMaterials')
        self.materialSplitBtn.setToolTip(self.strRes('kCreateSeparate'))
        self.materialSplitBtn.clicked.connect(self.materialSplitClicked)

        self.materialJoinBtn = fx.ImageButton('TypeDefaultMaterial')
        self.materialJoinBtn.setToolTip(self.strRes('kCreateSingleShader'))
        self.materialJoinBtn.clicked.connect(self.materialJoinClicked)

        self.createCurveBtn = faeui.IconButton(self.strRes('kCreateCurvesFromType'), 'curveEP')
        self.createCurveBtn.setToolTip(self.strRes('kCreateNURBS'))
        self.createCurveBtn.clicked.connect(self.createCurveClicked)

        self.typeAnimTextWidget = TypeAnimTextWidget.TypeAnimTextWidget(self.name)

        self.updateWritingSystem()
        self.updateFont()
        self.updateFontStyle()
        self.updateTextValues()
        self.contextChanged()

    def updateShellAnimOption(self):
        checked = typePlugin.getAnimCallbackOption()
        self.shellAnimOption.blockSignals(True)
        self.shellAnimOption.setChecked(checked)
        self.shellAnimOption.blockSignals(False)

    def shellAnimOptionChanged(self, index):
        checked = self.shellAnimOption.isChecked()
        typePlugin.setAnimCallbackOption(checked)

    def fontChanged(self, index=None):
        if self.lockUpdates: return
        value = self.font_menu.currentText()
        value = UniToEscaped(value)
        cmds.setAttr(self.name + '.currentFont', value, typ='string')
        
        self.loadStyleList()

        #self.updateTextValues()

    def fontStyleChanged(self, index=None):
        if self.lockUpdates: return
        value = self.font_style_menu.currentText()
        value = UniToEscaped(value)
        cmds.setAttr(self.name + '.currentStyle', value, typ='string')

        self.updateTextValues()

    def writingSystemChanged(self, index=None):
        if self.lockUpdates: return
        value = self.writingSystemMenu.currentText()
        value = UniToEscaped(value)
        cmds.setAttr(self.name + '.writingSystem', value, typ='string')

        self.updateFontWritingSystem()
        self.updateTextValues()

    def updateFontWritingSystem(self):
        tvalue = self.writingSystemMenu.currentText()

        if tvalue == 'Any':
            self.font_menu.setWritingSystem(qt.QFontDatabase.Any)
        else:
            currentIndex = self.writingSystemMenu.currentIndex() - 1
            f_db = qt.QFontDatabase()
            self.font_menu.setWritingSystem(f_db.writingSystems()[currentIndex])

        self.initFontDictionary()

    def textChanged(self):
        if self.lockUpdates: return
        plainText = self.textEdit.toPlainText()
        if len(plainText) == 0:
            plainText = " "
        byteString = ByteToHex(plainText)
        self.preventSecondaryUpdate = True

        className = getCurrentCtxName()
        if (className == "typeTRSTool"):
            cmds.SelectTool()

        cmds.setAttr(self.name + '.textInput', byteString, typ='string')


    def updateTextValues(self):
        if self.preventSecondaryUpdate:
            self.preventSecondaryUpdate = False
            return
        text = cmds.getAttr(self.name + '.textInput')
        text = HexToUni(text)
        
        f = self.textEdit.currentFont()
        fontDatabase = qt.QFontDatabase()
        self.lockUpdates = True
        self.textEdit.setCurrentFont(fontDatabase.font(self.font_menu.currentText(), self.font_style_menu.currentText(), f.pixelSize()))
        self.textEdit.setPlainText(text)
        self.lockUpdates = False

    def updateFont(self):
        text = cmds.getAttr(self.name + '.currentFont')
        text = EscapedToUni(text)

        for i in xrange(self.font_menu.count()):
            if text == self.font_menu.itemText(i):
                self.lockUpdates = True
                self.font_menu.setCurrentIndex(i)
                self.lockUpdates = False
                return

    def updateFontStyle(self):
        text = cmds.getAttr(self.name + '.currentStyle')
        text = EscapedToUni(text)

        for i in xrange(self.font_style_menu.count()):
            if text == self.font_style_menu.itemText(i):
                self.lockUpdates = True
                self.font_style_menu.setCurrentIndex(i)
                self.lockUpdates = False
                return


    def updateWritingSystem(self):
        text = cmds.getAttr(self.name + '.writingSystem')
        if len(text) == 0:
            text = 'Any'
        else:
            text = EscapedToUni(text)

        for i in xrange(self.writingSystemMenu.count()):
            if text == self.writingSystemMenu.itemText(i):
                self.lockUpdates = True
                self.writingSystemMenu.setCurrentIndex(i)
                self.lockUpdates = False
                return

    def shellAnimationClicked(self):
        node = self.getAnimationNode()
        if self.isAnimConnLegacy():
            node = self.name
        cmds.setKeyframe(node, at='animationPosition')
        cmds.setKeyframe(node, at='animationRotation')
        cmds.setKeyframe(node, at='animationScale')
        # set the animation attributes as dirty to force evaluation
        cmds.dgdirty('%s.animationPosition' % node)

    def alignClicked(self, index):
        cmds.setAttr(self.name + '.alignmentMode', index+1)

    def alignChanged(self, *args):
        self.alignRadio.setIndex(cmds.getAttr(self.name + '.alignmentMode') - 1)

    def createLocalPivotBtn(self, axis):
        btn = fx.ImageButton('TypePivot')
        btn.setFixedWidth(pix(17))
        btn.clicked.connect(lambda axis=axis: self.pivotLocationClicked(axis))   
        self.addWidget(btn)

    def showLocalPivotMenu(self, axis, rpChecked, spChecked):
        treeMenu = qt.QMenu()
        a = treeMenu.addAction(fx.res('kLocalRotatePivot'), lambda cmd=axis+'RP': self.pivotLocationMenuClicked(cmd))
        b = treeMenu.addAction(fx.res('kLocalScalePivot'), lambda cmd=axis+'SP': self.pivotLocationMenuClicked(cmd))
        a.setCheckable(True)
        b.setCheckable(True)

        a.setChecked(rpChecked)
        b.setChecked(spChecked)
        treeMenu.exec_(qt.QCursor.pos())

    def createFalloffCurve(self, attr):
        with self.horizontalLayout(height=pix(185)):
            mel.eval('createTypeFalloffCurve("%s")' % (self.getExtrudeNode() + '.' + attr))

    def editFalloffCurve(self, attr):
        mel.eval('editTypeFalloffCurve("%s")' % (self.getExtrudeNode() + '.' + attr))

    def contextChanged(self):
        className = getCurrentCtxName()
        self.manipReplacementBtn.setHighlighted(className == "typeTRSTool")


    def manipReplacementClicked(self):
        className = getCurrentCtxName()
        if (className == "typeTRSTool"):
            cmds.SelectTool()
        else:
            transforms = cmds.listConnections(self.name+'.transformMessage')
            cmds.select(transforms[0], replace=True)
            self.manipReplacementBtn.setHighlighted(True)
            mel.eval("typeMoveTool")

    def materialSplitClicked(self):
        transformNode = cmds.listConnections( self.name + '.transformMessage', d=True, s=True)[0]
        relatives = cmds.listRelatives(transformNode, s=True, c=True)
        if not relatives: return

        meshShape = relatives[0]

        cmds.undoInfo(openChunk=True)
        splitTypeMaterials(self.getExtrudeNode(), meshShape, self.name, self.shaderComboBox.currentText())
        cmds.undoInfo(closeChunk=True)

        self.setupNavigationControls(self.navigations)

    def materialJoinClicked(self):
        transformNode = cmds.listConnections( self.name + '.transformMessage', d=True, s=True)[0]
        relatives = cmds.listRelatives(transformNode, s=True, c=True)
        if not relatives: return

        meshShape = relatives[0]

        cmds.undoInfo (openChunk=True)
        joinTypeMaterials(meshShape, self.name, self.shaderComboBox.currentText())
        cmds.undoInfo (closeChunk=True)

        self.setupNavigationControls(self.navigations)

    def updateMaterialSplitBtn(self):
        transformNode = cmds.listConnections(self.name + '.transformMessage', d=True, s=True)[0]
        shadingAttributes = getShaderFromObject(transformNode)
        materialNumber = len(shadingAttributes)

        if (materialNumber > 1):
            self.materialSplitBtn.setEnabled(False)
        else:
            self.materialSplitBtn.setEnabled(True)


    def createCurveClicked(self):
        maya.mel.eval("convertTypeCapsToCurves;")

    def pivotLocationClicked(self, axis):
        rp = cmds.getAttr(self.getAnimationNode() + '.local%sRotationPivot' % axis.upper())
        sp = cmds.getAttr(self.getAnimationNode() + '.local%sScalePivot' % axis.upper())
        self.showLocalPivotMenu(axis, rp, sp)

    def pivotLocationMenuClicked(self, cmd):
        axis = cmd[0]
        pivot = 'RotationPivot' if cmd[1:]=='RP' else 'ScalePivot'
        attr = self.getAnimationNode() + '.local' + axis.upper() + pivot
        value = cmds.getAttr(attr)
        cmds.setAttr(attr, not value)

    def nodeChanged(self):
        self.alignChanged()
        self.editFalloffCurve('extrudeCurve')

        if self.modernExtrude:
            self.editFalloffCurve('frontBevelCurve')
        else:
            self.editFalloffCurve('frontBevelCurve')
            self.editFalloffCurve('outerBevelCurve')

        self.editFalloffCurve('backBevelCurve')
        self.updateMaterialSplitBtn()
        self.setupNavigationControls(self.navigations)
        self.typeAnimTextWidget.set_node(self.name)
        self.updateBevelVisibility()
        self.extrudeEnableChanged()
        self.backBevelEnabledChanged()
        self.generatorChanged()
        self.updateAnimateEnabled()
        self.updateDecimalPlaces()
        self.updateMASHShortcuts()
        self.fixAnimLegacyConnections()
        self.updateShellAnimOption()

        self.updateWritingSystem()
        self.updateFont()
        self.updateFontStyle()
        self.updateTextValues()


    # Utilities
    def getExtrudeNode(self):
        if 'extrude' not in self.cachedNodes:
            self.cachedNodes['extrude'] = cmds.listConnections( self.name+'.extrudeMessage', d=True, s=True)[0]
        return self.cachedNodes['extrude']

    def getRemeshNode(self):
        if 'remesh' not in self.cachedNodes:
            self.cachedNodes['remesh'] =  cmds.listConnections( self.name + '.remeshMessage', d=True, s=True)[0]
        return self.cachedNodes['remesh']

    def getAnimationNode(self):
        if 'animation' not in self.cachedNodes:
            self.cachedNodes['animation'] = cmds.listConnections( self.name+'.animationMessage', d=True, s=True)[0]
        return self.cachedNodes['animation']

    def setupWritingSystems(self):
        fontDatabase = qt.QFontDatabase()

        self.writingSystemMenu.clear()
        model = self.writingSystemMenu.model()
        self.font_menu.setWritingSystem(qt.QFontDatabase.Any)
        item = qt.QStandardItem('Any')
        model.appendRow(item)

        for system in fontDatabase.writingSystems():
            sample = fontDatabase.writingSystemSample(system)
            wsName = fontDatabase.writingSystemName(system)
            writingSystemTitle = wsName
            item = qt.QStandardItem(writingSystemTitle)
            model.appendRow(item)

    def loadStyleList(self):
        font = self.font_menu.currentFont()
        currentFont = qt.QFont.family(font)
        theseStyles = set()
        for style in self.fontDictionary.get(currentFont, []):
            theseStyles.add(style)
        theseStyles = sorted(theseStyles)

        #add them to the style menu
        self.font_style_menu.clear()
        model = self.font_style_menu.model()
        for thisStyle in theseStyles:
            item = qt.QStandardItem(thisStyle)
            model.appendRow(item)

    def initFontDictionary(self):
        self.fontDictionary = {}
        listFromAPI = cmds.getAttr(self.name+'.fontStyleList')
        for index in range(len(listFromAPI)/2):
            family = EscapedToUni(listFromAPI[2*index])
            style  = EscapedToUni(listFromAPI[2*index+1])
            self.fontDictionary.setdefault(family, []).append(style)

    def strRes(self, name):
        return self.stringResourceFunction(name)

    def stringResourceFunction(self, name):
        result = name
        try:
            result = maya.stringTable['y_maya.app.type.AEtypeTemplate.' + name]
        except:
            pass
        return result

def getCurrentCtxName():
    ctx = cmds.currentCtx()
    className = ""
    if True == cmds.contextInfo(ctx, exists=True):
        className = cmds.contextInfo(ctx, c=True)
    return className

def joinTypeMaterials(meshShape, typeNode, shaderType):
    transformList = cmds.listRelatives(meshShape, parent=True, fullPath=True)

    cmds.setAttr( meshShape+'.displayColors', 0 )

    shader = cmds.shadingNode(shaderType, asShader=True, n="typeShader#", skipSelect=True)
    defaultColour = [(1, 1, 1)]
    try:
        cmds.setAttr( shader+'.color', defaultColour[0][0], defaultColour[0][1], defaultColour[0][2], type="double3" )
    except:
        pass

    shadingGroup = cmds.sets(n=shader+'SG', renderable=True,noSurfaceShader=True,empty=True)
    cmds.connectAttr('%s.outColor' %shader ,'%s.surfaceShader' %shadingGroup)

    #assign the shader
    cmds.select(transformList[0])
    cmds.hyperShade( assign=shader )
    cmds.select(typeNode)

#assign materials to the type tool
def splitTypeMaterials (extrudeNode, meshShape, typeNode, shaderType):

    shadingGroups = getShadingGroupsFromObject(meshShape)
    cmds.setAttr( meshShape+'.displayColors', 0 )
    for shaders in shadingGroups:
        cmds.sets(meshShape, rm=shaders )

    capGroupId = cmds.listConnections(extrudeNode+'.capGroupId')
    bevelGroupId = cmds.listConnections(extrudeNode+'.bevelGroupId')
    extrudeGroupId = cmds.listConnections(extrudeNode+'.extrudeGroupId')

    if (capGroupId is None) or (len(capGroupId) == 0):
        groupIdCaps = cmds.createNode( 'groupId', skipSelect=True )
        cmds.connectAttr( groupIdCaps+'.groupId', extrudeNode+'.capGroupId' )
        capGroupId = cmds.listConnections(extrudeNode+'.capGroupId')

    if (bevelGroupId is None) or (len(bevelGroupId) == 0):
        groupIdBevels = cmds.createNode( 'groupId', skipSelect=True )
        cmds.connectAttr( groupIdBevels+'.groupId', extrudeNode+'.bevelGroupId' )
        bevelGroupId = cmds.listConnections(extrudeNode+'.bevelGroupId')

    if (extrudeGroupId is None) or (len(extrudeGroupId) == 0):
        groupIdExtrusion = cmds.createNode( 'groupId', skipSelect=True )
        cmds.connectAttr( groupIdExtrusion+'.groupId', extrudeNode+'.extrudeGroupId' )
        extrudeGroupId = cmds.listConnections(extrudeNode+'.extrudeGroupId')

    groupIds = [capGroupId[0], bevelGroupId[0], extrudeGroupId[0]]

    shaderNames = ["typeCapsShader", "typeBevelShader", "typeExtrusionShader"]
    shaderColours = [(0.627451, 0.627451, 0.627451), (1.0, 0.4019, 0.1274), (0.129412, 0.65098, 1)]

    s = 0
    for ids in groupIds:

        shader = cmds.shadingNode(shaderType, asShader=True, n=shaderNames[s]+'#', skipSelect=True)
        try:
            cmds.setAttr( shader+'.color', shaderColours[s][0], shaderColours[s][1], shaderColours[s][2], type="double3" )
        except:
            try:
                #rampShader
                cmds.setAttr( shader+'.color[0].color_Color', shaderColours[s][0], shaderColours[s][1], shaderColours[s][2], type="double3" )
            except:
                pass

        shadingGroup = cmds.sets(n=shaderNames[s]+'SG#', renderable=True,noSurfaceShader=True,empty=True)
        cmds.connectAttr('%s.outColor' %shader ,'%s.surfaceShader' %shadingGroup)
        try:
            cmds.assignShaderToType(gr=ids, sg=shadingGroup, me=meshShape)
        except:
            cmds.warning ("Material assignment failure.")
        s +=1

#get the shaders attached to an object
def getShadingGroupsFromObject (mesh):
    materials = []
    future = cmds.listHistory(str(mesh), f=1, pdo=1)

    if future is None:
        return None

    # Search for the connecting shading group
    for n in future:
        if cmds.attributeQuery("surfaceShader",node=n, exists=True):
            materials.append(n)

    return materials

#given the group nodes, get the associated materials
def getVectorShadingGroups (mesh, extrudeNode):
    capGroupId = cmds.listConnections(extrudeNode+'.capGroupId')
    bevelGroupId = cmds.listConnections(extrudeNode+'.bevelGroupId')
    extrudeGroupId = cmds.listConnections(extrudeNode+'.extrudeGroupId')

    capGrpMessageConections = cmds.listConnections(capGroupId[0]+'.message')
    bevelGrpMessageConections = cmds.listConnections(bevelGroupId[0]+'.message')
    extrudeGrpMessageConections = cmds.listConnections(extrudeGroupId[0]+'.message')

    if (capGrpMessageConections is not None and 
        bevelGrpMessageConections is not None and 
        extrudeGrpMessageConections is not None):

        capMaterialAtr = getShaderFromArray(capGrpMessageConections)
        bevelMaterialAtr = getShaderFromArray(bevelGrpMessageConections)
        extrudeMaterialAtr = getShaderFromArray(extrudeGrpMessageConections)

        return [capMaterialAtr, bevelMaterialAtr, extrudeMaterialAtr]
    else:
        return []

#given a list of nodes, find the shading engine, and it's material
def getShaderFromArray(GrpMessageConections):
    for node in GrpMessageConections:
        if cmds.nodeType(node) == "shadingEngine":
            return node+'.surfaceShader'

#get the shader attribute attached to an object
#this and the next function are VERY similar, but they go about their task in different ways - which only work in different situations.
def getShaderFromObject (mesh):
    #use a set, because we'll get each material returned a couple of times
    materials = set()
    shapes = cmds.listRelatives (str(mesh), fullPath=True, shapes=True)
    if shapes is None:
        return []
    future = cmds.listConnections(shapes[0], type="shadingEngine")
    if future is None:
        return []

    # Search for the connecting shading group
    for n in future:
        if cmds.attributeQuery("surfaceShader",node=n, exists=True):
            materials.add ("%s.surfaceShader" % (str(n)))

    #we're expecting a list back, so lets not confuse things.
    returnList = list(materials)
    return returnList

def HexToByte(hexStr ):
    """
    Convert a string hex byte values into a byte string. The Hex Byte values may
    or may not be space separated.
    """
    # The list comprehension implementation is fractionally slower in this case
    #
    #    hexStr = ''.join( hexStr.split(" ") )
    #    return ''.join( ["%c" % chr( int ( hexStr[i:i+2],16 ) ) \
    #                                   for i in range(0, len( hexStr ), 2) ] )

    bytes = []

    hexStr = ''.join( hexStr.split(" ") )

    for i in range(0, len(hexStr), 2):
        bytes.append( "0x"+chr( int (hexStr[i:i+2], 16 ) ) )

    return ''.join( bytes )

def HexToUni(hexStr ):
    bytes = []

    hexStr = hexStr.split(" ")

    for hexChar in hexStr:
        ordNum = int(hexChar,16)
        bytes.append(unichr(ordNum))

    return ''.join( bytes )

def EscapedToUni(str):
    i = 0
    bytes = []
    strLen = len(str)
    while i < strLen:
        ch = str[i]
        if ch != '\\':
            bytes.append(ch)
        elif i+1 < strLen:
            i += 1
            ch = str[i]
            if ch == '\\': # \\
                bytes.append(ch)
            elif ch == 'u': # \u
                if i+4 < strLen:
                    ordNum = int(str[i+1:i+5], 16)
                    bytes.append(unichr(ordNum))
                    i += 4
            elif ch == 'U': # \U
                if i+8 < strLen:
                    ordNum = int(str[i+1:i+9], 16)
                    bytes.append(unichr(ordNum))
                    i += 8
        i += 1
    return ''.join(bytes)

def UniToEscaped(str):
    hex = []
    for ch in str:
        if ord(ch) > 65535:
            hex.append("\\U%08X" % ord(ch))
        elif ord(ch) > 255:
            hex.append("\\u%04X" % ord(ch))
        elif ch == '\\':
            hex.append("\\\\")
        else:
            hex.append(ch)
    return ''.join(hex)

def ByteToHex( byteStr ):
    """
    Convert a byte string to it's hex string representation e.g. for output.
    """

    # Uses list comprehension which is a fractionally faster implementation than
    # the alternative, more readable, implementation below
    #
    #    hex = []
    #    for aChar in byteStr:
    #        hex.append( "%02X " % ord( aChar ) )
    #
    #    return ''.join( hex ).strip()

    return ''.join( [ "%02X " % ord( x ) for x in byteStr ] ).strip()
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
