from maya.app.flux.ae.Template import Template
from maya.app.flux.ae.Custom import Custom
import maya.app.flux.ae.ui as faeui
from maya.app.flux.imports import *
import maya.app.flux.core as fx
from maya.app.flux.core import pix

import os
import maya
import time
import ntpath

try:
    maya.utils.loadStringResourcesForModule(__name__)
except:
    pass
import maya.app.type.plugin as typePlugin

class MyEventFilterer(qt.QObject):
    def eventFilter(self, widget, event):
        if event.type() == qt.QEvent.Type.MouseButtonPress:
            cmds.undoInfo(openChunk=True, chunkName="SVG Adjust")
        elif event.type() == qt.QEvent.Type.MouseButtonRelease:
            cmds.undoInfo(closeChunk=True)
            #return True
        return False

class AEsvgToPolyTemplate(Template):
    def buildUI(self, nodeName):
        self.addCustom(MyCustom(nodeName))

class MyCustom(Custom):
    def buildUI(self, nodeName):
        self.registerExternalNode('extrudeNode', self.getExtrudeNode)
        self.registerExternalNode('remeshNode', self.getRemeshNode)
        self.registerExternalNode('animationNode', self.getAnimationNode)
        self.registerExternalNode('adjustNode', self.getAdjustNode)

        self.eventFilterer = MyEventFilterer()
        self.eventFilterer.parent = self

        self.modernExtrude = False
        if cmds.nodeType(self.getExtrudeNode()) != "vectorExtrude":
            self.modernExtrude = True

        self.supportedDefaultShaders = ['blinn', 'lambert', 'phong', 'phongE', 'rampShader']

        self.lockUpdates = False
        self.preventSecondaryUpdate = False
        self.bevelIgnore = []

        self.createCustomWidgets()
        self.updateMaterialSplitBtn()

        with self.horizontalLayout(ref='svgLabel'):
            self.addStretch()
            self.svgLabel = qt.QLabel()
            self.svgLabel.setFixedHeight(pix(150))

            self.warningLabel = qt.QLabel('', parent=self.svgLabel)
            self.warningLabel.setFixedHeight(pix(20))
            icon = '''<svg height="32px" viewBox="0 0 32 32" width="32px"><path d="M14.4242327,6.14839275 C15.2942987,4.74072976 16.707028,4.74408442 17.5750205,6.14839275 L28.3601099,23.59738 C29.5216388,25.4765951 28.6755462,27 26.4714068,27 L5.5278464,27 C3.32321557,27 2.47386317,25.4826642 3.63914331,23.59738 Z M16,20 C16.5522847,20 17,19.5469637 17,19.0029699 L17,12.9970301 C17,12.4463856 16.5561352,12 16,12 C15.4477153,12 15,12.4530363 15,12.9970301 L15,19.0029699 C15,19.5536144 15.4438648,20 16,20 Z M16,24 C16.5522848,24 17,23.5522848 17,23 C17,22.4477152 16.5522848,22 16,22 C15.4477152,22 15,22.4477152 15,23 C15,23.5522848 15.4477152,24 16,24 Z M16,24" fill="#FF0000"/></svg>'''

            renderer = qt.QSvgRenderer(qt.QByteArray(icon));
            pm = qt.QPixmap(fx.dpi(20), fx.dpi(20));
            pm.fill(qt.Qt.transparent);
            painter = qt.QPainter(pm)
            renderer.render(painter)
            painter.end()
            pm.setDevicePixelRatio(fx.dpi())
            pm = fx.scalePixmap(pm, 20, 20)
            self.warningLabel.setPixmap(pm)
            self.warningLabel.move(pix(0), pix(130))

            self.addWidget(self.svgLabel)
            self.addStretch()

        self.addSpacing(pix(10))

        with self.horizontalLayout():
            with self.verticalLayout():
                self.currentLayout().setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Fixed, qt.QSizePolicy.Fixed))
                with self.horizontalLayout():
                    self.addWidget(self.pasteRadioBtn)
                    self.addWidget(self.pasteBtn)
                    self.addStretch()
            
                with self.horizontalLayout():
                    self.addWidget(self.pathRadioBtn)
                    self.addWidget(self.pathBtn)
                    self.addStretch()

            self.addSpacing(5)

            with self.verticalLayout():
                self.pasteLabel = qt.QLabel(self.strRes('kSVGPleaseLbl'))
                self.pasteLabel.setContentsMargins(pix(2),0,0,0)
                self.pasteLabel.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Fixed))
                self.pasteLabel.setFixedHeight(pix(20))
                self.addWidget(self.pasteLabel)

                self.pathField = qt.QLineEdit()
                self.pathField.setFixedHeight(pix(20))
                self.pathField.setTextMargins(pix(20), 0,0,0)
                self.pathField.editingFinished.connect(self.pathEdited)
                self.refreshBtn = fx.ImageButton('SVGRefresh', parent=self.pathField)
                self.refreshBtn.move(pix(4), pix(2))
                self.refreshBtn.setFixedWidth(pix(16))
                self.refreshBtn.setFixedHeight(pix(16))
                pixmap = fx.getPixmap('SVGRefresh')
                self.refreshBtn.setImage(fx.scalePixmap(pixmap, 16, 16))
                self.refreshBtn.setToolTip(self.strRes('kSVGRefreshFileLbl'))
                self.refreshBtn.clicked.connect(self.refreshClicked)
                #self.addWidget(self.refreshBtn)
                self.addWidget(self.pathField)            

        self.addSpacing(pix(20))
        
        with self.tabLayout():

            with self.newTab('kSVGSVGLbl'):
                self.useArtBoard = self.addCheckbox('useArtboard', label='kUseViewBox', ann=self.strRes('kUseViewBoxAnn'))
                self.addSlider('svgSize', label='kSVGSizeLbl')
                self.addCheckbox('legacy2018', label='kSVGShowHiddenPathsLbl')

                with self.frameLayout('kSVGManipulationsLbl', True):
                    self.onLayoutVisibilityChange(self.manipVisibilityChanged)
                    with self.horizontalLayout():
                        self.pathListLabel = qt.QLabel(self.strRes('kSVGPathNameLbl'))
                        self.pathListLabel.setToolTip(fx.res('kSelectSVG'))
                        self.pathListLabel.setFixedWidth(pix(146))
                        self.pathListLabel.setAlignment(qt.Qt.AlignRight | qt.Qt.AlignVCenter)
                        self.addWidget(self.pathListLabel)
                        self.pathList = qt.QListWidget()
                        self.pathList.setToolTip(fx.res('kSelectSVG'))
                        self.pathList.setFixedHeight(pix(100))
                        self.pathList.setSelectionMode(qt.QAbstractItemView.ExtendedSelection)
                        self.pathList.itemSelectionChanged.connect(self.pathNamesChanged)
                        self.addWidget(self.pathList)

                    self.svgOffsetWindowZSlider = self.instanceKey + '_' + 'svgOffsetWindowZSlider'

                    cmds.floatSliderGrp(self.svgOffsetWindowZSlider, label=self.strRes('kSVGOffsetZLbl'), 
                        field=True, minValue=-10.0, maxValue=10.0, fieldMinValue=-100000.0, 
                        fieldMaxValue=100000.0, value=0, dragCommand=self.setVectorOffset)

                    self.offsetFieldChangedStatus = False

                    w = fx.getMayaWidget(self.svgOffsetWindowZSlider + '|slider')
                    w.installEventFilter(self.eventFilterer)
                    w = fx.getMayaWidget(self.svgOffsetWindowZSlider + '|field')
                    w.textEdited.connect(self.offsetFieldChanged)
                    w.editingFinished.connect(self.offsetFieldEditingFinished)

                    self.svgOffsetWindowExtrudeSlider = self.instanceKey + '_' + 'svgOffsetWindowExtrudeSlider'

                    cmds.floatSliderGrp(self.svgOffsetWindowExtrudeSlider, label=self.strRes('kSVGScaleZLbl'), 
                        field=True, minValue=-10.0, maxValue=10.0, fieldMinValue=-100000.0, 
                        fieldMaxValue=100000.0, value=0, dragCommand=self.setVectorOffset)

                    w = fx.getMayaWidget(self.svgOffsetWindowExtrudeSlider + '|slider')
                    w.installEventFilter(self.eventFilterer)
                    w = fx.getMayaWidget(self.svgOffsetWindowExtrudeSlider + '|field')
                    w.textEdited.connect(self.offsetFieldChanged)
                    w.editingFinished.connect(self.offsetFieldEditingFinished)

                    with self.indentLayout(''):
                        self.clearManipulationsBtn = qt.QPushButton(self.strRes('kSVGClearManipulationsLbl'))
                        self.clearManipulationsBtn.setToolTip(self.strRes('kSVGClearManipulationsTooltipLbl'))
                        self.clearManipulationsBtn.clicked.connect(self.clearManipClicked)
                        self.addSpacing(pix(2))
                        self.addWidget(self.clearManipulationsBtn)

                    self.addSlider('zOffset', label='kSVGGlobalZOffsetLbl')
            with self.newTab('kSVGGeometryLbl'):
                with self.frameLayout('kSVGMeshSettingsLbl', True):
                    self.addSlider('curveResolution', label= 'kSVGCurveResolutionLbl')
                    self.addCheckbox('removeColinear', label= 'kSVGFilterCollinearLbl' )
                    self.addSlider('colinearAngle', label= 'kSVGCollinearAngleLbl')
                    self.addCheckbox('enableDistanceFilter', label= 'kSVGFilterByDistanceLbl')
                    self.addSlider('pointDistanceFilter', label= 'kSVGDistanceLbl')
                    self.addCheckbox('deleteCaps', label= 'kSVGDeleteCapsLbl', node='extrudeNode')
                    self.addCheckbox('displayVertexColours', label='kSVGOutputVertexColorsLbl')

                    with self.indentLayout(''):
                        self.addWidget(self.createCurveBtn)
                    self.addSpacing(pix(2))

                    with self.frameLayout('kSVGDeformableMeshLbl'):
                        self.addCheckbox('deformableType', label='kSVGDeformableCheckLbl')
                        self.addSlider('maxDivisions', label= 'kSVGMaxEdgeDivLbl')
                        self.addSlider('maxEdgeLength', label= 'kSVGMaxEdgeLenLbl')
                        self.addSlider('refineThreshold', label= 'kSVGMaxRefineThreshLbl', node='remeshNode')
                        self.addSlider('reduceThreshold', label= 'kSVGReduceThreshLbl', node='remeshNode')
                        self.addSlider('maxTriangleCount', label= 'kSVGMaxTriangleCountLbl', node='remeshNode') 

                with self.frameLayout('kSVGExtrusionLbl', True):
                    self.addCheckbox('enableExtrusion', label='kSVGEnableExtrusionLbl', node='extrudeNode')
                    self.createFalloffCurve('extrudeCurve')
                    self.addSlider('extrudeDistance', label= 'kSVGExtrudeDistance1Lbl', node='extrudeNode')
                    self.addSlider('extrudeOffset', label='kSVGExtrudeOffset1Lbl', node='extrudeNode')
                    self.addSlider('extrudeDivisions', label= 'kSVGExtrudeDivisions1Lbl', node='extrudeNode')

                with self.frameLayout('kSVGBevelsLbl', True, ref='bevels'):
                    with self.indentLayout(''):
                        self.enableBevel = qt.QCheckBox(self.strRes('kSVGEnableFrontBevelLbl'))
                        self.enableBevel.clicked.connect(self.enableBevelClicked)
                        self.addWidget(self.enableBevel)

                    self.addRadio('bevelStyle', label='kSVGBevelStyleLbl', labels=['kSVGOuterBevel1Lbl', 'kSVGInnerBevel1Lbl'], node='extrudeNode')

                    with self.horizontalLayout(ref='enableBackBevel'):
                        self.addCheckbox('enableBackBevel', label= 'kSVGEnableBackBevelLbl', node='extrudeNode')
                    with self.horizontalLayout(ref='rearBevelUsesFront'):
                        self.addCheckbox('rearBevelUsesFront', label= 'kSVGUseFrontBevelLbl', node='extrudeNode')

                    self.bevelChoiceGrp = qt.QButtonGroup()
                    self.frontBevelRadioBtn = qt.QRadioButton('Front Bevel')
                    self.frontBevelRadioBtn.clicked.connect(self.switchFrontBevel)
                    self.backBevelRadioBtn = qt.QRadioButton(self.strRes('kSVGBackBevelLbl'))
                    self.backBevelRadioBtn.clicked.connect(self.switchBackBevel)
                    self.bevelChoiceGrp.addButton(self.frontBevelRadioBtn,0)
                    self.bevelChoiceGrp.addButton(self.backBevelRadioBtn,1)
                    self.frontBevelRadioBtn.setChecked(True)

                    if self.modernExtrude:
                        with self.frameLayout(fx.res('kBevelProfile'), True):
                            with self.stackedLayout(ref='outerFrontBevel'):
                                with self.page():
                                    pass
                                with self.page():
                                    with self.indentLayout('', ref='showFrontBackBevelOption'):
                                        self.addWidget(self.frontBevelRadioBtn)
                                        self.addWidget(self.backBevelRadioBtn)

                            with self.stackedLayout(ref='frontBackBevel'):
                                with self.page():
                                    self.createFalloffCurve('frontBevelCurve')
                                    self.addSlider('bevelDistance', label='kSVGBevelDistanceLbl', node='extrudeNode')
                                    self.addSlider('bevelOffset', label='kSVGBevelOffsetLbl', node='extrudeNode')
                                    self.addSlider('bevelDivisions', label='kSVGBevelDivisionsLbl', node='extrudeNode')
                                with self.page():
                                    self.createFalloffCurve('backBevelCurve')
                                    self.addSlider('backBevelDistance', label= 'kSVGBevelDistanceLbl', node='extrudeNode')
                                    self.addSlider('backBevelOffset', label= 'kSVGBevelOffsetLbl', node='extrudeNode')
                                    self.addSlider('backBevelDivisions', label= 'kSVGBevelDivisionsLbl', node='extrudeNode')
                    else:
                        # Legacy layout
                        with self.frameLayout('kSVGOuterBevel1Lbl', True, ref='outerBevel'):
                            self.createFalloffCurve('outerBevelCurve')
                            self.addSlider('outerBevelDistance', label= 'kSVGBevelDistanceLbl', node='extrudeNode')
                            self.addSlider('extrudeOffset', label= 'kSVGBevelOffsetLbl', node='extrudeNode')
                            self.addSlider('outerBevelDivisions', label= 'kSVGBevelDivisionsLbl', node='extrudeNode')

                        with self.frameLayout('kSVGInnerBevel1Lbl', True, ref='frontBevel'):
                            self.createFalloffCurve('frontBevelCurve')
                            self.addSlider('bevelDistance', label='kSVGBevelDistanceLbl', node='extrudeNode')
                            self.addSlider('bevelOffset', label='kSVGBevelOffsetLbl', node='extrudeNode')
                            self.addSlider('bevelDivisions', label='kSVGBevelDivisionsLbl', node='extrudeNode')

                        with self.frameLayout('kSVGBackBevelLbl', True, ref='backBevel'):
                            self.addCheckbox('enableBackBevel', label= 'kSVGEnableBackBevelLbl', node='extrudeNode')
                            self.addCheckbox('rearBevelUsesFront', label= 'kSVGUseFrontBevelLbl', node='extrudeNode')
                            self.createFalloffCurve('backBevelCurve')
                            self.addSlider('backBevelDistance', label= 'kSVGBevelDistanceLbl', node='extrudeNode')
                            self.addSlider('backBevelOffset', label= 'kSVGBevelOffsetLbl', node='extrudeNode')
                            self.addSlider('backBevelDivisions', label= 'kSVGBevelDivisionsLbl', node='extrudeNode')

            with self.newTab('kSVGTexturingLbl'):
                with self.indentLayout('kSVGDefaultShaderLbl'):
                    self.addWidget(self.shaderComboBox)
                    self.addSpacing(pix(5))
                    self.addWidget(self.materialSplitBtn)
                    self.addWidget(self.materialJoinBtn)

                a = self.addNavigation(label='kSVGCapsShaderLbl')
                b = self.addNavigation(label='kSVGBevelShaderLbl')
                c = self.addNavigation(label='kSVGExtrudeShaderLbl')
                self.setupNavigationControls([a,b,c])

            with self.newTab('kSVGAnimationLbl'):
                self.onLayoutVisibilityChange(self.animationTabChanged)
                self.addCheckbox('enableAnimation', label='kSVGAnimLbl', node='animationNode')

                with self.verticalLayout(ref='animateLayout'):
                    self.animPosControl = self.addVector('animationPosition', label='kSVGTranslateLbl', node='animationNode')
                    self.animRotControl = self.addVector('animationRotation', label='kSVGRotateLbl', node='animationNode')
                    self.animScaleControl = self.addVector('animationScale', label='kSVGScaleLbl', node='animationNode')

                    with self.indentLayout(''):
                        self.addWidget(self.shellAnimationBtn)
                        self.addSpacing(pix(10))
                        self.addWidget(self.shellAnimOption)

                    self.addSpacing(pix(2)) 

                    with self.frameLayout('kSVGAnimationPivotsLbl', True):
                        self.addCheckbox('enablePivotDisplay', label='kSVGDisplayPivotPointsLbl', node='animationNode')
                        with self.horizontalLayout():
                            self.addSlider('xPivotLocation', label='kSVGXPivotLbl', node='animationNode')
                            self.createLocalPivotBtn('x')

                        with self.horizontalLayout():
                            self.addSlider('yPivotLocation', label='kSVGYPivotLbl', node='animationNode')
                            self.createLocalPivotBtn('y')

                        with self.horizontalLayout():
                            self.addSlider('zPivotLocation', label='kSVGZPivotLbl', node='animationNode')
                            self.createLocalPivotBtn('z')

                    with self.frameLayout('kSVGDelayLbl', True):
                        self.addCheckbox('reverseOrder', label='kSVGReverseOrderLbl', node='animationNode')
                        self.addSlider('offsetFrames', label='kSVGDelayFramesLbl', node='animationNode')
                        self.addCheckbox('randomDelay', label='kSVGRandomiseDelayLbl', node='animationNode')
                        self.addSlider('randomSeed', label='kSVGRandomSeedLbl', node='animationNode')

        self.createAttributeListener('deformableType', self.deformableTypeChanged)
        self.createAttributeListener('bevelStyle', self.bevelStyleChanged, node='extrudeNode')
        self.createAttributeListener('enableExtrusion', self.extrudeEnableChanged, node='extrudeNode')
        self.createAttributeListener('enableBackBevel', self.backBevelEnabledChanged, node='extrudeNode')
        self.createAttributeListener('rearBevelUsesFront', self.backBevelEnabledChanged, node='extrudeNode')
        self.createAttributeListener('svgFilepath', self.updateInfoLabel)
        self.createAttributeListener('svgPaste', self.updateInfoLabel)
        self.createAttributeListener('svgMode', self.svgModeChanged)
        self.createAttributeListener('manipulatorPositionsPP', self.getVectorOffsetAttributes, node='adjustNode')
        self.createAttributeListener('manipulatorScalesPP', self.getVectorOffsetAttributes, node='adjustNode')
        self.createAttributeListener('solidsPerCharacter', self.getVectorOffsetAttributes)
        self.createAttributeListener('enableAnimation', self.updateAnimateEnabled, node='animationNode')
        self.createAttributeListener('errorIndicator', self.updateErrorIndicator)
        self.createAttributeListener('selectionIndexes', self.pathSelectionChanged, node='adjustNode')
        self.updateBevelVisibility()
        self.extrudeEnableChanged()
        self.backBevelEnabledChanged()
        self.svgModeChanged()
        self.populatePaths()
        self.updateAnimateEnabled()
        self.updateErrorIndicator()
        self.pathSelectionChanged()
        self.fixAnimLegacyConnections()
        self.updateShellAnimOption()

    def isAnimConnLegacy(self):
        return cmds.isConnected(self.name + '.animationPosition', 
                        self.getAnimationNode() + '.animationPosition')

    def fixAnimLegacyConnections(self):
        kwargs = {'node': 'animationNode'}
        if self.isAnimConnLegacy():
            kwargs = {}

        self.setControlAttr(self.animPosControl, 'animationPosition', **kwargs)
        self.setControlAttr(self.animRotControl, 'animationRotation', **kwargs)
        self.setControlAttr(self.animScaleControl, 'animationScale', **kwargs)

    def animationTabChanged(self, visible):
        if visible:
            selection = cmds.ls(sl=True) or []
            selection += [self.getAnimationNode(), self.name]
            cmds.select(*selection)

    def offsetFieldChanged(self, *args):
        self.offsetFieldChangedStatus = True

    def offsetFieldEditingFinished(self, *args):
        if self.offsetFieldChangedStatus:
            self.setVectorOffset()
            self.offsetFieldChangedStatus = False

    def nodeChanged(self):
        self.editFalloffCurve('extrudeCurve')

        if self.modernExtrude:
            self.editFalloffCurve('frontBevelCurve')
        else:
            self.editFalloffCurve('frontBevelCurve')
            self.editFalloffCurve('outerBevelCurve')

        self.editFalloffCurve('backBevelCurve')
        self.updateMaterialSplitBtn()
        self.setupNavigationControls(self.navigations)

        self.updateBevelVisibility()
        self.extrudeEnableChanged()
        self.backBevelEnabledChanged()
        self.svgModeChanged()
        self.populatePaths()
        self.updateAnimateEnabled()
        self.updateErrorIndicator()
        self.pathSelectionChanged()
        self.fixAnimLegacyConnections()
        self.updateShellAnimOption()

    def updateAnimateEnabled(self):
        value = cmds.getAttr(self.getAnimationNode() + '.enableAnimation')
        self.setLayoutEnabled('animateLayout', value)

    def manipVisibilityChanged(self, visible):
        if not visible:
            self.pathList.clearSelection()

    def pathSelectionChanged(self):
        selectedPaths = cmds.getAttr(self.getAdjustNode() + '.selectionIndexes') or []
        selectedRows = [x.row() for x in self.pathList.selectionModel().selectedRows()]

        if(set(selectedPaths) == set(selectedRows)): return

        self.pathList.blockSignals(True)
        self.pathList.clearSelection()

        for i in selectedPaths:
            if i < self.pathList.count():
                self.pathList.item(i).setSelected(True)
        self.pathList.blockSignals(False)
        self.getVectorOffsetAttributes()

    def populatePaths(self):
        svgMode = cmds.getAttr(self.name + '.svgMode')
        names = []
        if svgMode == 1:
            names = cmds.getAttr(self.name + '.pathNames')
        else:
            names = cmds.getAttr(self.name + '.pathNamesFromPaste')

        self.pathList.blockSignals(True)
        self.pathList.clear()
        for i in names:
            item = qt.QListWidgetItem(i)
            self.pathList.addItem(item)
        self.pathList.blockSignals(False)

        self.pathNamesChanged()

    def updatePreviewPanel(self):
        filePath = cmds.getAttr(self.name + '.svgFilepath')
        svgPaste = cmds.getAttr(self.name + '.svgPaste')
        mode = cmds.getAttr(self.name + '.svgMode')

        data = ''
        if mode == 2:
            data = svgPaste.strip()
            data = data.replace('\n', '')
            data = data.encode('utf-8')
        else:
            try:
                with open(filePath, 'r') as f:
                    data = f.read()
            except:
                pass

        if len(data)==0:
            data = s = "<!-- Generator: Adobe Illustrator 21.0.0, SVG Export Plug-In --><svg version=\"1.1\" baseProfile=\"basic\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:a=\"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/\" x=\"0px\" y=\"0px\" width=\"38px\" height=\"24px\" viewBox=\"0 0 38 24\" enable-background=\"new 0 0 38 24\" xml:space=\"preserve\"> <defs> </defs> <polygon fill=\"#13B713\" points=\"12,5 7,5 7,0 5,0 5,5 0,5 0,7 5,7 5,12 7,12 7,7 12,7 \"/> <rect x=\"14\" y=\"1\" fill=\"#757575\" width=\"4\" height=\"2\"/> <rect x=\"21\" y=\"1\" fill=\"#757575\" width=\"4\" height=\"2\"/> <rect x=\"28\" y=\"1\" fill=\"#757575\" width=\"4\" height=\"2\"/> <rect x=\"14\" y=\"22\" fill=\"#757575\" width=\"4\" height=\"2\"/> <rect x=\"7\" y=\"22\" fill=\"#757575\" width=\"4\" height=\"2\"/> <rect x=\"21\" y=\"22\" fill=\"#757575\" width=\"4\" height=\"2\"/> <rect x=\"28\" y=\"22\" fill=\"#757575\" width=\"4\" height=\"2\"/> <polygon fill=\"#757575\" points=\"35,1 38,1 38,4 36,4 36,3 35,3 \"/> <polygon fill=\"#757575\" points=\"38,21 38,24 35,24 35,22 36,22 36,21 \"/> <polygon fill=\"#757575\" points=\"4,24 1,24 1,21 3,21 3,22 4,22 \"/> <rect x=\"36\" y=\"7\" fill=\"#757575\" width=\"2\" height=\"4\"/> <rect x=\"36\" y=\"14\" fill=\"#757575\" width=\"2\" height=\"4\"/> <rect x=\"1\" y=\"14\" fill=\"#757575\" width=\"2\" height=\"4\"/> </svg>"

        renderer = qt.QSvgRenderer(qt.QByteArray(data));
        size = renderer.viewBoxF()
        height = pix(150.0)
        width = pix(400.0)
        if size.height() > 0 and size.width() > 0:
            ratio = size.width() / size.height()
            nwidth = height * ratio
            if nwidth > width:
                height = width / ratio
            else:
                width = nwidth

        pm = qt.QPixmap(fx.dpi(width), fx.dpi(height));
        pm.fill(qt.Qt.transparent);
        painter = qt.QPainter(pm)
        renderer.render(painter)
        painter.end()
        pm.setDevicePixelRatio(fx.dpi())
        pm = fx.scalePixmap(pm, width, height)
        self.svgLabel.setPixmap(pm)

        self.svgLabel.parent().layout().activate()
        
        self.setLayoutHidden('svgLabel', False)

    def updateErrorIndicator(self):
        hasParseErrors = False
        try:
            hasParseErrors = cmds.getAttr(self.name + '.errorIndicator')
        except:
            pass

        self.warningLabel.setVisible(hasParseErrors)

    def svgModeChanged(self):
        mode = cmds.getAttr(self.name + '.svgMode')
        if mode == 2:
            self.pasteRadioBtn.setChecked(True)
            self.setControlEnabled(self.useArtBoard, False)
        else:
            self.pathRadioBtn.setChecked(True)
            self.setControlEnabled(self.useArtBoard, True)
        self.updateInfoLabel()
        self.populatePaths()


    def updateInfoLabel(self):
        filePath = cmds.getAttr(self.name + '.svgFilepath') or ''
        svgPaste = cmds.getAttr(self.name + '.svgPaste') or ''

        svgText = self.strRes('kSVGStoredLbl') if len(svgPaste) > 0 else self.strRes('kSVGPleaseLbl')
        self.pasteLabel.setText(svgText)
        self.pathField.setText(filePath)

        self.updatePreviewPanel()

    def pathNamesChanged(self, *args):
        selectedRows = [x.row() for x in self.pathList.selectionModel().selectedRows()]
        cmds.setAttr(self.getAdjustNode() + '.selectionIndexes', selectedRows, typ='Int32Array')
        self.getVectorOffsetAttributes()

    def clearManipClicked(self):
        self.clearVectorOffsetAttributes()

    @fx.undoChunk('SVG Adjust')
    def setVectorOffset(self, *args):
        self.setVectorOffsetAttributes()

    #this sets the manipulation offsets (z position and extrusion scale)
    def setVectorOffsetAttributes(self):
        selectedRows = self.pathList.selectionModel().selectedRows()
        if not selectedRows: return

        adjustNode = self.getAdjustNode()

        #get the amount of offset and scale
        zPosOffset = cmds.floatSliderGrp (self.svgOffsetWindowZSlider, q=True, v=True )
        zScaleOffset = cmds.floatSliderGrp (self.svgOffsetWindowExtrudeSlider, q=True, v=True )

        #get the array attributs
        zScaleAdjusts = cmds.getAttr('%s.manipulatorScalesPP'  %  adjustNode )
        zPositionAdjusts = cmds.getAttr('%s.manipulatorPositionsPP'  %  adjustNode )
        #get the vertsPerChar array, this tells us how many array elements we need
        vertsPerCharArray = cmds.getAttr('%s.solidsPerCharacter'  %  self.name )

        if vertsPerCharArray is None:
            vertsPerCharArray = []

        #if our array attributes have no value, create arrays for them
        if zPositionAdjusts is None:
            zPositionAdjusts = [(0.0, 0.0, 0.0)]

        if zScaleAdjusts is None:
            zScaleAdjusts = [(1.0, 1.0, 1.0)]

        #initialise them with values if need be
        if (len(zPositionAdjusts) < len(vertsPerCharArray)) or len(zPositionAdjusts) == 0:
            for i in range (len(zPositionAdjusts), len(vertsPerCharArray), 1):
                zPositionAdjusts.append((0.0, 0.0, 0.0))


        if (len(zScaleAdjusts) < len(vertsPerCharArray)) or len(zScaleAdjusts) == 0:
            for i in range (len(zScaleAdjusts), len(vertsPerCharArray), 1):
                zScaleAdjusts.append((1.0, 1.0, 1.0))

        for index in selectedRows:
            row = index.row()
            #set the correct array element to our interface settings
            zPositionAdjusts[row] = (0.0, 0.0, zPosOffset)
            zScaleAdjusts[row] = (1.0, 1.0, zScaleOffset)

        #set the attribute
        cmds.setAttr((adjustNode+'.manipulatorPositionsPP'), len(zPositionAdjusts), *zPositionAdjusts, typ="vectorArray" )
        cmds.setAttr((adjustNode+'.manipulatorScalesPP'), len(zScaleAdjusts), *zScaleAdjusts, typ="vectorArray" )

    #same as above, but this refreshes the sliders when you change selection in the AE
    def getVectorOffsetAttributes(self):
        selectedRows = self.pathList.selectionModel().selectedRows()
        if not selectedRows:
            cmds.floatSliderGrp (self.svgOffsetWindowZSlider, e=True, v=0, en=False )
            cmds.floatSliderGrp (self.svgOffsetWindowExtrudeSlider, e=True, v=1, en=False )
            return
        else:
            cmds.floatSliderGrp (self.svgOffsetWindowZSlider, e=True, en=True )
            cmds.floatSliderGrp (self.svgOffsetWindowExtrudeSlider, e=True, en=True )

        adjustNode = self.getAdjustNode()
        #get the selected shape

        zPositionAdjusts = cmds.getAttr('%s.manipulatorPositionsPP'  % adjustNode )
        zScaleAdjusts = cmds.getAttr('%s.manipulatorScalesPP'  %  adjustNode )
        vertsPerCharArray = cmds.getAttr('%s.solidsPerCharacter'  %  self.name )

        if vertsPerCharArray is None:
            vertsPerCharArray = []

        if zPositionAdjusts is None:
            zPositionAdjusts = [(0.0, 0.0, 0.0)]

        if zScaleAdjusts is None:
            zScaleAdjusts = [(1.0, 1.0, 1.0)]

        if (len(zPositionAdjusts) < len(vertsPerCharArray)) or len(zPositionAdjusts) == 0:
            for i in range (len(zPositionAdjusts), len(vertsPerCharArray), 1):
                zPositionAdjusts.append((0.0, 0.0, 0.0))

        if (len(zScaleAdjusts) < len(vertsPerCharArray)) or len(zScaleAdjusts) == 0:
            for i in range (len(zScaleAdjusts), len(vertsPerCharArray), 1):
                zScaleAdjusts.append((1.0, 1.0, 1.0))

        zSliderValue = 0
        scaleValue = 0

        for index in selectedRows:
            row = index.row()

            zSliderValue += zPositionAdjusts[row][2]
            scaleValue += zScaleAdjusts[row][2]

        zSliderValue /= len(selectedRows)
        scaleValue /= len(selectedRows)

        cmds.floatSliderGrp (self.svgOffsetWindowZSlider, e=True, v= zSliderValue )
        cmds.floatSliderGrp (self.svgOffsetWindowExtrudeSlider, e=True, v= scaleValue )

    def clearVectorOffsetAttributes(self):
        adjustNode = self.getAdjustNode()
        #get the array attributs
        zScaleAdjusts = cmds.getAttr('%s.manipulatorScalesPP'  %  adjustNode )
        zPositionAdjusts = cmds.getAttr('%s.manipulatorPositionsPP'  %  adjustNode )

        if zPositionAdjusts is None:
            zPositionAdjusts = [(0.0, 0.0, 0.0)]

        if zScaleAdjusts is None:
            zScaleAdjusts = [(0.0, 0.0, 0.0)]

        for i in range (0, len(zPositionAdjusts), 1):
            zPositionAdjusts[i] = (0.0, 0.0, 0.0)

        for i in range (0, len(zScaleAdjusts), 1):
            zScaleAdjusts[i] = (1.0, 1.0, 1.0)


        cmds.setAttr((adjustNode+'.manipulatorPositionsPP'), len(zPositionAdjusts), *zPositionAdjusts, type="vectorArray" )
        cmds.setAttr((adjustNode+'.manipulatorScalesPP'), len(zScaleAdjusts), *zScaleAdjusts, type="vectorArray" )

        cmds.floatSliderGrp (self.svgOffsetWindowZSlider, e=True, v= 0.0 )
        cmds.floatSliderGrp (self.svgOffsetWindowExtrudeSlider, e=True, v= 1.0 )

    def svg_catchPaste(self):
        import xml.parsers.expat
        #get the clipboard text using PySide
        cb = qt.QApplication.clipboard()
        svgString = cb.text().replace('\x00', '') #remove possible null byte at the end
        if (len(svgString) == 0):
            cmds.error (fx.res('kSVGClipboardError'))

        #we need to check this is a valid XML file, so we try to parse it with Python
        #if we sucseed, then we can proceed, otherwise, let the user know.
        list = []

        parser = xml.parsers.expat.ParserCreate()
        parser.StartElementHandler = lambda name, attrs: list.append(name)
        parser.CharacterDataHandler = lambda data: list.append(data)

        try:
            parser.Parse(svgString)
            return svgString
        except Exception, e:
            cmds.error(fx.res('kNoValidSVG'))
            print str(e)
            return ""

    def pasteRadioClicked(self):
        cmds.setAttr(self.name + '.svgMode', 2)

    def pathRadioClicked(self):
        cmds.setAttr(self.name + '.svgMode', 1)

    def pasteClicked(self):
        try:
            data = self.svg_catchPaste()
            cmds.setAttr(self.name + '.svgPaste', data, typ='string')
            cmds.setAttr(self.name + '.svgMode', 2)
            self.updatePreviewPanel()
            self.clearManipClicked()
        except Exception, e:
            nom.MGlobal.displayInfo(str(e))
            

    def pathClicked(self):
        saveLocation = cmds.fileDialog2(fm=1, fileFilter="*.svg")

        if saveLocation and len(saveLocation[0]) > 0:
            fileName = saveLocation[0]
            fileName = fileName and os.path.normpath(fileName) #hoping this fixes the file path on PCs

            cmds.setAttr(self.name + '.svgFilepath', fileName, typ='string')
            cmds.setAttr(self.name + '.svgMode', 1)
            self.updatePreviewPanel()
            self.clearManipClicked()

    def pathEdited(self):
        if self.pathField.isModified():
            self.pathField.setModified(False)
            cmds.setAttr(self.name + '.svgFilepath', self.pathField.text(), typ='string')
            cmds.setAttr(self.name + '.svgMode', 1)
            self.updatePreviewPanel()
            self.clearManipClicked()

    def refreshClicked(self):
        fileName = cmds.getAttr(self.name + '.svgFilepath')
        cmds.setAttr(self.name + '.svgFilepath', fileName, typ='string')
        cmds.setAttr(self.name + '.svgMode', 1)

    def backBevelEnabledChanged(self):
        a = cmds.getAttr(self.getExtrudeNode() + '.enableBackBevel')
        b = not cmds.getAttr(self.getExtrudeNode() + '.rearBevelUsesFront')
        hidden = not (a and b)

        self.setLayoutHidden('showFrontBackBevelOption', hidden)
        if hidden:
            self.frontBevelRadioBtn.setChecked(True)
            self.switchFrontBevel()

        self.setLayoutHidden('rearBevelUsesFront', not a)

    def enableBevelClicked(self):
        if not self.isBevelEnabled():
            self.enableBevelStyle()
        else:
            self.disableAllBevels()

    def disableAllBevels(self):
        a = cmds.getAttr(self.getExtrudeNode() + '.enableFrontBevel')
        b = cmds.getAttr(self.getExtrudeNode() + '.enableBackBevel')
        c = cmds.getAttr(self.getExtrudeNode() + '.enableOuterBevel')
        if a == 1:
            cmds.setAttr(self.getExtrudeNode() + '.enableFrontBevel', 0)
        if b == 1:
            cmds.setAttr(self.getExtrudeNode() + '.enableBackBevel', 0)
        if c == 1:
            cmds.setAttr(self.getExtrudeNode() + '.enableOuterBevel', 0)

    def enableBevelStyle(self):
        style = cmds.getAttr(self.getExtrudeNode() + '.bevelStyle')
        if style == 2:
            cmds.setAttr(self.getExtrudeNode() + '.enableOuterBevel', 0)
            cmds.setAttr(self.getExtrudeNode() + '.enableFrontBevel', 1)
        else:
            cmds.setAttr(self.getExtrudeNode() + '.enableFrontBevel', 0)
            cmds.setAttr(self.getExtrudeNode() + '.enableBackBevel', 0)
            cmds.setAttr(self.getExtrudeNode() + '.enableOuterBevel', 1)

    def extrudeEnableChanged(self):
        enabled = cmds.getAttr(self.getExtrudeNode() + '.enableExtrusion')
        self.setLayoutEnabled('bevels', enabled)

    def switchFrontBevel(self):
        self.setIndex('frontBackBevel', 0)

    def switchBackBevel(self):
        self.setIndex('frontBackBevel', 1)

    def isBevelEnabled(self):
        a = cmds.getAttr(self.getExtrudeNode() + '.enableOuterBevel')
        b = cmds.getAttr(self.getExtrudeNode() + '.enableFrontBevel')
        return (a or b)

    def bevelStyleChanged(self):
        self.updateBevelVisibility()
        self.enableDisableBevels()
        

    def updateBevelVisibility(self):
        value = cmds.getAttr(self.getExtrudeNode() + '.bevelStyle')

        if self.modernExtrude:
            if value == 1:
                self.setIndex('outerFrontBevel', 0)
                self.setIndex('frontBackBevel', 0)
            else:
                self.setIndex('outerFrontBevel', 1)
                self.setIndex('frontBackBevel', self.bevelChoiceGrp.checkedId())

            self.setLayoutHidden('enableBackBevel', value == 1)
            
            if self.isBevelEnabled():
                self.enableBevel.setChecked(True)
            else:
                self.enableBevel.setChecked(False)
        else:
            self.setLayoutHidden('outerBevel', value==0)
            self.setLayoutHidden('frontBevel', value==1)
            self.setLayoutHidden('backBevel', value==1)

    def enableDisableBevels(self):
        if self.isBevelEnabled():
            self.enableBevelStyle()
        else:
            self.disableAllBevels()
                        

    def setupNavigationControls(self, navigations):
        self.navigations = navigations
        transformNode = cmds.listConnections( self.name+'.transformMessage', d=True, s=True)[0]
        shadingAttributes = getShaderFromObject(transformNode)
        materialNumber = len(shadingAttributes)

        if materialNumber == 3:
            shaderList = getVectorShadingGroups (self.name, self.getExtrudeNode())
            
            if len(shaderList) == 0:
                
                for i in xrange (3):
                    self.setControlEnabled(self.navigations[i], False)
                    cmds.attrNavigationControlGrp(self.navigations[i], e=True, attribute=shadingAttributes[i])
            else:
                for i in xrange (3):
                    self.setControlEnabled(self.navigations[i], True)
                    cmds.attrNavigationControlGrp(self.navigations[i], e=True, attribute=shaderList[i])

        elif materialNumber == 2:
            for i in xrange (3):
                self.setControlLabel(self.navigations[i], self.strRes('kSVGShaderLbl'))
            cmds.attrNavigationControlGrp(self.navigations[0], e=True, attribute=shadingAttributes[0])
            cmds.attrNavigationControlGrp(self.navigations[1], e=True, attribute=shadingAttributes[1])
        else:
            self.setControlLabel(self.navigations[0], self.strRes('kSVGShaderLbl'))
            self.setControlEnabled(self.navigations[1], False)
            self.setControlEnabled(self.navigations[2], False)     
            cmds.attrNavigationControlGrp(self.navigations[0], e=True, attribute=shadingAttributes[0])

        self.updateMaterialSplitBtn()

    def getShader(self, index):
        shaderList = getVectorShadingGroups (self.name, self.getExtrudeNode())
        return shaderList[index].split('.')[0]

    def deformableTypeChanged(self):
        value = cmds.getAttr(self.name + '.deformableType')
        cmds.setAttr(self.getRemeshNode() + '.nodeState', not value)

    def createCustomWidgets(self):
        self.svgInputModeGrp = qt.QButtonGroup()

        self.pasteRadioBtn = qt.QRadioButton()
        self.pasteRadioBtn.clicked.connect(self.pasteRadioClicked)

        self.pathRadioBtn = qt.QRadioButton()
        self.pathRadioBtn.clicked.connect(self.pathRadioClicked)

        self.svgInputModeGrp.addButton(self.pasteRadioBtn,0)
        self.svgInputModeGrp.addButton(self.pathRadioBtn,1)

        self.pasteRadioBtn.setChecked(True)

        self.pasteBtn = fx.ImageButton('SVGPaste', self.strRes('kSVGPasteLbl'), textPos='right')
        self.pasteBtn.setToolTip(self.strRes('kSVGPasteSVGLbl'))
        self.pasteBtn.clicked.connect(self.pasteClicked)

        self.pathBtn = fx.ImageButton('fileOpen', self.strRes('kSVGImportLbl'), textPos='right')
        self.pathBtn.setToolTip(self.strRes('kSVGImportSVGLbl'))
        self.pathBtn.clicked.connect(self.pathClicked)

        self.shellAnimationBtn = faeui.IconButton(self.strRes('kSVGSetKeysLbl'), 'setKeyframe')
        self.shellAnimationBtn.setToolTip(self.strRes('kSVGSetKeysToolTipLbl')) 
        self.shellAnimationBtn.clicked.connect(self.shellAnimationClicked)

        self.shellAnimOption = qt.QCheckBox(self.strRes('kAutoUpdateOnSetKey'))
        self.shellAnimOption.stateChanged.connect(self.shellAnimOptionChanged)

        self.shaderComboBox = qt.QComboBox()
        for shader in self.supportedDefaultShaders:
            self.shaderComboBox.addItem(shader)

        self.materialSplitBtn = fx.ImageButton('TypeSeparateMaterials')
        self.materialSplitBtn.setToolTip(self.strRes('kSVGAssignSeparateShadersLbl'))
        self.materialSplitBtn.clicked.connect(self.materialSplitClicked)

        self.materialJoinBtn = fx.ImageButton('TypeDefaultMaterial')
        self.materialJoinBtn.setToolTip(self.strRes('kSVGCreateSingleShaderLbl'))
        self.materialJoinBtn.clicked.connect(self.materialJoinClicked)

        self.createCurveBtn = faeui.IconButton(self.strRes('kSVGCreateCurvesLbl'), 'curveEP')
        self.createCurveBtn.setToolTip(self.strRes('kSVGConvertSilhouetteLbl'))
        self.createCurveBtn.clicked.connect(self.createCurveClicked)

    def updateShellAnimOption(self):
        checked = typePlugin.getAnimCallbackOption()
        self.shellAnimOption.blockSignals(True)
        self.shellAnimOption.setChecked(checked)
        self.shellAnimOption.blockSignals(False)

    def shellAnimOptionChanged(self, index):
        checked = self.shellAnimOption.isChecked()
        typePlugins.setAnimCallbackOption(checked)

    def shellAnimationClicked(self):
        node = self.getAnimationNode()
        if self.isAnimConnLegacy():
            node = self.name
        cmds.setKeyframe(node, at='animationPosition')
        cmds.setKeyframe(node, at='animationRotation')
        cmds.setKeyframe(node, at='animationScale')
        # set the animation attributes as dirty to force evaluation
        cmds.dgdirty('%s.animationPosition' % node)

    def alignClicked(self, index):
        cmds.setAttr(self.name + '.alignmentMode', index+1)

    def alignChanged(self, *args):
        self.alignRadio.setIndex(cmds.getAttr(self.name + '.alignmentMode') - 1)

    def createLocalPivotBtn(self, axis):
        btn = fx.ImageButton('TypePivot')
        btn.setFixedWidth(pix(17))
        btn.clicked.connect(lambda axis=axis: self.pivotLocationClicked(axis))   
        self.addWidget(btn)

    def showLocalPivotMenu(self, axis, rpChecked, spChecked):
        treeMenu = qt.QMenu()
        a = treeMenu.addAction(self.strRes('kSVGLocalRotationPivotLbl'), lambda cmd=axis+'RP': self.pivotLocationMenuClicked(cmd))
        b = treeMenu.addAction(self.strRes('kSVGLocalScalePivotLbl'), lambda cmd=axis+'SP': self.pivotLocationMenuClicked(cmd))
        a.setCheckable(True)
        b.setCheckable(True)

        a.setChecked(rpChecked)
        b.setChecked(spChecked)
        treeMenu.exec_(qt.QCursor.pos())

    def createFalloffCurve(self, attr):
        with self.horizontalLayout(height=pix(185)):
            mel.eval('createTypeFalloffCurve("%s")' % (self.getExtrudeNode() + '.' + attr))

    def editFalloffCurve(self, attr):
        mel.eval('editTypeFalloffCurve("%s")' % (self.getExtrudeNode() + '.' + attr))

    def materialSplitClicked(self):
        transformNode = cmds.listConnections(self.name + '.transformMessage', d=True, s=True)[0]
        meshShape = cmds.listRelatives(transformNode, s=True, c=True)[0]

        cmds.undoInfo(openChunk=True)
        splitTypeMaterials(self.getExtrudeNode(), meshShape, self.name, self.shaderComboBox.currentText())
        cmds.undoInfo(closeChunk=True)

        self.setupNavigationControls(self.navigations)

    def materialJoinClicked(self):
        transformNode = cmds.listConnections(self.name + '.transformMessage', d=True, s=True)[0]
        meshShape = cmds.listRelatives(transformNode, s=True, c=True)[0]

        cmds.undoInfo (openChunk=True)
        joinTypeMaterials(meshShape, self.name, self.shaderComboBox.currentText())
        cmds.undoInfo (closeChunk=True)

        self.setupNavigationControls(self.navigations)

    def updateMaterialSplitBtn(self):
        transformNode = cmds.listConnections(self.name + '.transformMessage', d=True, s=True)[0]
        shadingAttributes = getShaderFromObject(transformNode)
        materialNumber = len(shadingAttributes)

        if (materialNumber > 1):
            self.materialSplitBtn.setEnabled(False)
        else:
            self.materialSplitBtn.setEnabled(True)

    def createCurveClicked(self):
        maya.mel.eval("convertTypeCapsToCurves;")

    def pivotLocationClicked(self, axis):
        rp = cmds.getAttr(self.getAnimationNode() + '.local%sRotationPivot' % axis.upper())
        sp = cmds.getAttr(self.getAnimationNode() + '.local%sScalePivot' % axis.upper())
        self.showLocalPivotMenu(axis, rp, sp)

    def pivotLocationMenuClicked(self, cmd):
        axis = cmd[0]
        pivot = 'RotationPivot' if cmd[1:]=='RP' else 'ScalePivot'
        attr = self.getAnimationNode() + '.local' + axis.upper() + pivot
        value = cmds.getAttr(attr)
        cmds.setAttr(attr, not value)

    # Utilities
    def getExtrudeNode(self):
        if 'extrude' not in self.cachedNodes:
            self.cachedNodes['extrude'] = cmds.listConnections(self.name + '.extrudeMessage', d=True, s=True)[0]
        return self.cachedNodes['extrude']

    def getRemeshNode(self):
        if 'remesh' not in self.cachedNodes:
            self.cachedNodes['remesh'] =  cmds.listConnections(self.name + '.remeshMessage', d=True, s=True)[0]
        return self.cachedNodes['remesh']

    def getAnimationNode(self):
        if 'animation' not in self.cachedNodes:
            self.cachedNodes['animation'] = cmds.listConnections(self.name + '.animationMessage', d=True, s=True)[0]
        return self.cachedNodes['animation']

    def getAdjustNode(self):
        if 'adjust' not in self.cachedNodes:
            self.cachedNodes['adjust'] = cmds.listConnections(self.name + '.adjustMessage', d=True, s=True)[0]

        return self.cachedNodes['adjust']

    def strRes(self, name):
        return self.stringResourceFunction(name)

    def stringResourceFunction(self, name):
        result = name
        try:
            result = mel.eval('getPluginResource("Type", "%s")' % name)
        except:
            pass
        return result

def joinTypeMaterials(meshShape, typeNode, shaderType):
    transformList = cmds.listRelatives(meshShape, parent=True, fullPath=True)

    cmds.setAttr( meshShape+'.displayColors', 0 )

    shader = cmds.shadingNode(shaderType, asShader=True, n="typeShader#", skipSelect=True)
    defaultColour = [(1, 1, 1)]
    try:
        cmds.setAttr( shader+'.color', defaultColour[0][0], defaultColour[0][1], defaultColour[0][2], type="double3" )
    except:
        pass

    shadingGroup = cmds.sets(n=shader+'SG', renderable=True,noSurfaceShader=True,empty=True)
    cmds.connectAttr('%s.outColor' %shader ,'%s.surfaceShader' %shadingGroup)

    #assign the shader
    cmds.select(transformList[0])
    cmds.hyperShade( assign=shader )
    cmds.select(typeNode)

#assign materials to the type tool
def splitTypeMaterials (extrudeNode, meshShape, typeNode, shaderType):
    shadingGroups = getShadingGroupsFromObject(meshShape)
    cmds.setAttr( meshShape+'.displayColors', 0 )
    for shaders in shadingGroups:
        cmds.sets(meshShape, rm=shaders )

    capGroupId = cmds.listConnections(extrudeNode+'.capGroupId')
    bevelGroupId = cmds.listConnections(extrudeNode+'.bevelGroupId')
    extrudeGroupId = cmds.listConnections(extrudeNode+'.extrudeGroupId')

    if (capGroupId is None) or (len(capGroupId) == 0):
        groupIdCaps = cmds.createNode( 'groupId', skipSelect=True )
        cmds.connectAttr( groupIdCaps+'.groupId', extrudeNode+'.capGroupId' )
        capGroupId = cmds.listConnections(extrudeNode+'.capGroupId')

    if (bevelGroupId is None) or (len(bevelGroupId) == 0):
        groupIdBevels = cmds.createNode( 'groupId', skipSelect=True )
        cmds.connectAttr( groupIdBevels+'.groupId', extrudeNode+'.bevelGroupId' )
        bevelGroupId = cmds.listConnections(extrudeNode+'.bevelGroupId')

    if (extrudeGroupId is None) or (len(extrudeGroupId) == 0):
        groupIdExtrusion = cmds.createNode( 'groupId', skipSelect=True )
        cmds.connectAttr( groupIdExtrusion+'.groupId', extrudeNode+'.extrudeGroupId' )
        extrudeGroupId = cmds.listConnections(extrudeNode+'.extrudeGroupId')

    groupIds = [capGroupId[0], bevelGroupId[0], extrudeGroupId[0]]

    shaderNames = ["typeCapsShader", "typeBevelShader", "typeExtrusionShader"]
    shaderColours = [(0.627451, 0.627451, 0.627451), (1.0, 0.4019, 0.1274), (0.129412, 0.65098, 1)]

    s = 0
    for ids in groupIds:

        shader = cmds.shadingNode(shaderType, asShader=True, n=shaderNames[s]+'#', skipSelect=True)
        try:
            cmds.setAttr( shader+'.color', shaderColours[s][0], shaderColours[s][1], shaderColours[s][2], type="double3" )
        except:
            try:
                #rampShader
                cmds.setAttr( shader+'.color[0].color_Color', shaderColours[s][0], shaderColours[s][1], shaderColours[s][2], type="double3" )
            except:
                pass

        shadingGroup = cmds.sets(n=shaderNames[s]+'SG#', renderable=True,noSurfaceShader=True,empty=True)
        cmds.connectAttr('%s.outColor' %shader ,'%s.surfaceShader' %shadingGroup)
        try:
            cmds.assignShaderToType(gr=ids, sg=shadingGroup, me=meshShape)
        except:
            cmds.warning (fx.res('kMaterialAssignmentFailure'))
        s +=1

#get the shaders attached to an object
def getShadingGroupsFromObject (mesh):
    materials = []
    future = cmds.listHistory(str(mesh), f=1, pdo=1)

    if future is None:
        return None

    # Search for the connecting shading group
    for n in future:
        if cmds.attributeQuery("surfaceShader",node=n, exists=True):
            materials.append(n)

    return materials

#given the group nodes, get the associated materials
def getVectorShadingGroups (mesh, extrudeNode):
    capGroupId = cmds.listConnections(extrudeNode+'.capGroupId')
    bevelGroupId = cmds.listConnections(extrudeNode+'.bevelGroupId')
    extrudeGroupId = cmds.listConnections(extrudeNode+'.extrudeGroupId')

    capGrpMessageConections = cmds.listConnections(capGroupId[0]+'.message')
    bevelGrpMessageConections = cmds.listConnections(bevelGroupId[0]+'.message')
    extrudeGrpMessageConections = cmds.listConnections(extrudeGroupId[0]+'.message')

    if (capGrpMessageConections is not None and 
        bevelGrpMessageConections is not None and 
        extrudeGrpMessageConections is not None):

        capMaterialAtr = getShaderFromArray(capGrpMessageConections)
        bevelMaterialAtr = getShaderFromArray(bevelGrpMessageConections)
        extrudeMaterialAtr = getShaderFromArray(extrudeGrpMessageConections)

        return [capMaterialAtr, bevelMaterialAtr, extrudeMaterialAtr]
    else:
        return []

#given a list of nodes, find the shading engine, and it's material
def getShaderFromArray(GrpMessageConections):
    for node in GrpMessageConections:
        if cmds.nodeType(node) == "shadingEngine":
            return node+'.surfaceShader'

#get the shader attribute attached to an object
#this and the next function are VERY similar, but they go about their task in different ways - which only work in different situations.
def getShaderFromObject (mesh):
    #use a set, because we'll get each material returned a couple of times
    materials = set()
    shapes = cmds.listRelatives (str(mesh), fullPath=True, shapes=True)
    future = cmds.listConnections(shapes[0], type="shadingEngine")
    if future is None:
        return []

    # Search for the connecting shading group
    for n in future:
        if cmds.attributeQuery("surfaceShader",node=n, exists=True):
            materials.add ("%s.surfaceShader" % (str(n)))

    #we're expecting a list back, so lets not confuse things.
    returnList = list(materials)
    return returnList
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
