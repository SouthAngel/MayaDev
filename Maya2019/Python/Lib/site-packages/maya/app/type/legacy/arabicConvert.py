MERGE_MAP = [
    u'\uFE80',  u'\uFE81',  u'\uFE83',  u'\uFE85',  u'\uFE87',  u'\uFE89',  u'\uFE8D',  u'\uFE8F', 
    u'\uFE93',  u'\uFE95',  u'\uFE99',  u'\uFE9D',  u'\uFEA1',  u'\uFEA5',  u'\uFEA9',  u'\uFEAB', 
    u'\uFEAD',  u'\uFEAF',  u'\uFEB1',  u'\uFEB5',  u'\uFEB9',  u'\uFEBD',  u'\uFEC1',  u'\uFEC5', 
    u'\uFEC9',  u'\uFECD',  u'\u063B',  u'\u063C',  u'\u063D',  u'\u063E',  u'\u063F',  u'\u0640', 
    u'\uFED1',  u'\uFED5',  u'\uFED9',  u'\uFEDD',  u'\uFEE1',  u'\uFEE5',  u'\uFEE9',  u'\uFEED', 
    u'\uFEEF',  u'\uFEF1'
]

t_none = 0
t_start = 1
t_end = 2
t_middle = 3

MERGE_TYPE = [
    t_none,     t_start,    t_start,    t_start,    t_start,    t_end,      t_start,    t_end, 
    t_start,    t_end,      t_end,      t_end,      t_end,      t_end,      t_start,    t_start, 
    t_start,    t_start,    t_end,      t_end,      t_end,      t_end,      t_end,      t_end, 
    t_end,      t_end,      t_none,     t_none,     t_none,     t_none,     t_none,     t_middle, 
    t_end,      t_end,      t_end,      t_end,      t_end,      t_end,      t_end,      t_start, 
    t_end,      t_end
]

def ByteToHex( byteStr ):
    return ''.join( [ "%02X " % ord( x ) for x in byteStr ] ).strip()

def HexToUni(hexStr ):
    bytes = []

    hexStr = hexStr.split(" ")

    for hexChar in hexStr:
        ordNum = int(hexChar,16)
        bytes.append(unichr(ordNum))

    return ''.join( bytes )

def filterAndCorrectArabic(hexText):
    text = HexToUni(hexText)

    if len([x for x in text if isArabic(x)]) == 0:
        return hexText

    text = convertText(text)

    newText = ''
    toFlip = ''

    for ch in text:
        arabic = isArabic(ch)
        if ch == '>': ch = '<'
        elif ch == '<': ch = '>'

        if arabic or not ch.isalpha():
            if len(toFlip) > 0:
                newText += toFlip[::-1]
                toFlip = ''
            newText += ch
        else:
            toFlip += ch

    if len(toFlip) > 0:
        newText += toFlip[::-1]

    return ByteToHex(newText)

def isArabic(ch):
    # References: https://en.wikipedia.org/wiki/Arabic_script_in_Unicode
    arabic = (u'\u0600', u'\u06FF')
    arabicSupplement = (u'\u0750', u'\u077F')
    arabicExtendedA = (u'\u08A0', u'\u08FF')
    arabicPresentationFormsA = (u'\uFB50', u'\uFDFF')
    arabicPresentationFormsB = (u'\uFE70', u'\uFEFF')
    arabicBlocks = [arabic, arabicSupplement, arabicExtendedA, arabicPresentationFormsA, arabicPresentationFormsB]
    for unicodeBlock in arabicBlocks:
        if ch >= unicodeBlock[0] and ch <= unicodeBlock[1]:
            return True

    return False

def convertText(text):
    if not text: return text
    characters = list(text)
    length = convertCharacters(characters)
    text = ''.join(characters[0:len(characters)-length])
    return text[::-1]

def isAlefChar(a):
    return (a in [u'\u0622', u'\u0623', u'\u0625', u'\u0627'])

def isLamChar(a):
    return (a == u'\u0644')

def isSpaceChar(a):
    return (a >= u'\u064B' and a <= u'\u065E')

def inMergeRange(ch):
    return (ch >= u'\u0621' and ch <= u'\u064A')

def convertCharacters(chars):
    offset = t_none
    index = 0
    i = 0

    while(i < len(chars)):
        ch = chars[i]

        if getConvertType(ch) == t_middle:
            chars[i - index] = ch
            offset = t_middle
            i += 1
            continue

        nextI = i + 1

        while nextI < len(chars) - 1 and isSpaceChar(chars[nextI]):
            nextI += 1

        offset = t_start if (offset == t_end or offset == t_middle) else t_none

        if nextI < len(chars):

            if isLamChar(ch) and isAlefChar(chars[nextI]):
                chars[i - index] = convertLamAlef(chars[nextI], offset)
                index += nextI - i
                i = nextI
                i += 1
                continue

            if canMergeAfter(ch) and canMegerBefore(chars[nextI]):
                offset |= t_end

        chars[i - index] = convertChar(ch, offset)
        i += 1
    return index

def convertChar(ch, offset):
    result = ch

    if inMergeRange(ch):
        index = ord(ch) - ord(u'\u0621');

        if MERGE_TYPE[index] == t_start:
            result = unichr(ord(MERGE_MAP[index]) + (offset % 2))

        elif MERGE_TYPE[index] == t_end:
            result = unichr(ord(MERGE_MAP[index]) + offset)

        elif MERGE_TYPE[index] == t_none:
            result = unichr(ord(MERGE_MAP[index]))

    return result

def canMegerBefore(ch):
    if inMergeRange(ch):
        index = MERGE_TYPE[ord(ch) - ord(u'\u0621')];
        return (index == t_start or index == t_end or index == t_middle)

    return False    

def canMergeAfter(ch):
    if inMergeRange(ch):
        index = MERGE_TYPE[ord(ch) - ord(u'\u0621')];
        return (index == t_end or index == t_middle)

    return False

def getConvertType(ch):
    if inMergeRange(ch):
        index = ord(ch) - ord(u'\u0621');
        return MERGE_TYPE[index]

    return t_none

def convertLamAlef(ch, offset):
    if isAlefChar(ch):
        c = ord(ch) - ord(u'\u0622') # range: u'\u0622', u'\u0627'
        lamAlefMap = [u'\uFEF5', u'\uFEF7', u'\u0624', u'\uFEF9', u'\u0626', u'\uFEFB']
        return unichr(ord(lamAlefMap[c]) + (offset % 2))

    return ch# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
