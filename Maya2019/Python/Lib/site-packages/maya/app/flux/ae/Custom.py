import maya.app.flux.ae.ui as aeUI
import maya.app.flux.ae.utils as aeUtils
from maya.app.flux.imports import *
import maya.app.flux.ui.core as fui
import maya.app.flux.attrUtils as attrUtils

import maya.OpenMayaUI as omui
import re
from contextlib import contextmanager

SLIDER_ATTR_TYPES = ('long','short','byte','char','float','double','doubleAngle','doubleLinear')
VECTOR_ATTR_TYPES = ('float3','double3','long3','short3')

class ControlHandle(object):
    def __init__(self, pCustom, internalKey):
        self.pCustom = pCustom
        self.internalKey = internalKey

    def setEnabled(self, enabled):
        self.pCustom.setControlEnabled(self.internalKey, enabled)

    def setLabel(self, label):
        self.pCustom.setControlLabel(self.internalKey, label)

    def setAttr(self, attr, **kwargs):
        self.pCustom.setControlAttr(self.internalKey, attr, **kwargs)

class Custom(qt.QObject):
    def __init__(self, nodeName, *args, **kwargs):
        qt.QObject.__init__(self)

        self.build_args = args
        self.build_kwargs = kwargs

        self.name = nodeName
        self.registeredNames = set()
        self.customControls = {}
        self.pluginName = ''
        self._currentParent = None
        self.externalNodes = {}
        self.useCustomResouceFunction = hasattr(self, 'stringResourceFunction')
        self.listeners = {}
        self.cachedNodes = {}
        self.refWidgets = {}
        self.toolBtnJobs = []
        self.controlKeys = {}

        aeUtils.registerInstance(self)

    def onCreate(self, node):
        nodeName = node

        self._beginLayout()
        self.buildUI(nodeName, *self.build_args, **self.build_kwargs)
        self._endLayout()

        name = cmds.setParent(q=True)
        cmds.scriptJob(uiDeleted=[name, self.onClose], runOnce=True)
        self.customId = name

    def onReplace(self, node):
        self.name = node
        self.cachedNodes = {}

        self._updateCCs()
        self._refreshAttributeListeners()

        nc = getattr(self, "nodeChanged", None)
        if callable(nc):
            self.nodeChanged()

    def onClose(self):
        for attr in self.listeners.keys():
            info = self.listeners[attr]
            if cmds.scriptJob(exists=info['jobId']):
                cmds.scriptJob(kill=info['jobId'])

        for job in self.toolBtnJobs:
            if cmds.scriptJob(exists=job):
                cmds.scriptJob(kill=job)

        self.listeners = {}
        aeUtils.deregisterInstance(self)

    # Event filter for injecting drag data into controls
    def eventFilter(self, widget, event):
        if event.type() == qt.QEvent.Type.MouseMove:
            middleMouse = event.buttons() & qt.Qt.MiddleButton
            twoButtonMouse = qt.QGuiApplication.keyboardModifiers() & qt.Qt.ControlModifier and event.buttons() & qt.Qt.LeftButton
            altPressed = qt.QGuiApplication.keyboardModifiers() & qt.Qt.AltModifier

            if (middleMouse or twoButtonMouse) and (not altPressed):
                key = widget.objectName()
                attr = self.customControls[key].get('attr', '')
                node = self._nodeForKey(key)
                text = node + '.' + attr

                drag =  qt.QDrag(self)
                mimeData = qt.QMimeData()
                mimeData.setText(text)
                drag.setMimeData(mimeData)
                drag.exec_()
        
        return False

    def _injectEventFilter(self, key):
        w = omui.MQtUtil.findLayout(key)
        w = wrapInstance(long(w), qt.QWidget)
        w.installEventFilter(self)

    def _applyLocalization(self, name):
        if name is not None and len(name)>2 and name[0] == 'k' and name[1].isupper():
            try:
                if not self.useCustomResouceFunction:
                    name = mel.eval('getPluginResource("' + self.pluginName + '", "' + name + '")')
                else:
                    name = self.stringResourceFunction(name)
            except:
                pass
        return name

    def _localize(self, kwargs):
        if 'label' in kwargs:
            kwargs['label'] = self._applyLocalization(kwargs['label'])

    def _regControl(self, attr, typ):
        key = self.instanceKey + '_' + attr
        while key in self.customControls:
            key += '1'
        self.customControls[key] = {'attr': attr, 'type': typ}
        return key

    def _regControlWithoutAttr(self, typ):
        key = self.__class__.__name__ + '_' + typ
        while key in self.customControls:
            key += '1'
        self.customControls[key] = {'type': typ}
        return key

    def _labelFromAttr(self, attr, kwargs):
        if 'label' not in kwargs:
            node = kwargs.get('node', self.name)
            niceName = cmds.attributeQuery(attr, node=node, niceName=True)
            kwargs['label'] = niceName
            
    def _processSpecialArgs(self, kwargs, key, attr):
        node = self.name
        if 'node' in kwargs:
            name = kwargs['node']
            del kwargs['node']
            node = self.externalNodes[name]()
            self.customControls[key]['node'] = name

        controlKey = attr
        if 'controlKey' in kwargs:
            controlKey = kwargs['controlKey']
            del kwargs['controlKey']

        if controlKey not in self.controlKeys:
            self.controlKeys[controlKey] = key

        return node

    def _nodeForKey(self, key):
        node = self.name
        if 'node' in self.customControls[key]:
            node = self.externalNodes[self.customControls[key]['node']]()
        return node

    def _processChangeCommand(self, attr, kwargs):
        if 'cc' in kwargs:
            func = kwargs['cc']
            node = kwargs.get('node', '')
            self.createAttributeListener(attr, func, node)
            del kwargs['cc']

    def _updateCCs(self):
        for key in self.customControls.keys():
            attr = self.customControls[key].get('attr', '')
            node = self._nodeForKey(key)
            self._setAttrForControl(key, node, attr)

    def _setAttrForControl(self, key, node, attr):
        typ = self.customControls[key]['type']
        attribute = node+'.'+attr

        if typ == 'color':
            cmds.attrColorSliderGrp(key, e=True, attribute=attribute)
        elif typ == 'checkbox':
            cmds.attrControlGrp(key, e=True, attribute=attribute)
        elif typ == 'slider':
            cmds.attrFieldSliderGrp(key, e=True, attribute=attribute)
        elif typ == 'vector':
            cmds.attrFieldGrp(key, e=True, attribute=attribute)
        elif typ == 'enum':
            cmds.attrEnumOptionMenuGrp(key, e=True, attribute=attribute)
        elif typ == 'connectable':
            cmds.connectControl(key, attribute)
        elif typ == 'navigation' and len(attr)>0:
            cmds.attrNavigationControlGrp(key, e=True, attribute=attribute)
        elif typ == 'textField':
            self.textFieldAttrChanged(key)

    def _setParent(self, widget):
        self._currentParent = widget
        widget.setAsMelParent()

    def _getWidgetByRef(self, ref):
        return self.refWidgets.get(ref, None)

    def _beginLayout(self):
        if self._currentParent is not None:
            return

        self._setParent(aeUI.Layout())

    def _endLayout(self):
        while(self._currentParent.layoutType != 'wrapper'):
            self._currentParent.updateHeight()
            self._currentParent = self._currentParent.parentLayout

        self._currentParent.updateHeight()
        cmds.setParent(self._currentParent.parentName)
        self._currentParent = None

    def _beginTabLayout(self, ref=None):
        w = aeUI.TabLayout(self._currentParent)
        self._setParent(w)        
        if ref is not None:
            self.refWidgets[ref] = w

    def _beginTab(self, name):
        name = self._applyLocalization(name)

        tabLayout = self._currentParent
        w = aeUI.Tab()
        tabLayout.addTabNamed(w, name)
        self._setParent(w)

    def _beginFrameLayout(self, name, expanded=False, ref=None):
        name = self._applyLocalization(name)
        w = aeUI.FrameLayout(name, expanded)
        self.addWidget(w)
        self._setParent(w)
        if ref is not None:
            self.refWidgets[ref] = w

    def _beginHorizontalLayout(self, offset=0, height=None, ref=None):
        w = aeUI.HorizontalLayout(offset, height)
        self.addWidget(w)
        self._setParent(w)
        if ref is not None:
            self.refWidgets[ref] = w

    def _beginVerticalLayout(self, offset=0, height=None, ref=None):
        w = aeUI.VerticalLayout(offset, height)
        self.addWidget(w)
        self._setParent(w)
        if ref is not None:
            self.refWidgets[ref] = w

    def _beginIndentLayout(self, name='', autoStretch=True, ref=None):
        name = self._applyLocalization(name)
        w = aeUI.IndentLayout(name, autoStretch=autoStretch)
        self.addWidget(w)
        self._setParent(w)
        if ref is not None:
            self.refWidgets[ref] = w

    def _beginStackedLayout(self, ref=None):
        w = aeUI.StackedLayout()
        self.addWidget(w)
        self._setParent(w)       
        if ref is not None:
            self.refWidgets[ref] = w

    def _beginStackedPage(self):
        if self._currentParent.layoutType != 'stackedLayout':
            raise TypeError('Can only add page to a Stacked Layout.')

        w = aeUI.StackedPage()
        self._currentParent.addPage(w)
        self._currentParent.childLayouts.append(w)
        if hasattr(w, 'parentLayout'):
            w.parentLayout = self._currentParent
        self._setParent(w)

    def _endLayoutOfType(self, typ):
        while(self._currentParent.layoutType != typ):
            self._currentParent.updateHeight()
            self._currentParent = self._currentParent.parentLayout
        self._currentParent.updateHeight()
        self._setParent(self._currentParent.parentLayout)

    def _refreshAttributeListeners(self):
        for attr in self.listeners.keys():
            info = self.listeners[attr]
            if cmds.scriptJob(exists=info['jobId']):
                cmds.scriptJob(kill=info['jobId'])

            node = self.name
            if 'node' in info:
                node = self.externalNodes[info['node']]()

            if not node or not cmds.objExists(node) or attr not in cmds.listAttr(node):
                info['jobId'] = -1
                continue

            self.listeners[attr]['jobId'] = cmds.scriptJob(attributeChange=[node+'.'+attr, info['funcName']])

    def createAttributeListener(self, attr, func, node=''):
        info = {}
        info['funcName'] = func
        if len(node)>0:
            info['node'] = node
            node = self.externalNodes[info['node']]()
        else:
            node = self.name

        if not node or not cmds.objExists(node) or attr not in cmds.listAttr(node):
            info['jobId'] = -1
        else:
            info['jobId'] = cmds.scriptJob(attributeChange=['%s.%s' % (node, attr), info['funcName']])

        self.listeners[attr] = info

    def createContextListener(self, func):
        job = cmds.scriptJob(e=['ToolChanged', func])
        self.toolBtnJobs.append(job)

    def addControl(self, attr, **kwargs):
        node = kwargs.get('node', self.name)
        
        isColor = cmds.attributeQuery(attr, node=node, usedAsColor=True)
        isEnum = cmds.attributeQuery(attr, node=node, enum=True)
        attrType = cmds.attributeQuery(attr, node=node, attributeType=True)

        if isColor:
            return self.addColor(attr, **kwargs)
        elif isEnum:
            return self.addEnum(attr, **kwargs)
        elif attrType == 'bool':
            return self.addCheckbox(attr, **kwargs)
        elif attrType in ('string', 'typed'):
            return self.addTextField(attr, **kwargs)
        elif attrType in SLIDER_ATTR_TYPES:
            return self.addSlider(attr, **kwargs)
        elif attrType in VECTOR_ATTR_TYPES:
            return self.addVector(attr, **kwargs)
        else:
            print "Error: can't add control for type %s." % attrType

    def addColor(self, attr, **kwargs):
        self._processChangeCommand(attr, kwargs)
        key = self._regControl(attr, 'color')
        node = self._processSpecialArgs(kwargs, key, attr)
        self._localize(kwargs)
        self._labelFromAttr(attr, kwargs)
        cmds.attrColorSliderGrp(key, attribute=node+'.'+attr, **kwargs)
        self._injectEventFilter(key)
        return key

    def addCheckbox(self, attr, **kwargs):
        self._processChangeCommand(attr, kwargs)
        key = self._regControl(attr, 'checkbox')
        node = self._processSpecialArgs(kwargs, key, attr)
        self._localize(kwargs)
        self._labelFromAttr(attr, kwargs)

        cmds.attrControlGrp(key, attribute=node+'.'+attr, **kwargs)
        self._injectEventFilter(key)
        return key

    def textFieldAttrChanged(self, key):
        attr = self.customControls[key].get('attr', '')
        node = self._nodeForKey(key)
        fieldWrapper = self.customControls[key]['textFieldWrapper']
        callback = self.customControls[key]['textFieldCallback']

        fieldWrapper.setText(cmds.getAttr('%s.%s' % (node, attr) ))

    def textFieldEditingFinished(self, key):
        attr = self.customControls[key].get('attr', '')
        node = self._nodeForKey(key)
        fieldWrapper = self.customControls[key]['textFieldWrapper']
        callback = self.customControls[key]['textFieldCallback']

        cmds.setAttr('%s.%s' % (node, attr), fieldWrapper.text(), typ='string')

        if callback: callback()

    def addTextField(self, attr, **kwargs):
        callback = None
        if 'cc' in kwargs:
            callback = kwargs['cc']
            del kwargs['cc']

        key = self._regControl(attr, 'textField')
        node = self._processSpecialArgs(kwargs, key, attr)
        self._localize(kwargs)
        self._labelFromAttr(attr, kwargs)

        lineEdit = qt.QLineEdit()
        fieldWrapper = fui.TextFieldWrapper(lineEdit)
        self.customControls[key]['textFieldCallback'] = callback
        self.customControls[key]['textFieldWrapper'] = fieldWrapper

        with self.indentLayout(kwargs['label'], autoStretch=False):
            self.addWidget(lineEdit)

        node = kwargs.get('node', '')
        self.createAttributeListener(attr, lambda k=key: self.textFieldAttrChanged(k), node)
        fieldWrapper.textEdited.connect(lambda k=key: self.textFieldEditingFinished(k))

        self.textFieldAttrChanged(key)

    def addSlider(self, attr, **kwargs):
        self._processChangeCommand(attr, kwargs)
        key = self._regControl(attr, 'slider')
        node = self._processSpecialArgs(kwargs, key, attr)
        self._localize(kwargs)
        self._labelFromAttr(attr, kwargs)

        cmds.attrFieldSliderGrp(key, attribute=node+'.'+attr, **kwargs)
        self._injectEventFilter(key)
        return key

    def addVector(self, attr, **kwargs):
        self._processChangeCommand(attr, kwargs)
        key = self._regControl(attr, 'vector')
        node = self._processSpecialArgs(kwargs, key, attr)
        self._localize(kwargs)
        self._labelFromAttr(attr, kwargs)
        cmds.attrFieldGrp(key, attribute=node+'.'+attr, **kwargs)
        self._injectEventFilter(key)
        return key

    def addEnum(self, attr, **kwargs):
        self._processChangeCommand(attr, kwargs)
        key = self._regControl(attr, 'enum')
        node = self._processSpecialArgs(kwargs, key, attr)
        self._localize(kwargs)
        self._labelFromAttr(attr, kwargs)
        cmds.attrEnumOptionMenuGrp(key, attribute=node+'.'+attr, **kwargs)
        self._injectEventFilter(key)
        return key

    def addRadio(self, attr, **kwargs):
        self._processChangeCommand(attr, kwargs)
        key = self._regControl(attr, 'connectable')
        node = self._processSpecialArgs(kwargs, key, attr)

        self._localize(kwargs)
        self._labelFromAttr(attr, kwargs)

        states = cmds.attributeQuery(attr, node=node, listEnum=True)[0].split(':')
        start = cmds.attributeQuery(attr, node=node, min=True)[0]

        if 'labels' in kwargs:
            states = [self._applyLocalization(x) for x in kwargs['labels']]
            del kwargs['labels']

        if len(states) == 2:
            kwargs['labelArray2'] = states
        elif len(states) == 3:
            kwargs['labelArray3'] = states
        elif len(states) == 4:
            kwargs['labelArray4'] = states
            
        for i in xrange(len(states)):
            kwargs['data' + str(i+1)] = start + i
            
        kwargs['numberOfRadioButtons'] = len(states)

        cmds.radioButtonGrp(key, **kwargs)
        cmds.connectControl(key, node + '.' + attr)
        self._injectEventFilter(key)
        return key

    def addNavigation(self, attr='', **kwargs):
        if len(attr)==0:
            key = self._regControlWithoutAttr('navigation')
            node = self._processSpecialArgs(kwargs, key, attr)
            self._localize(kwargs)
        else:
            self._processChangeCommand(attr, kwargs)
            key = self._regControl(attr, 'enum')
            node = self._processSpecialArgs(kwargs, key, attr)
            self._localize(kwargs)
            self._labelFromAttr(attr, kwargs)
            kwargs['attribute'] = node + '.' + attr
        
        cmds.attrNavigationControlGrp(key, **kwargs)
        self._injectEventFilter(key)
        return key

    def setControlAttr(self, key, attr, **kwargs):
        self.customControls[key]['attr'] = attr
        node = self._processSpecialArgs(kwargs, key, attr)

        self._setAttrForControl(key, node, attr)

    def setControlEnabled(self, key, enabled):
        typ = self.customControls[key]['type']
        if typ == 'color':
            cmds.attrColorSliderGrp(key, e=True, enable=enabled)
        elif typ == 'checkbox':
            cmds.attrControlGrp(key, e=True, enable=enabled)
        elif typ == 'slider':
            cmds.attrFieldSliderGrp(key, e=True, enable=enabled)
        elif typ == 'vector':
            cmds.attrFieldGrp(key, e=True, enable=enabled)
        elif typ == 'enum':
            cmds.attrEnumOptionMenuGrp(key, e=True, enable=enabled)
        elif typ == 'connectable':
            cmds.radioButtonGrp(key, e=True, enable=enabled)
        elif typ == 'navigation':
            cmds.attrNavigationControlGrp(key, e=True, enable=enabled)
        elif typ == 'textField':
            widget = self.customControls[key]['textFieldWrapper'].lineEdit
            widget.setEnabled(enabled)

    def setControlLabel(self, key, label):
        typ = self.customControls[key]['type']
        if typ == 'color':
            cmds.attrColorSliderGrp(key, e=True, label=label)
        elif typ == 'checkbox':
            cmds.attrControlGrp(key, e=True, label=label)
        elif typ == 'slider':
            cmds.attrFieldSliderGrp(key, e=True, label=label)
        elif typ == 'vector':
            cmds.attrFieldGrp(key, e=True, label=label)
        elif typ == 'enum':
            cmds.attrEnumOptionMenuGrp(key, e=True, label=label)
        elif typ == 'connectable':
            cmds.radioButtonGrp(key, e=True, label=label)
        elif typ == 'navigation':
            cmds.attrNavigationControlGrp(key, e=True, label=label)
        elif typ == 'textField':
            print 'Cannot change textField control\'s label: not supported'

    def melDeferred(self, cmd):
        imports = 'import maya.mel as mel; import maya.cmds as cmds;'
        changeParent = 'cmds.setParent("%s");' % cmds.setParent(q=True) 
        command = 'mel.eval(\'%s\');' % cmd
        cmds.evalDeferred(imports + changeParent + command)

    def addSpacing(self, value):
        self._currentParent.addSpacing(value)

    def addStretch(self, factor=1):
        self._currentParent.addStretch(factor)

    def addWidget(self, widget, stetchFactor=0, alignment=0):
        self._currentParent.addWidget(widget, stetchFactor, alignment)

    def setIndex(self, ref, index):
        w = self._getWidgetByRef(ref)
        if w.layoutType != 'stackedLayout':
            raise 'Can only set index of Stacked Layout'

        w.setIndex(index)

    def currentLayout(self):
        return self._currentParent

    def onLayoutVisibilityChange(self, func):
        self._currentParent.visibilityChanged.connect(func)

    def setLayoutEnabled(self, ref, enabled):
        w = self._getWidgetByRef(ref)
        w.setEnabled(enabled)

    def setLayoutHidden(self, ref, hidden):
        w = self._getWidgetByRef(ref)
        if hidden:
            w.hide()
        else:
            w.show()
        w.resizeUpstream()

    def controlHandle(self, controlKey):
        if controlKey in self.controlKeys:
            return ControlHandle(self, self.controlKeys[controlKey])
        else:
            return None

    def registerExternalNode(self, name, func):
        self.externalNodes[name] = func

    def supress(self, *attrs):
        for attr in attrs:
            cmds.editorTemplate(suppress=attr)

    @contextmanager
    def frameLayout(self, name, expanded=False, ref=None):
        self._beginFrameLayout(name, expanded, ref)
        yield
        self._endLayoutOfType('frameLayout')

    @contextmanager
    def tabLayout(self, ref=None):
        self._beginTabLayout(ref)
        yield
        self._endLayoutOfType('tabLayout')

    @contextmanager
    def newTab(self, name):
        self._beginTab(name)
        yield
        self._endLayoutOfType('tab')

    @contextmanager
    def horizontalLayout(self, offset=0, height=None, ref=None):
        self._beginHorizontalLayout(offset, height, ref)
        yield
        self._endLayoutOfType('horizontalLayout')

    @contextmanager
    def verticalLayout(self, offset=0, height=None, ref=None):
        self._beginVerticalLayout(offset, height, ref)
        yield
        self._endLayoutOfType('verticalLayout')

    @contextmanager
    def indentLayout(self, name='', autoStretch=True, ref=None):
        self._beginIndentLayout(name, autoStretch=autoStretch, ref=ref)
        yield
        self._endLayoutOfType('indentLayout')

    @contextmanager
    def stackedLayout(self, ref=None):
        self._beginStackedLayout(ref)
        yield
        self._endLayoutOfType('stackedLayout')

    @contextmanager
    def page(self):
        self._beginStackedPage()
        yield
        self._endLayoutOfType('stackedPage')
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
