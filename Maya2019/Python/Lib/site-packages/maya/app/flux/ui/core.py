from maya.app.flux.imports import *
import maya.app.flux.ui.singleton as singleton
import maya.app.flux.utils as futils
import maya.app.flux

from maya import OpenMayaUI as omui

import threading
import time
import json
import os.path
import math
from copy import deepcopy

###############
# Internal vars
###############
pixmap_cache = {}
fluxIcons = {}
maya_scale = 1.0 if not hasattr(cmds, "mayaDpiSetting") else cmds.mayaDpiSetting(query=True, realScaleValue=True)
qt_dpi = qt.qApp.devicePixelRatio() if cmds.about(batch=True) else qt.QMainWindow().devicePixelRatio()

###############
# UI
###############

class HWidget(qt.QWidget):
    def __init__(self, *args, **kwargs):
        qt.QWidget.__init__(self, *args, **kwargs)
        setHLayout(self, 2,2,2,2,2)
        layout = self.layout()
        self.addWidget = layout.addWidget
        self.addSpacing = layout.addSpacing
        self.addStretch = layout.addStretch
        self.setMargins = layout.setContentsMargins
        self.margins = layout.contentsMargins
        self.setSpacing = layout.setSpacing

class VWidget(qt.QWidget):
    def __init__(self, *args, **kwargs):
        qt.QWidget.__init__(self, *args, **kwargs)
        setVLayout(self, 2,2,2,2,2)
        layout = self.layout()
        self.addWidget = layout.addWidget
        self.addSpacing = layout.addSpacing
        self.addStretch = layout.addStretch
        self.setMargins = layout.setContentsMargins
        self.margins = layout.contentsMargins
        self.setSpacing = layout.setSpacing


def centerOnScreen(dialog):
    rect = qt.qApp.desktop().screenGeometry()
    x = (rect.width()-dialog.width()) / 2;
    y = (rect.height()-dialog.height()) / 2;
    dialog.move(x,y)

def registerQtObject(obj):
    name = obj.__class__.__name__
    if name in singleton.nameCounters:
        singleton.nameCounters[name] += 1
    else:
        singleton.nameCounters[name] = 1
    name += str(singleton.nameCounters[name])
    obj.setObjectName(name)

def widgetWithLayout(typ='V', spacing=0, *margins):
    widget = qt.QWidget()
    if typ == 'V':
        setVLayout(widget, spacing, *margins)
    else:
        setHLayout(widget, spacing, *margins)
    return widget

def setHLayout(widget, spacing=0, *margins):
    if len(margins)==0: margins = (0,0,0,0)
    widget.setLayout(qt.QHBoxLayout())
    widget.layout().setContentsMargins(*margins)
    widget.layout().setSpacing(spacing)

def setVLayout(widget, spacing=0, *margins):
    if len(margins)==0: margins = (0,0,0,0)
    widget.setLayout(qt.QVBoxLayout())
    widget.layout().setContentsMargins(*margins)
    widget.layout().setSpacing(spacing)

def setWidgetWindowColor(widget, color):
    palette = widget.palette()
    palette.setColor(qt.QPalette.Window, qt.QColor(*color))
    widget.setPalette(palette)

def setWidgetBackgroundColor(widget, color):
    palette = widget.palette()
    palette.setColor(qt.QPalette.Window, qt.QColor(*color))
    widget.setPalette(palette)

def setWidgetBaseColor(widget, color):
    palette = widget.palette()
    palette.setColor(qt.QPalette.Base, qt.QColor(*color))
    widget.setPalette(palette)

def configureDragDrop(widget):
    widget.setDragEnabled(True)
    widget.setAcceptDrops(True)
    widget.setDropIndicatorShown(True)
    widget.setDefaultDropAction(qt.Qt.MoveAction)

def configureRightClickMenu(widget, callback):
    widget.setContextMenuPolicy(qt.Qt.CustomContextMenu)
    widget.customContextMenuRequested.connect(callback)

def getPixmap(name):
    if name in pixmap_cache:
        return pixmap_cache[name]

    if name and len(name) > 4 and name[-4:] == '.png':
        name = name[:-4]

    # scale = dpi()
    # iconScale = ''
    # if scale >= 2:
    #     iconScale = '_200'
    # elif scale >= 1.5:
    #     iconScale = '_150'

    # pixmap = None

    # icon = qt.QIcon(':%s%s' % (name, iconScale))
    # if len(icon.availableSizes()) > 0:
    #     pixmap = icon.pixmap(icon.availableSizes()[0])
    #     print ':%s%s' % (name, iconScale), pixmap.height(), pixmap.devicePixelRatio()
    #     pixmap.setDevicePixelRatio(dpi())
    # else:
    #     icon = qt.QIcon(':%s' % (name))
    #     if len(icon.availableSizes()) > 0:
    #         pixmap = icon.pixmap(icon.availableSizes()[0])

    pixmap = createPixmap(name + '.png')
    if pixmap and pix() == 1:
        pixmap.setDevicePixelRatio(dpi())
    #print pixmap.height(), pixmap.devicePixelRatio()
    # if pixmap is None:
    #     pixmap = pixmap2

    # if pixmap is not None and pix() == 1 and dpi() > 1:
    #     pixmap.setDevicePixelRatio(dpi())

    pixmap_cache[name] = pixmap
    return pixmap_cache[name]

def scalePixmap(pixmap, width, height):
    return pixmap.scaled(dpi(width), dpi(height), qt.Qt.KeepAspectRatio, qt.Qt.SmoothTransformation)

def getIconFromName(name):
    return qt.QIcon(getPixmap(name))

def createPixmap(imageName):
    rawPixmap = omui.MQtUtil.createPixmap(imageName)
    if rawPixmap is None:
        return None
    else:
        return wrapInstance(long(rawPixmap), qt.QPixmap)

def highlightPixmap(pixmap):
    img = qt.QImage(pixmap.toImage().convertToFormat(qt.QImage.Format_ARGB32))
    imgh = img.height()
    imgw = img.width()

    for y in range (0, imgh, 1):
        for x in range (0, imgw, 1):
            pixel = img.pixel(x, y);
            highLimit = 205 # value above this limit will just max up to 255
            lowLimit = 30 # value below this limit will not be adjusted
            adjustment = 255 - highLimit;
            color = qt.QColor(pixel);
            v = color.value()
            s = color.saturation()
            h = color.hue()
            if(v > lowLimit):
                if (v < highLimit):
                    v = v + adjustment
                else:
                    v = 255
            v = color.setHsv(h, s, v)
            img.setPixel(x, y, qt.qRgba(color.red(), color.green(), color.blue(), qt.qAlpha(pixel)));

    return qt.QPixmap(img)

def applyMargins(margins, rect):
    '''
    margins: list[4]
    rect: qt.QRect
    '''
    offsetLeft = margins[0]
    offsetTop = margins[1]
    offsetRight = -margins[2]
    offsetBottom = -margins[3]
    rect.setLeft(rect.left() + offsetLeft)
    rect.setTop(rect.top() + offsetTop)
    rect.setRight(rect.right() + offsetRight)
    rect.setBottom(rect.bottom() + offsetBottom)

def getWidgetOfClassFromLayout(layout, widgetClassName):
    for c in range(layout.count()):
        widget = layout.itemAt(c).widget()
        if widget.metaObject().className() == widgetClassName:
            return widget

def dpiScale(value):
    return maya_scale * value

def dpi(value=1):
    return max(qt_dpi * value, pix(value))

def pix(value=1):
    return dpiScale(value)

# Qt Painter with antialiasing
class QPainter(qt.QPainter):
    def __init__(self, *args):
        qt.QPainter.__init__(self, *args)
        self.setRenderHint(qt.QPainter.Antialiasing, True)

class TextFieldWrapper(qt.QObject):
    # A QLineEdit wrapper for clean events managing

    textEdited = qt.Signal()

    def __init__(self, lineEdit):
        qt.QObject.__init__(self)
        self.lineEdit = lineEdit
        self.isTextDirty = False

        self.lineEdit.textEdited.connect(self._textEdited)
        self.lineEdit.editingFinished.connect(self._editingFinished)

    def _textEdited(self):
        self.isTextDirty = True

    def _editingFinished(self):
        if self.isTextDirty:
            self.isTextDirty = False
            self.textEdited.emit()

    def setText(self, text):
        self.lineEdit.setText(text)

    def text(self):
        return self.lineEdit.text()

class DropWindow(qt.QDialog):
    instance = None
    dropped = qt.Signal(str)
    def __init__(self, label='', title='', accepts=None, ui=None, minWidth=450, **kw):
        qt.QDialog.__init__(self, **kw)
        self.setWindowTitle(title)
        self.setLayout(qt.QVBoxLayout())
        self.setMinimumWidth(pix(minWidth))

        self.stepLabels = []
        self.currentStep = 0
        self.accepts = accepts
        self.uiControls = ui

        steps = label
        if isinstance(label, basestring):
            steps = [label]
            self.accepts = [accepts]
        elif accepts is None:
            self.accepts = [None for x in steps]

        for i, step in enumerate(steps):
            w = qt.QWidget()
            w.setLayout(qt.QHBoxLayout())
            w.layout().setContentsMargins(0,0,0,0)
            w.setFixedHeight(pix(20))
            label = qt.QLabel(step)
            icon = qt.QLabel()
            self.stepLabels.append([label, icon])
            w.layout().addWidget(label)
            w.layout().addWidget(icon)
            w.layout().addStretch()
            self.layout().addWidget(w)
            if i > 0:
                label.setEnabled(False)

        self.customUI = qt.QWidget()
        self.customUI.setLayout(qt.QVBoxLayout())
        self.customUI.layout().setContentsMargins(0,0,0,0)

        self.updateCustomUI()

        self.layout().addWidget(self.customUI)

        self.listWidget = DropWindowListWidget()
        self.listWidget.viewport().installEventFilter(self)
        self.layout().addWidget(self.listWidget)
        self.droppedData = ''

        self.resize(self.sizeHint().width(), self.sizeHint().height())

    def updateCustomUI(self):
        if self.uiControls:
            width = 0
            height = 0
            for control in self.uiControls[self.currentStep]:
                w = futils.getMayaWidget(control)
                self.customUI.layout().addWidget(w)
                size = w.sizeHint()
                if size.width() > width: width = size.width()
                height += size.height()
            self.customUI.setMinimumWidth(width)
            self.customUI.setMinimumHeight(height)
        self.resize(self.sizeHint().width(), self.sizeHint().height())

    def flashRedIndicator(self):
        p = self.listWidget.property('bgColor')
        p2 = qt.QColor(255, 72, 82)
        self.paAnimation = qt.QPropertyAnimation(self.listWidget, "bgColor")
        self.paAnimation.setEasingCurve(qt.QEasingCurve.InOutQuint)
        self.paAnimation.setStartValue(p)
        self.paAnimation.setKeyValueAt(0.5, p2)
        self.paAnimation.setEndValue(p)
        self.paAnimation.setDuration(500)
        self.paAnimation.start()
        cmds.evalDeferred('import maya.cmds as cmds; cmds.warning("%s")' % futils.str_res('kUnsupportedNodeType'))

    def eventFilter(self, widget, event):
        if widget==self.listWidget.viewport() and event.type() == qt.QEvent.Type.Drop:
            data = event.mimeData().text()
            nodes = data.split('\n')

            acceptableTypes = self.accepts[self.currentStep]
            if acceptableTypes:
                for n in nodes:
                    if cmds.objExists(n):
                        nType = cmds.nodeType(n)
                        if nType not in acceptableTypes:
                            if nType == 'transform':
                                relatives = cmds.listRelatives(n, shapes=True) or []
                                if relatives and cmds.nodeType(relatives[0]) in acceptableTypes:
                                    continue
                            self.flashRedIndicator()
                            return False
                    else:
                        self.flashRedIndicator()
                        return False

            self.droppedData = data

            movie = qt.QMovie(os.path.join(futils.fluxResourcesFolder, 'DragDrop.gif'))
            self.listWidget.iconLabel.setMovie(movie)
            movie.start()

            if len(self.stepLabels):
                self.stepLabels[self.currentStep][0].setEnabled(False)
                self.stepLabels[self.currentStep][1].setPixmap(scalePixmap(getPixmap('confirm'), 20, 20))

            while self.customUI.layout().count() > 0:
                item = self.customUI.layout().takeAt(self.customUI.layout().count()-1)
                item.widget().close()

            self.currentStep += 1

            if self.currentStep < len(self.stepLabels):
                self.stepLabels[self.currentStep][0].setEnabled(True)
                self.updateCustomUI()

            else:
                self.close()

            self.dropped.emit(self.droppedData)
                
        return False

    def closeEvent(self, e):
        DropWindow.instance = None

    @staticmethod
    def getDrop(label='', callback=None, title='', accepts=None, ui=None, minWidth=450):
        mainWindowPtr = omui.MQtUtil.mainWindow()
        mainWindow = wrapInstance(long(mainWindowPtr), qt.QWidget)
        if not DropWindow.instance:
            DropWindow.instance = DropWindow(label, title=title, parent=mainWindow, accepts=accepts, ui=ui, minWidth=minWidth)
            DropWindow.instance.setProperty("saveWindowPref", True)
            DropWindow.instance.show()

        if callback is not None:
            DropWindow.instance.dropped.connect(callback)

class NodeListWidget(qt.QListWidget):
    clicked = qt.Signal(int)
    def __init__(self, parent=None):
        qt.QListWidget.__init__(self, parent=parent)
        self.setMouseTracking(True)

    def mouseMoveEvent(self, e):
        qt.QListWidget.mousePressEvent(self,e)
        pos = e.pos()
        index = self.indexAt(e.pos())
        if index.isValid():
            row = index.row()
            self.selectionModel().clearSelection()
            self.setCurrentRow(row)
            self.item(row).setSelected(True)

    def mousePressEvent(self, e):
        qt.QListWidget.mousePressEvent(self,e)
        pos = e.pos()
        index = self.indexAt(e.pos())
        if index.isValid():
            row = index.row()
            self.clicked.emit(row)

class NodeSelector(qt.QDialog):
    clicked = qt.Signal(str)
    def __init__(self, parent=None, acceptableNode='', createCallback=None, acceptableFunc=None):
        qt.QDialog.__init__(self, parent=parent)
        self.setWindowFlags(qt.Qt.Popup|qt.Qt.FramelessWindowHint|qt.Qt.NoDropShadowWindowHint)
        self.setLayout(qt.QVBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(0)

        setWidgetBackgroundColor(self, [93,93,93,255])

        self.createCallback = createCallback
        self.acceptableNode = acceptableNode
        self.acceptableFunc = acceptableFunc

        #background: rgba(93,93,93,204)
        self.listWidget = NodeListWidget()
        self.listWidget.setStyleSheet('QListWidget{border:none; background-color:rgba(0,0,0,0)}')
        self.listWidget.setFocusPolicy(qt.Qt.NoFocus)
        self.listWidget.clicked.connect(self.rowClicked)
        self.layout().addWidget(self.listWidget)

        if self.createCallback is not None:
            item = qt.QListWidgetItem('Create ' + acceptableNode)
            icon = getPixmap('out_MASH_CreateUtility')
            item.setIcon(qt.QIcon(icon))
            item.setSizeHint(qt.QSize(item.sizeHint().width(), pix(22)))
            self.listWidget.setIconSize(qt.QSize(pix(20),pix(20)))
            self.listWidget.addItem(item)

            item = qt.QListWidgetItem('')
            item.setSizeHint(qt.QSize(item.sizeHint().width(), pix(1)))
            item.setFlags(qt.Qt.NoItemFlags)
            self.listWidget.addItem(item)
            frame = qt.QFrame()
            frame.setFrameShape(qt.QFrame.HLine)
            self.listWidget.setItemWidget(item,frame)

        #Add options TODO!
        if self.acceptableFunc:
            nodes = self.acceptableFunc()
        else:
            nodes = cmds.ls(typ=acceptableNode)

        for i in nodes:
            item = qt.QListWidgetItem(i)
            icon = None
            try:
                typ = self.getNodeType(i)
                icon = self.getIcon(typ)
            except:
                pass
            if icon is None: continue

            item.setIcon(qt.QIcon(icon))
            item.setSizeHint(qt.QSize(item.sizeHint().width(), pix(20)))
            self.listWidget.setIconSize(qt.QSize(pix(20),pix(20)))
            self.listWidget.addItem(item)

        self.setFixedHeight(min(self.listWidget.count()*pix(20), pix(200)) + (-pix(17) if (self.createCallback is not None) else 0))
        self.setFocus()

    def getIcon(self, name):
        if name == 'displayPoints': raise NameException()
        if name == 'transform': name = 'locator'
        pixmap = getPixmap('out_' + name)
        pixmap = scalePixmap(pixmap, 20, 20)
        return pixmap

    def getNodeType(self, node):
        typ = cmds.nodeType(node)

        if typ == 'transform':
            shapes = cmds.listRelatives(node, shapes=True)
            if shapes:
                typ = cmds.nodeType(shapes[0])

        return typ

    def rowClicked(self, row):
        if (self.createCallback is not None) and row == 0:
            self.createCallback()
            self.close()
        else:
            node = self.listWidget.item(row).text()
            self.clicked.emit(node)
            self.close()

    def focusOutEvent(self, event):
        self.close()

class SingleNodeInputWidget(qt.QWidget):
    accepted = qt.Signal(str)
    def __init__(self, acceptableNode='', createCallback=None, acceptableFunc=None):
        qt.QWidget.__init__(self)
        self.setAcceptDrops(True)

        self.acceptableNode = acceptableNode
        self.acceptableFunc = acceptableFunc

        self.setFixedHeight(pix(22))
        self.setLayout(qt.QHBoxLayout())
        self.layout().setContentsMargins(pix(1),0,0,0)
        self.layout().setSpacing(pix(2))

        self.icon = qt.QLabel('')
        self.icon.setFixedHeight(pix(20))
        self.icon.setFixedWidth(pix(20))

        self.setIcon(acceptableNode)
        self.layout().addWidget(self.icon)

        self.label = qt.QLabel(futils.str_res('kAccepting') + ': ' + self.acceptableNode)
        self.layout().addWidget(self.label)
        self.layout().addStretch()

        self.button = ImageButton(self.createTrianglePixmap())
        self.button.clicked.connect(self.showSelector)
        self.layout().addWidget(self.button)

        self.selector = None

        self._currentNode = None

        self.createCallback = createCallback

    def setNode(self, node=None):
        if node is None:
            self._currentNode = None
            self.setIcon(self.acceptableNode)
            self.label.setText(futils.str_res('kAccepting') + ': ' + self.acceptableNode)
        else:
            self._currentNode = node
            typ = self.getNodeType(node)
            self.setIcon(typ)
            self.label.setText(node)

    def currentNode(self):
        return self._currentNode

    def setIcon(self, name):
        if name == 'transform': name = 'locator'
        pixmap = getPixmap('out_' + name)
        pixmap = scalePixmap(pixmap, 20, 20)
        self.icon.setPixmap(pixmap)

    def getNodeType(self, node):
        typ = cmds.nodeType(node)

        if typ == 'transform':
            shapes = cmds.listRelatives(node, shapes=True)
            if shapes:
                typ = cmds.nodeType(shapes[0])

        return typ

    def dragEnterEvent(self, e):
        name = e.mimeData().text()
        if cmds.nodeType(name) == self.acceptableNode:
            typ = self.getNodeType(name)
            self.setIcon(typ)
            self.label.setText(name)
            e.accept()

    def dropEvent(self, e):
        name = e.mimeData().text()
        if cmds.nodeType(name) == self.acceptableNode:
            self.setNode(name)
            self.accepted.emit(name)

    def dragLeaveEvent(self, e):
        if self.currentNode() is None:
            self.setIcon(self.acceptableNode)
            self.label.setText(futils.str_res('kAccepting') + ': ' + self.acceptableNode)
        else:
            self.setNode(self.currentNode())
        e.accept()
        
    def dragMoveEvent(self, e):
        e.accept()

    def showSelector(self):
        self.selector = NodeSelector(acceptableNode=self.acceptableNode, createCallback=self.createCallback, acceptableFunc=self.acceptableFunc)
        pos = self.mapToGlobal(self.pos())
        self.selector.setGeometry(pos.x(), pos.y()+self.height(), self.width(), pix(20))
        self.selector.clicked.connect(self.acceptNode)
        self.selector.finished.connect(self.selectorFinished)

        self.selector.show()
        self.update()

    def acceptNode(self, name):
        if len(name) == 0: return
        self.setNode(name)
        self.accepted.emit(name)

    def selectorFinished(self, result):
        self.update()

    def createTrianglePixmap(self):
        path = qt.QPainterPath()
        path.moveTo(pix(4),pix(7))
        path.lineTo(pix(14),pix(7))
        path.lineTo(pix(9),pix(12))
        path.lineTo(pix(4),pix(7))

        pixmap = qt.QPixmap(dpi(20),dpi(20))
        pixmap.setDevicePixelRatio(dpi())
        pixmap.fill(qt.QColor(0,0,0,0))
        painter = QPainter(pixmap)
        painter.setPen(qt.Qt.NoPen)
        painter.fillPath(path, qt.QBrush(qt.QColor(238,238,238)))
        painter.end()
        return pixmap

    def paintEvent(self, e):
        qt.QWidget.paintEvent(self, e)
        painter = QPainter(self)
        painter.setPen(qt.Qt.NoPen)
        painter.setBrush(qt.QColor(43,43,43))
        painter.drawRoundedRect(0,0,self.width(),self.height(), pix(2), pix(2))
        if self.selector and self.selector.isVisible():
            painter.drawRect(0,self.height()/2,self.width(),self.height())

        painter.setBrush(qt.QColor(93,93,93))
        painter.drawRoundedRect(self.width()-pix(22),0,pix(22),self.height(), pix(2), pix(2))
        painter.drawRect(self.width()-pix(22),0,pix(2),self.height())
        if self.selector and self.selector.isVisible():
            painter.drawRect(self.width()-pix(2),self.height()-pix(2),pix(2),pix(2))

        painter.end()

class ImageButton(qt.QWidget):
    clicked = qt.Signal()
    rightClicked = qt.Signal()

    def __init__(self, imageName, text='', textPos='bottom', highlighted=False, parent=None):
        qt.QWidget.__init__(self,parent)

        self.setFocusPolicy(qt.Qt.NoFocus)

        self.hover = False
        self.bgHighlighted = False
        self.bgFadeOnPress = False
        self.bgColor = qt.QColor(64, 134, 169)
        self.fadeBgColor = qt.QColor(100, 100, 100)
        self.isCurrentlyFading = False
        self.hasHoverBackground = False
        self.hoverBackgroundColor = qt.QColor(75,75,75)
        self.hasConstantBackground = False
        self.isHighlightEnabled = True

        p = self.palette()
        p.setColor(self.backgroundRole(), qt.QColor(0,0,0,0))
        self.setPalette(p)
        self.setAutoFillBackground(True)

        if textPos in ['left', 'right']:
            self.setLayout(qt.QHBoxLayout())
        else:
            self.setLayout(qt.QVBoxLayout())

        #self.layout().setSizeConstraint(qt.QLayout.SetMinimumSize)
        self.layout().setContentsMargins(0,0,0,0)

        self.createButton()
        self.createTextLabel(text)

        if textPos in ['left', 'top']:
            self.layout().addWidget(self.label, 0)
            self.layout().addWidget(self.button, 0)
        else:
            self.layout().addWidget(self.button, 0)
            self.layout().addWidget(self.label, 0)

        self.bgHighlighted = highlighted
        self.setImage(imageName)

        self.label.setVisible(len(text) > 0)

    #########
    # Public
    #########

    def setBackgroundColor(self, color):
        self.bgColor = color
        self.createBackground()
        self.redrawPixmap()

    def setConstantBackground(self, hasConst):
        self.hasConstantBackground = hasConst
        p = self.palette()
        p.setColor(self.backgroundRole(), self.hoverBackgroundColor if hasConst else qt.QColor(0,0,0,0))
        self.setPalette(p)

    def isHighlighted(self):
        return self.bgHighlighted

    def setHighlighted(self, highlighted):
        self.bgHighlighted = highlighted
        self.redrawPixmap()

    def setImage(self, image):
        if isinstance(image, basestring):
            self.createImage(image)
        else:
            self.setImageFromPixmap(image)
        self.redrawPixmap()

    def setImageFromPixmap(self, pixmap):
        self.pixmap = pixmap
        self.hoverPixmap = highlightPixmap(self.pixmap)
        self.createBackground()

    def setText(self, text):
        self.label.setText(text)
        self.label.setVisible(len(text) > 0)

    #########
    # Private
    #########

    def createButton(self):
        self.button = qt.QLabel()
        self.button.setAlignment(qt.Qt.AlignCenter)
        self.button.setSizePolicy(qt.QSizePolicy.Preferred, qt.QSizePolicy.Minimum)

    def createTextLabel(self, text):
        self.label = qt.QLabel(text)
        self.label.setAlignment(qt.Qt.AlignCenter)
        self.label.setWordWrap(True)

    def redrawPixmap(self):
        if self.isCurrentlyFading: return

        pixmap = self.hoverPixmap if self.hover else self.pixmap

        if not self.hasConstantBackground:
            p = self.palette()
            p.setColor(self.backgroundRole(), self.hoverBackgroundColor if self.hasHoverBackground and self.hover else qt.QColor(0,0,0,0))
            self.setPalette(p)

        finalPixmap = None

        if not self.bgHighlighted:
            finalPixmap = pixmap
        else:
            finalPixmap = self.pixmap.copy()
            finalPixmap.fill(qt.QColor(0, 0, 0, 0))
            painter = qt.QPainter(finalPixmap)
            painter.setRenderHint(qt.QPainter.Antialiasing, True)
            painter.drawPixmap(0,0, self.bgPixmap)
            painter.drawPixmap(0,0, pixmap)
            del painter

        self.button.setPixmap(finalPixmap)

    def createBackground(self):
        self.bgPixmap = self.createRoundRectPixmap(self.bgColor)

    def createRoundRectPixmap(self, color):
        pixmap = self.pixmap.copy()
        pixmap.fill(qt.QColor(0, 0, 0, 0))

        painter = qt.QPainter(pixmap)
        painter.setRenderHint(qt.QPainter.Antialiasing, True)
        painter.setPen(qt.QColor(0, 0, 0, 0))
        painter.setBrush(color)

        wRadius = (self.pixmap.width() / dpi())/pix(10.0)
        hRadius = wRadius
        painter.drawRoundedRect(0,0, self.pixmap.width() / self.pixmap.devicePixelRatio(),
                                self.pixmap.height() / self.pixmap.devicePixelRatio(), wRadius, hRadius)
        del painter
        return pixmap

    def createImage(self, imageName):
        self.pixmap = getPixmap(imageName)
        self.hoverPixmap = highlightPixmap(self.pixmap)
        self.createBackground()

    def fadeBackground(self):
        while self.fadeBgColor.alpha() > 0:
            self.fadeBgColor.setAlpha(self.fadeBgColor.alpha() - pix(17))
            fadePixmap = self.createRoundRectPixmap(self.fadeBgColor)

            finalPixmap = self.pixmap.copy()
            finalPixmap.fill(qt.QColor(0, 0, 0, 0))
            painter = qt.QPainter(finalPixmap)
            painter.setRenderHint(qt.QPainter.Antialiasing, True)
            painter.drawPixmap(0,0, fadePixmap)
            painter.drawPixmap(0,0, self.hoverPixmap)
            del painter
            self.button.setPixmap(finalPixmap)
            time.sleep(0.05)

        self.isCurrentlyFading = False
        self.fadeBgColor.setAlpha(255)
        self.redrawPixmap()

    #########
    # Events
    #########

    def enterEvent(self, e):
        if self.isHighlightEnabled and self.isEnabled():
            self.hover = True
            self.redrawPixmap()
        return qt.QWidget.enterEvent(self,e)

    def leaveEvent(self, e):
        if self.hover:
            self.hover = False
            self.redrawPixmap()
        return qt.QWidget.leaveEvent(self,e)

    def leftMousePress(self):
        if self.isEnabled():
            self.clicked.emit()

        if self.bgFadeOnPress:
            if self.isCurrentlyFading:
                self.fadeBgColor.setAlpha(255)
            else:
                self.isCurrentlyFading = True
                fader = threading.Thread(target=self.fadeBackground)
                fader.start()

    def mousePressEvent(self, e):
        qt.QWidget.mousePressEvent(self,e)
        if e.button() == qt.Qt.LeftButton:
            self.leftMousePress()

    def mouseReleaseEvent(self,e):
        qt.QWidget.mouseReleaseEvent(self,e)
        if e.button() == qt.Qt.RightButton and self.isEnabled():
            self.rightClicked.emit()

class DraggableListWidget(qt.QListWidget):
    def __init__(self, parent=None):
        qt.QListWidget.__init__(self)

        self.pixmap = getPixmap('DragDrop')

        self.setSelectionMode(qt.QAbstractItemView.ExtendedSelection)
        self.setDragDropMode(qt.QAbstractItemView.InternalMove)

        mime = qt.QMimeData()
        mime.setData('application/x-item', '???')

        drag = qt.QDrag(self)
        drag.setMimeData(mime)

        self.setAcceptDrops(True)
        self.setAlternatingRowColors(True)

        self.iconLabel = qt.QLabel(self)
        self.iconLabel.setPixmap(self.pixmap)
        self.iconLabel.setAttribute(qt.Qt.WA_TransparentForMouseEvents, True)

    def resizeEvent(self, e):
        qt.QListWidget.resizeEvent(self, e)
        pos = self.contentsRect().center()
        pos.setX(pos.x() - self.pixmap.size().width()/(2 * self.pixmap.devicePixelRatio()))
        pos.setY(pos.y() - self.pixmap.size().height()/(2 * self.pixmap.devicePixelRatio()))
        self.iconLabel.move(pos)

    def dragEnterEvent(self, event):
        event.acceptProposedAction()
        event.accept()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()
        event.accept()

    def paintEvent(self, e):
        qt.QListWidget.paintEvent(self,e)

class DraggableTreeWidget(qt.QTreeWidget):
    def __init__(self, parent=None):
        qt.QTreeWidget.__init__(self)

        self.pixmap = getPixmap('DragDrop')

        self.setSelectionMode(qt.QAbstractItemView.ExtendedSelection)
        self.setDragDropMode(qt.QAbstractItemView.InternalMove)

        mime = qt.QMimeData()
        mime.setData('application/x-item', '???')

        drag = qt.QDrag(self)
        drag.setMimeData(mime)

        self.setAcceptDrops(True)
        self.setAlternatingRowColors(True)

    def dragEnterEvent(self, event):
        event.acceptProposedAction()
        event.accept()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()
        event.accept()

    def paintEvent(self, e):
        qt.QTreeWidget.paintEvent(self,e)
        if self.model().rowCount() == 0:
            painter = qt.QPainter(self.viewport())
            pos = self.contentsRect().center()
            pos.setX(pos.x() - self.pixmap.size().width()/(2 * self.pixmap.devicePixelRatio()))
            pos.setY(pos.y() - self.pixmap.size().height()/(2 * self.pixmap.devicePixelRatio()) - pix(12))
            painter.drawPixmap(pos, self.pixmap)

class DropWindowListWidget(DraggableListWidget):
    def __init__(self, *args, **wargs):
        DraggableListWidget.__init__(self)
        self.setAutoFillBackground(True)
        self.setProperty('bgColor', self.palette().color(qt.QPalette.Window))

    def onBackgroundPropertyChange(self):
        p = self.palette()
        p.setColor(qt.QPalette.Window, self.property('bgColor'))
        self.setPalette(p)

    def event(self, e):
        if e.type() == qt.QEvent.Type.DynamicPropertyChange:
            self.onBackgroundPropertyChange()

        return DraggableListWidget.event(self, e)

class FrameWidget(qt.QWidget):
    switched = qt.Signal()

    def __init__(self, text, expanded=False, parent=None):
        qt.QWidget.__init__(self,parent)
        setVLayout(self,pix(2),0,0,0,0)

        self.createCollapsedIcon()
        self.createExpandedIcon()
        self.expanded = expanded

        self.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Minimum))
        
        self.topBar = FrameBar()
        setHLayout(self.topBar, 0,pix(2),0,0,0)
        self.topBar.setFixedHeight(pix(18))
        self.layout().addWidget(self.topBar)

        self.arrowIcon = qt.QLabel()
        self.arrowIcon.setPixmap(self.expandedPixmap if expanded else self.collapsedPixmap)
        self.topBar.layout().addWidget(self.arrowIcon)

        self.label = qt.QLabel(text)
        self.label.setStyleSheet('font-weight: bold;')
        self.topBar.layout().addSpacing(pix(9))
        self.topBar.layout().addWidget(self.label)
        self.topBar.layout().addStretch()

        self.contents = widgetWithLayout('V',pix(2),pix(5),pix(2),pix(5),pix(2))
        self.contents.setAutoFillBackground(True)
        setWidgetBackgroundColor(self.contents, [73,73,73])
        self.layout().addWidget(self.contents)

        if not expanded:
            self.contents.hide()

    def mousePressEvent(self, e):
        qt.QWidget.mousePressEvent(self,e)
        if e.pos().y()<=pix(18) and e.pos().y()>=0:
            self.switchMode()

    def createCollapsedIcon(self):
        path = qt.QPainterPath()

        pix2 = pix

        if not hasattr(cmds, "mayaDpiSetting"):
            path.moveTo(pix(7),pix(4))
            path.lineTo(pix(12),pix(9))
            path.lineTo(pix(7),pix(14))
            path.lineTo(pix(7),pix(4))
        else:
            pix2 = pix if pix() == 1 else lambda x: pix(x * 0.65)
            path.moveTo(pix2(8),pix2(3))
            path.lineTo(pix2(14),pix2(9))
            path.lineTo(pix2(8),pix2(15))
            path.lineTo(pix2(8),pix2(3))
            if pix() > 1:
                path.translate(pix2(4),0)

        self.collapsedPixmap = qt.QPixmap(dpi(pix2(20)), dpi(pix2(20)))
        self.collapsedPixmap.setDevicePixelRatio(dpi())
        self.collapsedPixmap.fill(qt.QColor(0,0,0,0))
        painter = QPainter(self.collapsedPixmap)
        painter.setPen(qt.Qt.NoPen)
        painter.fillPath(path, qt.QBrush(qt.QColor(238,238,238)))
        del painter

    def createExpandedIcon(self):
        path = qt.QPainterPath()

        pix2 = pix

        if not hasattr(cmds, "mayaDpiSetting"):
            path.moveTo(pix(4),pix(7))
            path.lineTo(pix(14),pix(7))
            path.lineTo(pix(9),pix(12))
            path.lineTo(pix(4),pix(7))
        else:
            pix2 = pix if pix() == 1 else lambda x: pix(x * 0.65)
            path.moveTo(pix2(5),pix2(7))
            path.lineTo(pix2(17),pix2(7))
            path.lineTo(pix2(11),pix2(13))
            path.lineTo(pix2(5),pix2(7))
            if pix() > 1:
                path.translate(pix2(4),0)

        self.expandedPixmap = qt.QPixmap(dpi(pix2(20)),dpi(pix2(20)))
        self.expandedPixmap.setDevicePixelRatio(dpi())
        self.expandedPixmap.fill(qt.QColor(0,0,0,0))
        painter = QPainter(self.expandedPixmap)
        painter.setPen(qt.Qt.NoPen)
        painter.fillPath(path, qt.QBrush(qt.QColor(238,238,238)))
        del painter

    def updateVisibility(self):
        if self.expanded:
            self.contents.show()
        else:
            self.contents.hide()

    def updateArrow(self):
        pixmap = None
        if self.expanded:
            pixmap = self.expandedPixmap
        else:
            pixmap = self.collapsedPixmap
        self.arrowIcon.setPixmap(pixmap)

    def switchMode(self):
        self.expanded = not self.expanded

        self.updateArrow()
        self.updateVisibility()

        self.layout().activate()
        self.parent().layout().activate()
        self.switched.emit()

    def addWidget(self, widget):
        self.contents.layout().addWidget(widget)

class FrameBar(qt.QWidget):
    def __init__(self, parent=None):
        qt.QWidget.__init__(self,parent)

    def paintEvent(self, e):
        qt.QWidget.paintEvent(self,e)

        painter = qt.QPainter(self)
        painter.setRenderHint(qt.QPainter.Antialiasing, True)
        painter.setPen(qt.QColor(0, 0, 0, 0))
        painter.setBrush(qt.QColor(93,93,93))

        painter.drawRoundedRect(0,0, self.width(), self.height(), pix(2), pix(2))
        del painter


class ListButtonBtn():
    def __init__(self, icons, name, highlightable=True): 
        # return of func is the new state
        # parameters: index, state
        self.icons = icons
        self.state = 0
        self.name = name
        self.highlightable = highlightable

class ListButtonItem(qt.QListWidgetItem):
    def __init__(self, text, parent, index=None):
        qt.QListWidgetItem.__init__(self,text)
        self.setFlags(qt.Qt.ItemIsDragEnabled|qt.Qt.ItemIsEditable|self.flags())
        self.setSizeHint(qt.QSize(self.sizeHint().width(), pix(28)))
        if index is not None:
            parent.insertItem(index, self)
        self.isOn = True
        self.color = qt.QColor(255,255,255)
        self._leftButtons = []
        self._rightButtons = []

    def addButton(self, icons, name, alignLeft=True, alignRight=False, highlightable=True):
        if alignRight: alignLeft = False
        buttons = self._leftButtons if alignLeft else self._rightButtons
        buttons.append(ListButtonBtn(icons, name, highlightable))

    def getButton(self, name):
        for button in self._leftButtons:
            if button.name == name:
                return button

        for button in self._rightButtons:
            if button.name == name:
                return button

class ListButtonDelegate(qt.QItemDelegate):
    def __init__(self, parent=None):
        qt.QItemDelegate.__init__(self,parent)

    def applyCellMargins(self, index):
        margins = []
        if index == 0:
            margins = [self.parent().margins_out, self.parent().margins_out, 
                        self.parent().margins_out, self.parent().margins_in]
        elif index == self.parent().count()-1:
            margins = [self.parent().margins_out, self.parent().margins_in, 
                        self.parent().margins_out, 0]
        else:
            margins = [self.parent().margins_out, self.parent().margins_in, 
                        self.parent().margins_out, self.parent().margins_in]                    
        applyMargins(margins, self._rect)

    def _drawBackground(self, index, color, selected, isOn):
        self.applyCellMargins(index)
        if isOn:
            self._painter.fillRect(self._rect, color)
        else:
            icon = fluxIcons['ChevronBGSelected'] if selected else fluxIcons['ChevronBG']
            self._painter.drawTiledPixmap(self._rect, icon, qt.QPoint(self._rect.left(), 0))

    def _drawColorBar(self, color):
        newRect = deepcopy(self._rect)
        newRect.setRight(self._rect.left() + self.parent().colorBarWidth)
        self._painter.fillRect(newRect, color)

    def _drawIcon(self, offset, icon, highlighted):
        newRect = deepcopy(self._rect)
        newRect.setLeft(self._rect.left() + offset)
        newRect.setTop(self._rect.top() + self.parent().padding)
        newRect.setWidth(self.parent().iconWidth)
        newRect.setHeight(self.parent().iconHeight)
        if highlighted: icon = highlightPixmap(icon)
        self._painter.drawPixmap(newRect, icon)

    def _drawText(self, offset, text, color):
        newRect = deepcopy(self._rect)
        oldPen = self._painter.pen()

        self._painter.setPen(color)
        applyMargins([offset,0,pix(10),0], newRect)
        self._painter.drawText(newRect, qt.Qt.AlignVCenter | qt.Qt.AlignLeft, text)

        self._painter.setPen(oldPen)

    def paint(self, painter, option, index):
        """ Main entry point of drawing the cell """
        if not index.isValid(): return

        item = self.parent().itemFromIndex(index)
        self._rect = deepcopy(option.rect)
        self._painter = painter

        selected = option.state & qt.QStyle.State_Selected
        bgcolor = None
        if selected:
            bgcolor = option.palette.color(qt.QPalette.Highlight)
        else:
            bgcolor = self.parent().rowBGColor

        self._drawBackground(index.row(), bgcolor, selected, item.isOn)
        self._drawColorBar(item.color)

        buttonName = ''
        if self.parent().hoverOver:
            row, button = self.parent().hoverOver
            if index.row()==row and button is not None:
                buttonName = button

        offset = self.parent().colorBarWidth
        self._drawIcon(offset, fluxIcons['OutlinerDrag'], buttonName=='dragIndicator')
        offset += self.parent().iconWidth
        for i, button in enumerate(item._leftButtons):
            self._drawIcon(offset, button.icons[button.state], (buttonName==button.name and button.highlightable))
            offset += self.parent().iconWidth
        offset += pix(5)

        self._drawText(offset, item.text(), self.parent().palette().text().color())

        toggleOffset = pix(24) if self.parent().showToggleButton else pix(4)


        offset = self._rect.width() -toggleOffset -len(item._rightButtons) * pix(20)
        for i, button in enumerate(item._rightButtons):
            self._drawIcon(offset, button.icons[button.state], (buttonName==button.name and button.highlightable))
            offset += self.parent().iconWidth

        if self.parent().showToggleButton:
            icon = None
            if item.isOn and selected:
                icon = fluxIcons['Enable_Selected']
            elif item.isOn:
                icon = fluxIcons['Enable']
            else:
                icon = fluxIcons['Disable']
            self._drawIcon(self._rect.width()-pix(24), icon, buttonName=='toggleButton')

        self._rect = None
        self._painter = None

    def sizeHint(self, option, index):
        hint = qt.QItemDelegate.sizeHint(self, option, index)
        if index.row()==0:
            hint.setHeight(hint.height() + self.parent().margins_in + self.parent().margins_out)
        elif index.row()==self.parent().count()-1:
            hint.setHeight(hint.height() + self.parent().margins_in)
        else:
            hint.setHeight(hint.height() + self.parent().margins_in*2)
        return hint

    def createEditor(self, parent, option, index):
        """ Creates the double-click editor for renaming render setup entries. The override entry is left aligned. """
        editor = qt.QLineEdit(parent)
        editor.setAlignment(qt.Qt.AlignLeft|qt.Qt.AlignVCenter)
        return editor

    def updateEditorGeometry(self, editor, option, index):
        """ Defines the rectangle of the QLineEdit used to edit the name of the node. """
        rect = deepcopy(option.rect)
        if index.row()==0:
            rect.setTop(rect.top() + self.parent().margins_out)
            rect.setBottom(rect.bottom() - self.parent().margins_in)
        elif index.row()==self.parent().count()-1:
            rect.setTop(rect.top() + self.parent().margins_in)
        else: 
            rect.setTop(rect.top() + self.parent().margins_in)
            rect.setBottom(rect.bottom() - self.parent().margins_in)

        item = self.parent().itemFromIndex(index)
        rect.setLeft(self.parent().colorBarWidth+pix(20)+len(item._leftButtons)*pix(20)+pix(5)+self.parent().margins_out-pix(2))
        toggleOffset = pix(24) if self.parent().showToggleButton else pix(4)
        rect.setRight(rect.right() - len(item._rightButtons)*pix(20) + toggleOffset+self.parent().margins_out + pix(2))
        editor.setGeometry(rect)

    def setEditorData (self, editor, index):
        editor.setText(index.model().data(index, qt.Qt.DisplayRole))

    def setModelData(self, editor, model, index):
        """ Sets the model data which will trigger the node renaming script to run in Maya """
        oldValue = index.data()
        newValue = editor.text()
        if newValue != oldValue and len(newValue)>0:
            model.setData(index, newValue)
            self.parent().itemTextChangedAtIndex(index, oldValue, newValue)

class ListButtonWidget(qt.QListWidget):
    '''
    Data delegate must implement these methods:
        def dropEvent(self, event):
            pass
        def setupTreeMenu(self, treeMenu, position):
            pass
        def selectionChanged(self):
            pass
        def buttonPressed(self, index, buttonName):
            pass
        def doubleClick(self, index, buttonName):
            pass
        def itemTextChangedAtIndex(self, index, oldValue, newValue):
            return newName

    Default buttons:
        'dragIndicator', 'textField', 'toggleButton'
    '''
    def __init__(self, parent=None):
        qt.QListWidget.__init__(self,parent)

        configureDragDrop(self)
        configureRightClickMenu(self, self.openTreeMenu)
        self.setSelectionMode(qt.QAbstractItemView.ExtendedSelection)

        self.actionButtonPressed = False

        delegate = ListButtonDelegate(self)
        self.setItemDelegate(delegate)

        self.setMouseTracking(True)

        self.dataDelegate = None

        self.margins_out = pix(2) #normal margin
        self.margins_in = pix(1) #margin between items
        self.colorBarWidth = pix(5)
        self.iconHeight = pix(20)
        self.iconWidth = pix(20)
        self.padding = pix(4)

        self.hoverOver = None
        self.showToggleButton = True
        self.bgpixmap = getPixmap('DragDrop')
        self.showDropIndicator = False

        self.rowBGColor = self.palette().color(qt.QPalette.Window)

    def dragEnterEvent(self, event):
        event.acceptProposedAction()
        event.accept()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()
        event.accept()

    def itemTextChangedAtIndex(self, index, oldValue, newValue):
        newName = self.dataDelegate.itemTextChangedAtIndex(index, oldValue, newValue)
        return newName

    def dropEvent(self, event):
        index = self.indexAt(event.pos())
        item = self.itemFromIndex(index)
        self.dataDelegate.dropEvent(event)
        qt.QListWidget.dropEvent(self, event)

    def openTreeMenu(self, position):
        treeMenu = qt.QMenu(self)
        self.dataDelegate.setupTreeMenu(treeMenu, position)
        treeMenu.exec_(self.viewport().mapToGlobal(position))

    def selectionChanged(self, item1, item2):
        qt.QListWidget.selectionChanged(self,item1, item2)
        self.dataDelegate.selectionChanged()
        
    def setLabelColor(self, color):
        self.currentItem().color = color
        self.viewport().update()

    def createNewLayer(self):
        item = TerrainItem('text', self, 0)

    def getButtonPressed(self, item, x):
        offset = self.margins_out + self.colorBarWidth

        if x >= offset and x < offset + self.iconWidth:
            return 'dragIndicator'
        offset += self.iconWidth

        for i in xrange(len(item._leftButtons)):
            if x >= offset and x < offset + self.iconWidth:
                return item._leftButtons[i].name
            offset += self.iconWidth

        toggleOffset = pix(24)+self.margins_out if self.showToggleButton else pix(4)

        if x>=offset and x < self.rect().width()-toggleOffset-self.margins_out - len(item._rightButtons)*self.iconWidth:
            return 'textField'

        offset = self.rect().width() - toggleOffset - len(item._rightButtons)*self.iconWidth

        for i in xrange(len(item._rightButtons)):
            if x >= offset and x < offset + self.iconWidth:
                return item._rightButtons[i].name
            offset += self.iconWidth

        if self.showToggleButton:
            if x>=offset and x< offset + self.iconWidth:
                return 'toggleButton'

        return None

    def mousePressEvent(self, event):
        index = self.indexAt(event.pos())

        if event.button() == qt.Qt.RightButton:
            self.actionButtonPressed = False
            qt.QListWidget.mousePressEvent(self,event)
            return

        row = index.row()
        if row < 0: 
            self.actionButtonPressed = False
            qt.QListWidget.mousePressEvent(self,event)
            return

        item = self.itemFromIndex(index)
        button = self.getButtonPressed(item, event.pos().x())

        if button is None or button=='dragIndicator' or button=='textField': 
            self.actionButtonPressed = False
            qt.QListWidget.mousePressEvent(self,event)
            return

        self.actionButtonPressed = True        

        if button=='toggleButton': #switch 3d
            item.isOn = not item.isOn
            self.viewport().update()
        else:
            self.dataDelegate.buttonPressed(index, button)

    def handleNormalSelection(self, index):
        modifiers = qt.QGuiApplication.keyboardModifiers()
        selectedRows = self.selectionModel().selectedRows()
        onlyThisSelected = len(selectedRows)==1 and selectedRows[0].row()==index.row()
        if (not onlyThisSelected and modifiers != qt.Qt.CTRL):
            self.selectionModel().clearSelection()
        self.selectionModel().setCurrentIndex(index, qt.QItemSelectionModel.Toggle)

    def handleRightClickSelection(self, index):
        modifiers = qt.QGuiApplication.keyboardModifiers()
        selectedRows = self.selectionModel().selectedRows()
        thisSelected = len(selectedRows)>0 and index.row() in [x.row() for x in selectedRows]
        if not thisSelected:
            if modifiers != qt.Qt.CTRL:
                self.selectionModel().clearSelection()
            self.selectionModel().setCurrentIndex(index, qt.QItemSelectionModel.Toggle)
                  
    def mouseDoubleClickEvent(self, event):
        index = self.indexAt(event.pos())
        row = index.row()
        
        if row==-1: 
            self.actionButtonPressed = False
            #qt.QListWidget.mousePressEvent(self,event)
            return

        item = self.itemFromIndex(index)
        button = self.getButtonPressed(item, event.pos().x())

        if button is None: 
            self.actionButtonPressed = False
            #qt.QListWidget.mousePressEvent(self,event)
            return

        self.dataDelegate.doubleClick(index, button)

    def mouseReleaseEvent(self, event):
        self.actionButtonPressed = False
        qt.QListWidget.mouseReleaseEvent(self,event)

    def mouseMoveEvent(self, event):
        index = self.indexAt(event.pos())
        row = index.row()

        button = None
        if row != -1:
            item = item = self.itemFromIndex(index)
            button = self.getButtonPressed(item, event.pos().x())

        if button is not None:
            self.hoverOver = [row, button]
            self.viewport().update()
        elif self.hoverOver:
            self.hoverOver = None
            self.viewport().update()
        if not self.actionButtonPressed:
            qt.QListWidget.mouseMoveEvent(self,event)

    def paintEvent(self, e):
        qt.QListWidget.paintEvent(self,e)
        if self.model().rowCount() == 0 and self.showDropIndicator:
            painter = qt.QPainter(self.viewport())
            pos = self.contentsRect().center()
            pos.setX(pos.x() - self.bgpixmap.size().width()/(2 * self.bgpixmap.devicePixelRatio()))
            pos.setY(pos.y() - self.bgpixmap.size().height()/(2 * self.bgpixmap.devicePixelRatio()))
            painter.drawPixmap(pos, self.bgpixmap)

def getIconSuffix():
    suffix = ''
    if pix(dpi())==1.5:
        suffix = '_150'
    elif pix(dpi())==2:
        suffix = '_200'
    return suffix

def loadFluxIcons():
    fluxIconsPath = os.path.dirname(maya.app.flux.__file__)
    fluxIconsPath = os.path.join(fluxIconsPath, 'resources')
    fluxIconsPath = os.path.join(fluxIconsPath, 'icons')
    fluxIconsNames = ['ChevronBGSelected', 'ChevronBG', 'OutlinerDrag', 'Enable_Selected', 'Enable', 'Disable', 'Create']
    fluxIcons = {}
    for name in fluxIconsNames:
        iconPath = name + getIconSuffix() + '.png'
        iconPath = os.path.join(fluxIconsPath, iconPath)
        fluxIcons[name] = getPixmap(iconPath)
    return fluxIcons

if not cmds.about(batch=True):
    fluxIcons = loadFluxIcons()
    # ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
