import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of the cached playback portions of the colour preferences windows.
Manages the UI creation, destruction, and synchronization of the cached playback
preferences with the state information.
'''
from functools import partial
import maya.cmds as cmds
import maya.mel as mel
from maya.common.ui import callback_tool
from maya.common.utils import Singleton
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.cache_preferences import CachePreferenceEnabled, cache_preferences_initialize
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager

__all__ = ['CacheUiColour']

# Colour preference names (see the corresponding names in TcacheRefreshUI.cpp)
# Use lists instead of dictionaries to preserve ordering
COLOUR_INFO = { 'opacity' : [ [ 'cachedPlaybackFramesOPACITY',         maya.stringTable['y_CacheUiColour.kCachedPlaybackFramesOPACITY'      ]           ] ]
              , 'colour'  : [ [ 'cachedPlaybackCachedFrames',         maya.stringTable['y_CacheUiColour.kCachedPlaybackCachedFrames'       ]      ]
                            , [ 'cachedPlaybackUncachedFrames',       maya.stringTable['y_CacheUiColour.kCachedPlaybackUncachedFrames'     ]    ]
                            , [ 'cachedPlaybackInvalidatedFrames',    maya.stringTable['y_CacheUiColour.kCachedPlaybackInvalidatedFrames'  ] ]
                            , [ 'cachedPlaybackCachedSubframes',      maya.stringTable['y_CacheUiColour.kCachedPlaybackCachedSubframes'    ]   ]
                            , [ 'cachedPlaybackInvalidatedSubframes', maya.stringTable['y_CacheUiColour.kCachedPlaybackInvalidSubframes'   ]  ]
                            , [ 'cachedPlaybackWarningFrames',        maya.stringTable['y_CacheUiColour.kCachedPlaybackWarningFrames'      ]     ]
                            ]
              }
OPACITY_NAMES = [name for [name, text] in COLOUR_INFO['opacity']]
COLOUR_NAMES  = [name for [name, text] in COLOUR_INFO['colour']]

#======================================================================
def colour_widget(colour_name):
    ''':return: Name of the RGB slider widget corresponding to the colour 'colour_name' '''
    return colour_name + 'RGBColorSlider'

#======================================================================
def opacity_widget(colour_name):
    ''':return: Name of the opacity slider widget corresponding to the colour 'colour_name' '''
    return colour_name + 'OPACITYColorSlider'

#======================================================================
class CacheUiColour(CacheUiBase):
    '''
    Class to manage the UI for the cache playback colour preferences.

    :member widgets: Set of widgets used to manage the various UI for the cache HUD state
    :member parent:  Parent control of the colour frame
    '''
    __metaclass__ = Singleton

    # Friendly name for frame widget
    FRAME_NAME = 'CacheUiColourPrefsFrame'

    # Indexes into self.widgets, independently managed
    ID_FRAME = 'frame'

    def __init__(self):
        '''
        Initialize the toolkit widgets to be empty initially
        '''
        super(CacheUiColour, self).__init__()
        self.widgets = {}
        self.parent = None

        # Unique ID used for client notifications from CachePreferences()
        self.ui_key = 'cache_preferences_in_colour_preferences'

        # Make sure the prefs have already been set up
        cache_preferences_initialize()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_ui(tool, plugin_loaded=None):
        '''
        Invoked when the preference value has been altered through some outside agent.
        Updates the various bits of UI to match it. No need to check the plug-in state
        as when it is unloaded the UI is not available for changes.
        :param plugin_loaded: If plug-in load state is known this will be a boolean, else None and it has to be read
        '''
        if plugin_loaded is None:
            plugin_loaded = CacheEvaluatorManager().plugin_loaded
        cache_enabled = CachePreferenceEnabled().get_value()
        if tool.ID_FRAME in tool.widgets:
            cmds.frameLayout( tool.widgets[tool.ID_FRAME], edit=True, visible=plugin_loaded, enable=cache_enabled, collapse=not cache_enabled )

    #----------------------------------------------------------------------
    @staticmethod
    def update_rgb_slider(colour_name):
        '''
        Find the RGB slider corresponding to the colour and update its value.
        :param colour_name: Name of the colour to be updated
        '''
        widget_name = colour_widget( colour_name )
        if cmds.colorSliderGrp( widget_name, exists=True ):
            cmds.colorSliderGrp( widget_name, edit=True, rgb=cmds.displayRGBColor( colour_name, query=True ) )

    #----------------------------------------------------------------------
    @staticmethod
    def update_opacity_slider(colour_name):
        '''
        Find the opacity slider corresponding to the colour and update its value
        :param colour_name: Name of the colour to be updated
        '''
        widget_name = opacity_widget( colour_name )
        if cmds.floatSliderGrp( widget_name, exists=True ):
            cmds.floatSliderGrp( widget_name, edit=True, value=cmds.displayRGBColor( colour_name, query=True )[0] )

    #----------------------------------------------------------------------
    def create_colour_slider(self, colour_name, colour_label):
        '''
        Create an RGB slider corresponding to the colour_name
        :param colour_name: Name of the colour whose slider is to be created
        '''
        try:
            rgb = cmds.displayRGBColor( colour_name, query=True )
            cmds.colorSliderGrp( colour_widget( colour_name )
                               , label=colour_label
                               , rgb=rgb
                               , changeCommand=callback_tool(self, partial(self.callback_update_colour, colour_name=colour_name))
                               )
        except RuntimeError:
            pass

    #----------------------------------------------------------------------
    def create_opacity_slider(self, colour_name, colour_label):
        '''
        Create an opacity slider corresponding to the colour_name
        :param colour_name: Name of the colour whose slider is to be created
        '''
        try:
            rgb = cmds.displayRGBColor( colour_name, query=True )
            cmds.floatSliderGrp( opacity_widget( colour_name )
                               , label=colour_label
                               , precision=2
                               , minValue=0.0
                               , maxValue=1.0
                               , value=rgb[0]
                               , changeCommand=callback_tool(self, partial(self.callback_update_opacity, colour_name=colour_name))
                               )
        except RuntimeError:
            pass

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_colour(tool, colour_name):
        '''Invoked when the 'colour_name' colour slider is changed to update the colour value'''
        assert tool is not None
        rgb = cmds.colorSliderGrp( colour_widget(colour_name), query=True, rgb=True )
        cmds.displayRGBColor( colour_name, rgb[0], rgb[1], rgb[2] )

        # If the User Defined Color Palette window is up, update it
        # We do not check what colour is being updated here because
        # the checking is slower than actually doing the work
        #
        mel.eval( '''global string $gObjColorPalette;
        if (`palettePort -exists $gObjColorPalette`) {
            initObjColorPalette();
        }''' )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_opacity(tool, colour_name):
        '''Invoked when the 'colour_name' opacity slider is changed to update the opacity value'''
        assert tool is not None
        opacity = cmds.floatSliderGrp( opacity_widget(colour_name), query=True, value=True )
        cmds.displayRGBColor( colour_name, opacity, opacity, opacity )

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        self.callback_update_ui( tool=self, plugin_loaded=new_state )

    #----------------------------------------------------------------------
    def create_frame(self):
        ''' Creates the frame used for the cache colour preferences.  '''
        self.widgets[self.ID_FRAME] = cmds.frameLayout( self.FRAME_NAME, label=maya.stringTable['y_CacheUiColour.kCachedPlayback'], collapsable=True )
        cmds.frameLayout( self.widgets[self.ID_FRAME], edit=True, preExpandCommand=callback_tool(self, self.callback_populate_frame) )

        CachePreferenceEnabled().add_client( self, callback_tool(self, self.callback_update_ui) )
        self.monitor_window()

        # Automatically remove this information when the control is deleted
        cmds.scriptJob( uiDeleted=(self.widgets[self.ID_FRAME], callback_tool(self, partial(self.callback_ui_deleted, element=self.ID_FRAME))) )

        # Restore the parent
        cmds.setParent( '..' )

        # Set the initial visibility states
        self.callback_update_ui( tool=self )

        return self.widgets[self.ID_FRAME]

    #----------------------------------------------------------------------
    @staticmethod
    def callback_populate_frame(tool):
        '''Populates the frame used for the cache colour preferences underneath the parent_control.'''
        # Delete any leftover children from the control first
        number_of_children = cmds.frameLayout( tool.widgets[tool.ID_FRAME], query=True, numberOfChildren=True )
        if number_of_children > 0:
            cmds.deleteUI( cmds.frameLayout(tool.widgets[tool.ID_FRAME],query=True,childArray=True) )

        # Establish the context
        cmds.setParent( tool.widgets[tool.ID_FRAME] )
        cmds.setUITemplate( 'DefaultTemplate', pushTemplate=True )
        cmds.columnLayout( adjustableColumn=True )

        # Fill in the colour preference sliders
        for [opacity_name, opacity_label] in COLOUR_INFO['opacity']:
            tool.create_opacity_slider( opacity_name, opacity_label )
        for [colour_name, colour_label] in COLOUR_INFO['colour']:
            tool.create_colour_slider( colour_name, colour_label )

        cmds.setUITemplate( popTemplate=True )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_frame(tool):
        ''' Updates the contents of the frame used for the cache colour preferences.  '''
        for opacity_name in OPACITY_NAMES:
            tool.update_opacity_slider( opacity_name )
        for colour_name in COLOUR_NAMES:
            tool.update_rgb_slider( colour_name )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_deleted(tool, element):
        '''
        Callback when the UI is deleted - cleans up the class variables.
        :param tool: CachePreferencesHud object attached to the UI that was deleted
        '''
        tool.widgets = {}
        tool.parent = None

        CachePreferenceEnabled().remove_client( tool )

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
