'''
Classes that manage caching states by a "with" scope object
'''
import re
import maya.cmds as cmds
from maya.debug.emModeManager import emModeManager
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager, CACHE_STANDARD_MODE_EVAL

__all__ = [ 'CachingScope'
          , 'NonCachingScope'
          ]

# Extracts the cached frame information from the cache evaluator 'info' dump
RE_EXTRACT_FRAMES = re.compile(r'(\d+):(\d+)')

# ======================================================================

class NonCachingScope(object):
    '''
    Scope object responsible for setting up non cached mode and restoring default settings after
    '''
    def __enter__(self):
        '''Enter the scope, setting up the evaluator managers and initial states'''
        self.em_mgr = emModeManager()
        self.em_mgr.setMode('emp')
        self.em_mgr.setMode('-cache')

        return self

    def __init__(self):
        '''Initialize everything to be empty - only use the "with" syntax with this object'''
        self.em_mgr = None

    def __exit__(self,exit_type,value,traceback):
        '''Exit the scope, restoring all of the state information'''
        if self.em_mgr:
            self.em_mgr.restore_state()
            self.em_mgr = None

    @staticmethod
    def verify_scope_setup(unit_test):
        '''
        Meta-test to check that the scope was defined correctly
        :param unit_test: The test object from which this method was called
        '''
        unit_test.assertTrue( cmds.evaluationManager( mode=True, query=True )[0] == 'parallel' )
        if cmds.pluginInfo('cacheEvaluator', loaded=True, query=True):
            unit_test.assertFalse( cmds.evaluator( query=True, en=True, name='cache' ) )

    @staticmethod
    def is_caching_scope():
        '''
        Method to determine whether caching is on or off in this object's scope
        :return: False, since this is the non-caching scope
        '''
        return False

# ======================================================================

class CachingScope(object):
    '''
    Scope object responsible for setting up caching and restoring original setup after
    '''
    def __enter__(self):
        '''Enter the scope, setting up the evaluator managers and initial states'''
        self.em_mgr = emModeManager()
        self.em_mgr.setMode('emp')
        self.em_mgr.setMode('+cache')
        # Enable idle build to make sure we can rebuild the graph when waiting.
        self.em_mgr.idle_action = emModeManager.idle_action_build

        # Setup caching options
        self.cache_mgr = CacheEvaluatorManager()
        self.cache_mgr.save_state()
        self.cache_mgr.plugin_loaded = True
        self.cache_mgr.enabled = True
        self.cache_mgr.cache_mode = CACHE_STANDARD_MODE_EVAL
        self.cache_mgr.resource_guard = False
        self.cache_mgr.fill_mode = 'syncAsync'

        # Setup autokey options
        self.auto_key_state = cmds.autoKeyframe(q=True, state=True)
        self.auto_key_chars = cmds.autoKeyframe(q=True, characterOption=True)
        cmds.autoKeyframe(e=True, state=False)

        return self

    def __init__(self):
        '''Initialize everything to be empty - only use the "with" syntax with this object'''
        self.em_mgr = None
        self.cache_mgr = None
        self.auto_key_state = None
        self.auto_key_chars = None

    def __exit__(self,exit_type,value,traceback):
        '''Exit the scope, restoring all of the state information'''
        if self.cache_mgr:
            self.cache_mgr.restore_state()
        if self.em_mgr:
            self.em_mgr.restore_state()
        cmds.autoKeyframe(e=True, state=self.auto_key_state, characterOption=self.auto_key_chars)

    @staticmethod
    def verify_scope_setup(unit_test):
        '''
        Meta-test to check that the scope was defined correctly
        :param unit_test: The test object from which this method was called
        '''
        unit_test.assertTrue( cmds.evaluationManager( mode=True, query=True )[0] == 'parallel' )
        unit_test.assertTrue( cmds.pluginInfo('cacheEvaluator', loaded=True, query=True) )
        unit_test.assertTrue( cmds.evaluator( query=True, en=True, name='cache' ) )

    @staticmethod
    def get_valid_frames():
        '''Utility to extract the list of frames cached from the cacheEvaluator command output'''
        valid_frames_string = cmds.evaluator( name='cache', q=True, info=True )
        valid_frames = []
        for match in RE_EXTRACT_FRAMES.findall(valid_frames_string):
            valid_frames.append( [ int(match[0]), int(match[1]) ] )

        return valid_frames

    def check_valid_frames(self, unit_test, expected_valid_frames):
        '''
        :param unit_test: The test object from which this method was called
        :param expected_valid_frames: The list of frames the text expected to be cached
        :return: True if the cached frame list matches the expected frame list
        '''
        current_valid_frames = self.get_valid_frames()
        if len(expected_valid_frames) == len(current_valid_frames):
            for current, expected in zip(current_valid_frames,expected_valid_frames):
                if current[0] != expected[0] or current[1] != expected[1]:
                    unit_test.fail( "{} != {} (current,expected)".format( current_valid_frames, expected_valid_frames) )
                    return False

            return True
        else:
            unit_test.fail( "{} != {} (current,expected)".format( current_valid_frames, expected_valid_frames) )
            return False

    @staticmethod
    def wait_for_cache(unit_test, wait_time=2):
        '''
        Fill the cache in the background, waiting for a maximum time
        :param unit_test: The test object from which this method was called
        :param wait_time: Time the test is willing to wait for cache completion (in seconds)
        '''
        cmds.currentTime( cmds.currentTime(q=True) )
        cmds.currentTime( cmds.currentTime(q=True) )
        cache_is_ready = cmds.cacheEvaluator( waitForCache=wait_time )
        unit_test.assertTrue( cache_is_ready )

    @staticmethod
    def is_caching_scope():
        '''
        Method to determine whether caching is on or off in this object's scope
        :return: True, since this is the caching scope
        '''
        return True

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
