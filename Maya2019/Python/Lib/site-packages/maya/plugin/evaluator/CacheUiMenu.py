import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of the popup menu entry in TimesliderMenu.mel that adds the caching preferences
enable/disable and selection of the caching mode as a submenu.
'''
from functools import partial
#
import maya.cmds as cmds
from maya.common.ui import callback_tool
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager
from maya.plugin.evaluator.cache_preferences import CachePreferences, CachePreferenceEnabled, CachePreferenceMode
from maya.plugin.evaluator.cache_preferences import cache_preferences_initialize, cache_ui_enabled
from maya.plugin.evaluator.CacheUiToggle import cache_preferences_menu_item

__all__ = ['CacheUiMenu']

#======================================================================
class CacheUiMenu(CacheUiBase):
    '''
    Class managing the cache preferences submenu within other menus.
    :member widgets: Dictionary of widgets used by the UI (KEY=widget_id, VALUE=ui control name)
    :member parent_menu: Menu control for the TimeSlider menu as a whole
    :member mode_change_job: scriptJob ID for the customEvaluatorChanged callback
    :member ui_key: Unique identifier for this particular menu
    '''
    #----------------------------------------------------------------------
    # UI objects holding the information on how the cache preferences are displayed and managed
    CONTROLS = {}

    #----------------------------------------------------------------------
    # Unique ID for the top level control and open preferences menu item
    # Must not be equal to any of the ID values on the CachePreferenceXXX classes
    ID_ROOT = 'cachedPlaybackMasterControl'
    ID_OPEN_PREFS = 'openCachedPlaybackPreferences'

    def __init__(self, ui_key):
        '''
        Initialize the menu controls
        '''
        super(CacheUiMenu, self).__init__()
        self.parent_menu = None
        self.mode_change_job = None
        self.widgets = {}

        # Add this object to the class list
        assert ui_key not in self.CONTROLS, maya.stringTable['y_CacheUiMenu.kCachePrefMenuExists' ].format( ui_key )
        self.CONTROLS[ui_key] = self

        # Unique ID used for client notifications from CachePreferences()
        self.ui_key = ui_key

        # Make sure the prefs have already been set up
        cache_preferences_initialize()

        # The parent menu may continue to exist after it has been dismissed so we have to
        # dynamically modify its contents based on available of cached playback.
        self.parent_menu = cmds.setParent( query=True, menu=True )

        self.widgets[self.ID_ROOT] = cmds.menuItem( label=maya.stringTable['y_CacheUiMenu.kFrameCachedPlayback' ], subMenu=True, tearOff=True, version='2019' )

        caching_enabled = CachePreferenceEnabled().get_value()
        control = cmds.menuItem( label=maya.stringTable['y_CacheUiMenu.kCachedPlaybackEnableText' ]
                               , annotation=maya.stringTable['y_CacheUiMenu.kCachedPlaybackEnableTip'  ]
                               , checkBox=caching_enabled
                               , command=callback_tool(self, self.callback_toggle_enabled) )
        self.widgets[CachePreferenceEnabled().ov_id] = control

        cmds.menuItem( divider=True )

        cmds.radioMenuItemCollection()
        current_mode = CachePreferenceMode().get_value()
        for mode_data in CachePreferenceMode.DATA:
            self.widgets[mode_data[CachePreferences.KEY_ENUM_ID]] = cmds.menuItem( label=mode_data[CachePreferences.KEY_ENUM_NAME]
                                                                                 , annotation=mode_data[CachePreferences.KEY_ENUM_INFO]
                                                                                 , radioButton=(current_mode == mode_data[CachePreferences.KEY_ENUM_ID])
                                                                                 , command=partial(self.callback_set_mode, mode=mode_data[CachePreferences.KEY_ENUM_ID]) )

        cmds.menuItem( divider=True )
        self.widgets[self.ID_OPEN_PREFS] = cache_preferences_menu_item()

        cmds.setParent( '..', menu=True )

        update_menu_callback = callback_tool(self, self.callback_update_menu)
        CachePreferenceMode().add_client( self, update_menu_callback )
        CachePreferenceEnabled().add_client( self, update_menu_callback )
        self.mode_change_job = cmds.scriptJob(event=('customEvaluatorChanged', update_menu_callback))

        self.monitor_window()
        self.plugin_state_change( new_state=CacheEvaluatorManager().plugin_loaded )

        # Automatically remove this class when the parent control is deleted
        cmds.scriptJob( uiDeleted=(self.parent_menu, callback_tool(self, self.menu_deleted)) )

    #----------------------------------------------------------------------
    def __str__(self):
        '''
        Return a useful formatting for all of the information in the menu.
        Not localized as this is only for debugging purposes.
        '''
        dump = 'CacheUiMenu:\n'
        dump += '    ui_key={}\n'.format( self.ui_key )
        dump += '    parent={}\n'.format( self.parent_menu )
        dump += '    job_id={}\n'.format( self.mode_change_job )
        dump += '    widgets={}'.format( '\n            '.join( ['{} = {}'.format(key,value) for key,value in self.widgets.iteritems()] ) )
        return dump

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        menuItem controls do not have a visibility attribute so the actual submenu must
        be destroyed or recreated as necessary.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        if self.ID_ROOT in self.widgets:
            # If the menu is torn off it can't be made invisible so also set the enabled state
            cmds.menu( self.widgets[self.ID_ROOT], edit=True, enable=new_state )
            cmds.menu( self.widgets[self.ID_ROOT], edit=True, visible=new_state )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_menu(tool):
        '''
        Callback to refresh the values of the menu items to match the preferences.
        :param tool: CacheUiMenu object to be updated
        '''
        if CachePreferenceEnabled().ov_id in tool.widgets:
            cmds.menuItem( tool.widgets[CachePreferenceEnabled().ov_id], edit=True, checkBox=CachePreferenceEnabled().get_value() )

            ui_enabled = cache_ui_enabled()
            current_mode = CachePreferenceMode().get_value()
            for mode_data in CachePreferenceMode.DATA:
                cmds.menuItem( tool.widgets[mode_data[CachePreferences.KEY_ENUM_ID]], edit=True
                             , enable=ui_enabled
                             , radioButton=(current_mode == mode_data[CachePreferences.KEY_ENUM_ID]) )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_toggle_enabled(tool):
        '''
        Callback when the enabled checkbox is clicked.
        :param tool: Checkbox menu item widget
        '''
        new_enabled = cmds.menuItem( tool.widgets[CachePreferenceEnabled().ov_id], query=True, checkBox=True )
        CachePreferenceEnabled().set_value( new_enabled )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_set_mode(value, mode):
        '''
        Callback when one of the caching mode radio buttons is clicked.
        :param mode: New caching mode to be set (as enum string)
        '''
        assert value is not None
        CachePreferenceMode().set_value( mode )

    #----------------------------------------------------------------------
    @staticmethod
    def menu_deleted(tool):
        '''
        Callback when the UI is deleted - cleans up the class variables.
        :param tool: CacheUiMenu object attached to the UI that was deleted
        '''
        assert tool.ui_key in tool.CONTROLS, maya.stringTable['y_CacheUiMenu.kCachePrefMenuDelete' ].format( tool.ui_key )
        del tool.CONTROLS[tool.ui_key]

        tool.widgets = {}

        # Remove the callbacks used to monitor for optionVar changes
        CachePreferenceEnabled().remove_client( tool )
        CachePreferenceMode().remove_client( tool )

        if tool.mode_change_job is not None:
            cmds.scriptJob( kill=tool.mode_change_job )
            tool.mode_change_job = None

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
