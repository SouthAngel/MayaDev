import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of the button that appears on the playback range UI component, which will
change color depending on the state of the caching feature, controls the quick enable/disable
of caching playback, and provides RMB access to a menu of caching modes.
'''
from functools import partial
#
import maya.cmds as cmds
import maya.mel as mel
from maya.common.ui import callback_tool, highlight_colour
from maya.common.utils import Singleton
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.cache_preferences import CachePreferences, CachePreferenceEnabled, CachePreferenceMode
from maya.plugin.evaluator.cache_preferences import cache_preferences_initialize, cache_ui_enabled
from maya.plugin.evaluator.CacheScriptJobHelper import CacheScriptJobHelper, EVENT_SAFE_MODE, EVENT_LIMIT_CHANGE, EVENT_EM_DISABLED
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager

__all__ = [ 'CacheUiToggle'
          , 'cache_preferences_menu_item'
          ]

#======================================================================
def use_safe_mode():
    '''
    For UI purposes safe mode is not considered on when the evaluator is off
    :return: True if the UI should use the safe mode configuration
    '''
    return CacheEvaluatorManager().plugin_loaded and CacheEvaluatorManager().safe_mode_triggered and CacheEvaluatorManager().enabled

#======================================================================
def in_em_mode():
    '''
    :return: True if the current evaluation is one of the EM modes (i.e. not DG)
    '''
    return cmds.evaluationManager(query=True,mode=True)[0] != 'off'

#======================================================================
def callback_open_caching_preferences(value):
    '''Callback invoked when the menu item to open the caching preferences is selected'''
    assert value is not None
    mel.eval('preferencesWnd CachedPlayback')

#======================================================================
def cache_preferences_menu_item():
    '''
    Create a menu item that will open the preferences window to the Cached Playback section
    :return: Name of the menuItem widget that was created
    '''
    return cmds.menuItem( label=maya.stringTable['y_CacheUiToggle.kPrefCachingTitle' ]
                        , annotation=maya.stringTable['y_CacheUiToggle.kPrefCachingTip' ]
                        , command=callback_open_caching_preferences
                        )

#======================================================================
class CacheUiToggle(CacheUiBase):
    '''
    Class managing the cache preferences toggle button within the playback range bar (playbackRange.mel)
    :member widgets:          Dictionary of widgets used by the UI (KEY=widget_id, VALUE=ui control name)
    :member mode_change_job:  scriptJob ID for the customEvaluatorChanged event
    :member state:            Current display state (one of the STATE_XX values)
    :member setting_mode:     True if currently in the middle of setting the mode from the popup (to avoid recursion)
    '''
    __metaclass__ = Singleton

    #----------------------------------------------------------------------
    # Icons and annotations for the cache toggle button in different states
    STATE_OKAY        = 0
    STATE_SAFE_MODE   = 1
    STATE_EM_OFF      = 2
    STATE_LOW_MEMORY  = 3
    STATE_NO_MEMORY   = 4
    STATE_CACHING_OFF = 5
    STATE_DISABLED    = 6
    #
    ICON_ON   = u'cachedPlayback.png'
    ICON_WARN = u'cachedPlaybackWarning.png'
    OKAY_TIP =   maya.stringTable['y_CacheUiToggle.kCachedPlaybackButtonOkayTip' ]
    #
    # Indexes into the STATE_INFO table
    ENABLED_IDX = 0
    ICON_IDX    = 1
    TOOLTIP_IDX = 2
    # Table of the toggle UI information for each of the caching states (array is [Enabled state, Icon image, Tooltip]
    STATE_INFO = { STATE_OKAY        : [True,  ICON_ON,   OKAY_TIP]
                 , STATE_SAFE_MODE   : [True,  ICON_WARN, maya.stringTable['y_CacheUiToggle.kCachedPlaybackButtonSafeTip'       ]]
                 , STATE_EM_OFF      : [False, ICON_ON,   maya.stringTable['y_CacheUiToggle.kCachedPlaybackEmOffTip'            ]]
                 , STATE_LOW_MEMORY  : [True,  ICON_WARN, maya.stringTable['y_CacheUiToggle.kCachedPlaybackButtonLowMemoryTip'  ]]
                 , STATE_NO_MEMORY   : [True,  ICON_WARN, maya.stringTable['y_CacheUiToggle.kCachedPlaybackButtonNoMemoryTip'   ]]
                 , STATE_CACHING_OFF : [True,  ICON_ON,   OKAY_TIP]
                 , STATE_DISABLED    : [True,  ICON_WARN, maya.stringTable['y_CacheUiToggle.kCachedPlaybackButtonEMDisabledTip' ]]
                 }
    #----------------------------------------------------------------------
    # Helper method to extract the enabled value from the state table
    @staticmethod
    def enabled(state):
        '''Returns the enabled value associated with the given state'''
        return CacheUiToggle.STATE_INFO[state][CacheUiToggle.ENABLED_IDX]
    #----------------------------------------------------------------------
    # Helper method to extract the icon value from the state table
    @staticmethod
    def icon(state):
        '''Returns the icon associated with the given state'''
        return CacheUiToggle.STATE_INFO[state][CacheUiToggle.ICON_IDX]
    #----------------------------------------------------------------------
    # Helper method to extract the tooltip value from the state table
    @staticmethod
    def tooltip(state):
        '''Returns the tooltip associated with the given state'''
        return CacheUiToggle.STATE_INFO[state][CacheUiToggle.TOOLTIP_IDX]

    #----------------------------------------------------------------------
    # Widget index values
    WID_BUTTON          = 0
    WID_POPUP           = 1
    WID_MODE            = 2
    WID_PREF_CACHING    = 3
    WID_PREF_COLOURS    = 4
    WID_FLUSH_CACHE     = 5
    WID_UNSUPPORTED_WEB = 6

    def __init__(self):
        '''
        Nothing to do here; the button is created on demand and this is a persistent singleton
        '''
        super(CacheUiToggle, self).__init__()
        self.widgets = {}
        self.mode_change_job = None
        self.setting_mode = False

        # Unique ID used for client notifications from CachePreferences()
        self.ui_key = 'cache_preferences_playback_range_button'

        # Make sure the prefs have already been set up
        cache_preferences_initialize()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_open_colour_preferences(value):
        '''Callback invoked when the menu item to open the colour preferences is selected'''
        assert value is not None
        mel.eval('source colorPrefWnd.mel; colorPrefOpenToFrame general_cachedPlayback')

    #----------------------------------------------------------------------
    @staticmethod
    def callback_flush_cache(value):
        '''Callback invoked when the "Flush cache" menu item is selected'''
        assert value is not None
        CacheEvaluatorManager().flush_cache()

    #----------------------------------------------------------------------
    def rebuild_popup_menu(self):
        '''
        Create the popup menu that appears over the icon.
        '''
        # If it already existed assume it needs to be changed and destroy the existing one first.
        if self.WID_POPUP in self.widgets and self.widgets[self.WID_POPUP] is not None:
            cmds.deleteUI( self.widgets[self.WID_POPUP] )

        self.widgets[self.WID_POPUP] = cmds.popupMenu( parent=self.widgets[self.WID_BUTTON] )

        cmds.radioMenuItemCollection()
        current_mode = CachePreferenceMode().get_value()
        for mode_data in CachePreferenceMode.DATA:
            self.widgets[mode_data[CachePreferences.KEY_ENUM_ID]] = cmds.menuItem( label=mode_data[CachePreferences.KEY_ENUM_NAME]
                                                                                 , annotation=mode_data[CachePreferences.KEY_ENUM_INFO]
                                                                                 , radioButton=(current_mode == mode_data[CachePreferences.KEY_ENUM_ID])
                                                                                 , command=callback_tool(self, partial(self.set_mode, mode=mode_data[CachePreferences.KEY_ENUM_ID]))
                                                                                 )
        # -----
        cmds.setParent( '..', menu=True )
        cmds.menuItem( divider=True )
        # -----
        self.widgets[self.WID_PREF_CACHING] = cache_preferences_menu_item()
        self.widgets[self.WID_PREF_COLOURS] = cmds.menuItem( label=maya.stringTable['y_CacheUiToggle.kPrefColoursTitle' ]
                                                           , annotation=maya.stringTable['y_CacheUiToggle.kPrefColoursTip' ]
                                                           , command=self.callback_open_colour_preferences
                                                           )
        self.widgets[self.WID_FLUSH_CACHE]  = cmds.menuItem( label=maya.stringTable['y_CacheUiToggle.kFlushCache' ]
                                                           , annotation=maya.stringTable['y_CacheUiToggle.kFlushCacheTip' ]
                                                           , command=self.callback_flush_cache
                                                           )

        # This is the real reason for rebuilding on demand. Menu items cannot be individually removed
        # from a popup menu so in order to get different contents you have to rebuld from scratch.
        if use_safe_mode():
            self.widgets[self.WID_UNSUPPORTED_WEB] = cmds.menuItem( label=maya.stringTable['y_CacheUiToggle.kUnsupportedNodesWebTitle' ]
                                                                  , annotation=maya.stringTable['y_CacheUiToggle.kUnsupportedNodesWebTip' ]
                                                                  , command=lambda tool: cmds.showHelp( 'CachedPlaybackUnsupportedNodes' )
                                                                  )
        else:
            self.widgets[self.WID_UNSUPPORTED_WEB] = None

    #----------------------------------------------------------------------
    def create_button(self):
        '''
        Create the button and popup menu implementing the subset of cache preferences
        accessible from the playback range widget, as well as links to the fully detailed
        preferences in the preference window.
        :return: UI Widget ID of the button
        '''
        ui_enabled = cache_ui_enabled()
        self.widgets[self.WID_BUTTON] = cmds.iconTextButton( image1=self.icon(self.STATE_OKAY)
                                                           , annotation=self.tooltip(self.STATE_OKAY)
                                                           , version='2019'
                                                           , backgroundColor=highlight_colour()
                                                           , enableBackground=CachePreferenceEnabled().get_value() and ui_enabled
                                                           , enable=self.enabled(self.STATE_OKAY)
                                                           , visible=CacheEvaluatorManager().plugin_loaded
                                                           , command=callback_tool(self, self.callback_toggle_enabled) )
        self.monitor_window()

        self.rebuild_popup_menu()

        update_ui_callback = callback_tool(self, self.callback_update_ui)
        CachePreferenceEnabled().add_client( self, update_ui_callback )
        CachePreferenceMode().add_client( self, update_ui_callback )
        self.mode_change_job = cmds.scriptJob( event=('customEvaluatorChanged', callback_tool(self, self.callback_update_ui)) )

        self.plugin_state_change( new_state=CacheEvaluatorManager().plugin_loaded )

        CacheScriptJobHelper().add_client( self, EVENT_SAFE_MODE,    callback_tool(self, self.callback_update_ui) )
        CacheScriptJobHelper().add_client( self, EVENT_LIMIT_CHANGE, callback_tool(self, self.callback_update_ui) )
        CacheScriptJobHelper().add_client( self, EVENT_EM_DISABLED,  callback_tool(self, self.callback_update_ui) )

        # Automatically remove this class when the parent control is deleted
        cmds.scriptJob( uiDeleted=(cmds.setParent(query=True), callback_tool(self, self.callback_ui_deleted)) )

        return self.widgets[self.WID_BUTTON]

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        cmds.iconTextButton( self.widgets[self.WID_BUTTON], edit=True, visible=new_state )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_toggle_enabled(tool):
        '''
        Callback to toggle the enabled state of the Cached Playback icon
        :param tool: CacheUiToggle object to be updated
        '''
        assert tool is not None
        new_enabled = not CachePreferenceEnabled().get_value()
        CachePreferenceEnabled().set_value( new_enabled )

        # The button itself does not update appearances on triggering so do it manually
        tool.callback_update_ui( tool )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_ui(tool):
        '''
        Callback to update the states of the Cached Playback icon and the popup menu after a change
        :param tool: CacheUiToggle object to be updated
        '''
        # Prevent recursion from the set_mode method
        if tool.setting_mode:
            return

        # If no plug-in then no updates are needed. (This check saves us from needing to manage
        # client status.)
        if not CacheEvaluatorManager().plugin_loaded:
            return

        em_off = not in_em_mode()

        # Gather the state info in priority order
        state = tool.STATE_OKAY
        if em_off:              # If in DG mode no other states will exist so it is first
            state = tool.STATE_EM_OFF
        elif cmds.evaluationManager(query=True, empty=True):
            state = tool.STATE_CACHING_OFF
        elif not CacheEvaluatorManager().enabled:
            state = tool.STATE_CACHING_OFF
        else:
            disable_info = cmds.evaluationManager(query=True, disableInfo=True)
            if disable_info is not None:
                state = tool.STATE_DISABLED
            elif use_safe_mode():   # If caching was put into safe mode nothing can cache so it is second
                state = tool.STATE_SAFE_MODE
            else:                   # Transient low memory states are last
                new_resource_state = CacheEvaluatorManager().resource_state
                if new_resource_state == 'low':
                    state = tool.STATE_LOW_MEMORY
                elif new_resource_state == 'out':
                    state = tool.STATE_NO_MEMORY

        ui_enabled = cache_ui_enabled()
        cmds.iconTextButton( tool.widgets[tool.WID_BUTTON]
                           , edit=True
                           , annotation=tool.tooltip(state)
                           , image1=tool.icon(state)
                           , enable=tool.enabled(state)
                           , enableBackground=ui_enabled )

        tool.rebuild_popup_menu()

    #----------------------------------------------------------------------
    @staticmethod
    def set_mode(tool, mode):
        '''
        Callback when one of the caching mode radio buttons is clicked.
        :param tool: Radio menu item widget
        :param mode: New caching mode to be set (as enum string)
        '''
        assert not tool.setting_mode
        tool.setting_mode = True
        CachePreferenceMode().set_value( mode )
        tool.setting_mode = False

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_deleted(tool):
        '''
        Callback when the UI is deleted - cleans up the class variables.
        :param tool: CacheUiToggle object attached to the UI that was deleted
        '''
        assert tool is not None
        tool.widgets = {}

        # Remove the callbacks used to monitor for optionVar changes
        CachePreferenceEnabled().remove_client( tool )
        CachePreferenceMode().remove_client( tool )

        # Remove the callbacks
        if tool.mode_change_job is not None:
            cmds.scriptJob( kill=tool.mode_change_job )
            tool.mode_change_job = None

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
