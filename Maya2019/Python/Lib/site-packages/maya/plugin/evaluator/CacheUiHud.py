import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of the cached playback portions of the evaluation toolkit.
Manages the UI creation, destruction, and synchronization of the cached playback
preferences with the state information.

These sections are managed, appearing in different places in the toolkit:
    Cache HUD
    Cache Correctness and Cache Performance tests
    Caching playback preferences section
'''
from functools import partial
import maya.cmds as cmds
from maya.common.ui import callback_tool
from maya.common.utils import Singleton
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.cache_preferences import CachePreferences, CachePreferenceHud, cache_preferences_initialize
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager
from maya.plugin.evaluator.CacheScriptJobHelper import CacheScriptJobHelper, EVENT_CACHE_DESTROYED

__all__ = ['CacheUiHud']

RUNTIME_TOGGLE_CMD = 'ToggleCacheVisibility'

#======================================================================
class CacheUiHud(CacheUiBase):
    '''
    Class to manage the UI for the cache HUD preferences.

    :member widgets: Set of widgets used to manage the various UI for the cache HUD state
    '''
    __metaclass__ = Singleton

    # Indexes into self.widgets, independently managed
    ID_TOOLKIT            = 'toolkit'
    ID_MENU               = 'menu'
    ID_PREVIOUS_MENU_ITEM = 'previousMenuItem'
    ID_MENU_ITEM_PARENT   = 'menuItemParent'

    # Data for the different HUD types.
    # KEY=Name of the HUD element, VALUE=[HUD label, HUD preset name]
    HUD_NAMES = [ 'HUDVP2ResourceLimit', 'HUDResourceLimit', 'HUDCacheState' ]
    HUD_DATA  = { HUD_NAMES[0] : [ maya.stringTable[ 'y_CacheUiHud.kHUDLabelVP2ResourceLimit'   ], 'Vp2ResourceLimit' ]
                , HUD_NAMES[1] : [ maya.stringTable[ 'y_CacheUiHud.kHUDLabelResourceLimit'   ],        'resourceLimit' ]
                , HUD_NAMES[2] : [ maya.stringTable[ 'y_CacheUiHud.kHUDLabelCache'   ],                       'cacheState' ]
                }

    def __init__(self):
        '''
        Initialize the toolkit widgets to be empty initially
        '''
        super(CacheUiHud, self).__init__()
        self.widgets = {}
        self.monitor_count = 0

        # Unique ID used for client notifications from CachePreferences()
        self.ui_key = 'cache_preferences_in_hud'

        # Make sure the prefs have already been set up
        cache_preferences_initialize()

        if not cmds.runTimeCommand( RUNTIME_TOGGLE_CMD, exists=True ):
            cmds.runTimeCommand( RUNTIME_TOGGLE_CMD
                               , default=True
                               , label=maya.stringTable['y_CacheUiHud.kCacheHudLabel' ]
                               , annotation=maya.stringTable['y_CacheUiHud.kCacheHudAnnotation' ]
                               , category=('Menu items.Common.Display.Heads Up Display')
                               , commandLanguage='python'
                               , command='from maya.plugin.evaluator.CacheUiHud import CachePreferenceHud; CachePreferenceHud().set_value( not CachePreferenceHud().get_value() )'
                               )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_preference(tool):
        '''
        Invoked when the state of the cache HUD checkbox changes. Updates the
        optionVar associated with the cache HUD.
        '''
        value = cmds.checkBoxGrp(tool.widgets[tool.ID_TOOLKIT], query=True, value1=True)
        CachePreferenceHud().set_value( value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_visibility(tool):
        '''
        Invoked when some external agent could affect the visibility of the widgets.
        e.g. the opening of a frame layout, which automatically makes all children visible
        '''
        tool.plugin_state_change( new_state=CacheEvaluatorManager().plugin_loaded )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_ui(tool):
        '''
        Invoked when the preference value has been altered through some outside agent.
        Updates the various bits of UI to match it. No need to check the plug-in state
        as when it is unloaded the UI is not available for changes.
        '''
        hud_state = CachePreferenceHud().get_value()
        if tool.ID_TOOLKIT in tool.widgets:
            cmds.checkBoxGrp( tool.widgets[tool.ID_TOOLKIT], edit=True, value1=hud_state )

        # The actual HUD element for caching should go away when it is disabled since it can have no data
        for hud_name in tool.HUD_NAMES:
            if hud_name in tool.widgets:
                cmds.headsUpDisplay( tool.widgets[hud_name], edit=True, visible=hud_state )

        if tool.ID_MENU in tool.widgets:
            cmds.menuItem( tool.widgets[tool.ID_MENU], edit=True, checkBox=hud_state )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_memory_changed(tool):
        '''
        Invoked when the memory usage may have changed and the HUD needs to update.
        '''
        assert tool is not None
        if CachePreferenceHud().get_value():
            cmds.refresh()

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        hud_state = CachePreferenceHud().get_value()

        for hud_name in self.HUD_NAMES:
            if hud_name in self.widgets:
                cmds.headsUpDisplay( self.widgets[hud_name], edit=True, visible=new_state and hud_state )

        if self.ID_TOOLKIT in self.widgets:
            cmds.checkBoxGrp( self.widgets[self.ID_TOOLKIT], edit=True, visible=new_state )

        # By destroying the HUD display menu children it will force them to rebuild the next time it is opened
        if self.ID_MENU_ITEM_PARENT in self.widgets:
            if new_state:
                if self.ID_MENU not in self.widgets:
                    self.insert_menu_item()
            else:
                if self.ID_MENU in self.widgets:
                    cmds.deleteUI( self.widgets[self.ID_MENU] )
                    del self.widgets[self.ID_MENU]

    #----------------------------------------------------------------------
    def start_monitoring(self):
        '''
        Enable the monitoring of changes to the plug-in state and the preference value.
        This uses a monitor count to allow one or both UI elements to be active at the
        same time and share the callback method that updates whichever of them is active.
        '''
        if self.monitor_count == 0:
            CachePreferenceHud().add_client( self, callback_tool(self, self.callback_update_ui) )
        self.monitor_count += 1

        self.monitor_window()

    #----------------------------------------------------------------------
    def create_toolkit_button(self):
        ''' Creates the checkbox used for the cache HUD state in the evaluation toolkit.  '''
        self.widgets[self.ID_TOOLKIT] = cmds.checkBoxGrp( label=''
                                                        , label1=maya.stringTable['y_CacheUiHud.kCacheHUD' ]
                                                        , value1=CachePreferenceHud().get_value()
                                                        , visible=CachePreferences().cache_mgr.plugin_loaded
                                                        , changeCommand=callback_tool(self, self.callback_update_preference)
                                                        )
        self.start_monitoring()
        # Automatically remove this information when the control is deleted
        cmds.scriptJob( uiDeleted=(self.widgets[self.ID_TOOLKIT], callback_tool( self, partial(self.callback_ui_deleted, element=self.ID_TOOLKIT))) )

    #----------------------------------------------------------------------
    def insert_menu_item(self):
        '''
        Put the Display menu HUD cache menuItem into its proper place. This method was
        designed to work both when the menu is initially being populated and when the
        item is being added back to the existing menu.
        '''
        assert self.ID_PREVIOUS_MENU_ITEM in self.widgets
        assert self.ID_MENU_ITEM_PARENT in self.widgets
        assert cmds.runTimeCommand( RUNTIME_TOGGLE_CMD, exists=True )

        self.widgets[self.ID_MENU] = cmds.menuItem( checkBox=CachePreferenceHud().get_value()
                                                  , parent=self.widgets[self.ID_MENU_ITEM_PARENT]
                                                  , insertAfter=self.widgets[self.ID_PREVIOUS_MENU_ITEM]
                                                  , version='2019'
                                                  , sourceType='mel'
                                                  , runTimeCommand=RUNTIME_TOGGLE_CMD )
        # Automatically remove this information when the control is deleted
        cmds.scriptJob( uiDeleted=(self.widgets[self.ID_MENU], callback_tool( self, partial(self.callback_ui_deleted, element=self.ID_MENU))) )

        self.start_monitoring()

    #----------------------------------------------------------------------
    def create_hud_menu_item(self, previous_item):
        '''
        Creates the menu item used in the Display menu for the cache HUD state.
        :param previous_item: Name of the menuItem appearing above this one in the menu
        '''
        self.widgets[self.ID_PREVIOUS_MENU_ITEM] = previous_item
        self.widgets[self.ID_MENU_ITEM_PARENT] = cmds.setParent( query=True, menu=True )
        cmds.scriptJob( uiDeleted=(self.widgets[self.ID_PREVIOUS_MENU_ITEM], callback_tool( self, partial(self.callback_ui_deleted, element=self.ID_PREVIOUS_MENU_ITEM))) )
        cmds.scriptJob( uiDeleted=(self.widgets[self.ID_MENU_ITEM_PARENT], callback_tool( self, partial(self.callback_ui_deleted, element=self.ID_MENU_ITEM_PARENT))) )

        if CachePreferences().cache_mgr.plugin_loaded:
            self.insert_menu_item()

        self.start_monitoring()

    #----------------------------------------------------------------------
    def create_heads_up_display(self, section, label_width, starting_block):
        '''
        Creates the HUD elements used by the cache evaluator.
        :param section: Section in which the HUD will appear
        :param label_width: How wide the HUD label should be
        :param starting_block: Block for the first HUD element
        :return: Next block index to use in order to appear after the last caching HUD element
        '''
        hud_visible = CachePreferenceHud().get_value() and CacheEvaluatorManager().plugin_loaded

        # HUD elements
        for hud_name in self.HUD_NAMES:
            # Unlike most other controls the headsUpDisplay command returns an ID that
            # cannot be used for querying. Only the name can be used.
            self.widgets[hud_name] = hud_name
            cmds.headsUpDisplay( hud_name
                               , section=section
                               , labelWidth=label_width
                               , dataWidth=95
                               , block=starting_block
                               , visible=hud_visible
                               , label=self.HUD_DATA[hud_name][0]
                               , labelFontSize='small'
                               , preset=self.HUD_DATA[hud_name][1]
                               )
            # HUD elements do not get a uiDeleted event if they are removed so do not monitor
            # them. The HUD display menu entry will monitor the main window so the HUD elements
            # will always be properly updated.
            starting_block += 1

        CacheScriptJobHelper().add_client( self, EVENT_CACHE_DESTROYED, callback_tool( self, self.callback_memory_changed ) )

        return starting_block

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_deleted(tool, element):
        '''
        Callback when the UI is deleted - cleans up the class variables.
        :param element: Index of UI element that was just deleted
        '''
        assert tool.monitor_count > 0

        if element in [tool.ID_TOOLKIT, tool.ID_MENU, tool.ID_MENU_ITEM_PARENT, tool.ID_PREVIOUS_MENU_ITEM] and element in tool.widgets:
            del tool.widgets[element]

        tool.monitor_count -= 1
        if tool.monitor_count == 0:
            CachePreferenceHud().remove_client( tool )

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
