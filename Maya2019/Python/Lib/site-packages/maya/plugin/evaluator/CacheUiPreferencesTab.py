import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of the cached playback tab in the main preferences window.
'''
import maya.cmds as cmds
import maya.mel as mel
from maya.common.ui import callback_tool
from maya.common.utils import Singleton
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.cache_preferences import cache_preferences_initialize
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager
from maya.plugin.evaluator.CacheUiFullLayout import CacheUiFullLayout
from maya.plugin.evaluator.CacheUiTimesliderPreferences import CacheUiTimesliderPreferences

__all__ = ['CacheUiPreferencesTab']

#======================================================================
class CacheUiPreferencesTab(CacheUiBase):
    '''
    Class to manage the UI for the cached playback tab in the preferences window.
    The main reason this has to be its own class is that the tabLayout command does not
    support making children invisible (and if you make the child invisible directly then
    it just makes the frame invisible, leaving the tab itself visible).

    Only one of these can exist at a time, however the names of the widgets around it
    may change if, for example, the preferences window closes and re-opens. For that reason
    all initialization is done in the create_ui method.

    :member widgets: Set of widgets used to manage the various UI components
    :member prefs_window: Name of the preferences window
    :member prefs_template: Name of the template the preferences window uses
    :member text_scroll_widget: Name of the textScrollList control in which the cache preferences item lives
    :member text_scroll_index: Index of the cache preferences item within the textScrollList
    '''
    __metaclass__ = Singleton

    # Indexes into self.widgets, independently managed
    ID_ROOT = 'prefCachingColumn'

    def __init__(self):
        '''
        Initialize the toolkit widgets to be empty initially
        '''
        super(CacheUiPreferencesTab, self).__init__()
        self.widgets = {}
        self.prefs_window = None
        self.prefs_template = None
        self.text_scroll_widget = None
        self.text_scroll_index = None

        # Unique ID used for client notifications from CachePreferences()
        self.ui_key = 'cache_preferences_tab'
        self.ui_key_layout = 'cache_preferences_tab_layout'

        # Make sure the prefs have already been set up
        cache_preferences_initialize()

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        As tabLayouts do not have the ability to make their children invisible the
        entire child has to be deleted and added back on unload and load.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        # If the window doesn't exist then do not try to update the contents
        if self.prefs_window is None:
            return

        last_selected = cmds.textScrollList( self.text_scroll_widget, query=True, selectIndexedItem=True )[0]

        if new_state:
            # The only way to get in here is if create_ui were previously called with the
            # actual parameters and either the plug-in was not loaded at the time or it
            # was subsequently unloaded. In either case the parameters should already exist.
            self.create_list_entry(self.prefs_window, self.text_scroll_widget, self.text_scroll_index, new_state=True)
            mel.eval( "source preferencesWnd.mel; enableTab({})".format( self.text_scroll_index ) )
        else:
            if self.text_scroll_widget is not None:
                # Find what should be selected next
                if last_selected > self.text_scroll_index:
                    # If it's after in the list then the index will decrease
                    last_selected = last_selected - 1
                elif last_selected == self.text_scroll_index:
                    # If it's the cachedPlayback item go back to the first tab
                    last_selected = 1
                # else keep the same selection

                cmds.textScrollList( self.text_scroll_widget, edit=True, removeIndexedItem=self.text_scroll_index )
                mel.eval( "source preferencesWnd.mel; disableTab({})".format( self.text_scroll_index ) )

        mel.eval( 'source preferencesWnd.mel; switchPrefTabs {};'.format(last_selected)  )

    #----------------------------------------------------------------------
    def create_ui(self, prefs_template):
        '''
        Creates the Cached Playback frame that is part of the preferences window tabs.
        :param prefs_template: Name of the template the preferences window uses
        :return: Title to show when the cache preferences tab is visible
        '''
        assert self.prefs_window is not None

        # Check to see if this has been created already (e.g. if the preferences window
        # were opened to a tab after it was already opened)
        if self.prefs_template is None:

            self.prefs_template     = prefs_template

            # This monitoring happens even if the preferences do not initially populate
            cmds.scriptJob( uiDeleted=(self.prefs_window, callback_tool(self, self.callback_ui_deleted)) )

            previous_parent = cmds.setParent( query=True )
            cmds.setParent( self.prefs_window )

            #  Create the UI
            cmds.setParent( self.ID_ROOT )
            cmds.setUITemplate( self.prefs_template, pushTemplate=True )

            CacheUiFullLayout(self.ui_key_layout)
            CacheUiTimesliderPreferences().create_ui()

            cmds.setParent( previous_parent )
            cmds.setUITemplate( popTemplate=True )

            # Initialize the state of the widgets to the current state of the preferences
            self.update_ui()

        return maya.stringTable[ 'y_CacheUiPreferencesTab.kCachePreferencesTabTitle'  ]

    #----------------------------------------------------------------------
    def create_list_entry(self, prefs_window, text_scroll_widget, text_scroll_index, new_state=None):
        '''
        Create the textScrollList entry from which the cached playback is enabled
        :param text_scroll_widget: Name of the textScrollList control in which the cache preferences item lives
        :param text_scroll_index: Index of the cache preferences item within the textScrollList
        :param new_state: New plugin load state. If None then read from the evalutor
        '''
        if self.prefs_window is None:
            self.monitor_window()

        self.prefs_window       = prefs_window
        self.text_scroll_widget = text_scroll_widget
        self.text_scroll_index  = text_scroll_index

        # If the plugin is not loaded then the item should not exist, so don't bother creating it
        if new_state is None:
            new_state = CacheEvaluatorManager().plugin_loaded
        if not new_state:
            return False

        cmds.textScrollList( text_scroll_widget, edit=True, appendPosition=[text_scroll_index, maya.stringTable['y_CacheUiPreferencesTab.kCachePreferencesTabText']], uniqueTag='CachedPlayback' )
        return True

    #----------------------------------------------------------------------
    def create_frame(self):
        '''
        Create the frame in which the cache preferences tab will live.
        '''
        previous_parent = cmds.setParent(query=True)
        self.widgets[self.ID_ROOT] = cmds.frameLayout( self.ID_ROOT, labelVisible=False, borderVisible=False, marginWidth=10, marginHeight=10 )
        cmds.columnLayout( adjustableColumn=True )
        cmds.setParent( previous_parent )

    #----------------------------------------------------------------------
    def update_ui(self):
        '''Updates the Cached Playback frame that is part of the preferences window tabs.'''

        # If the UI doesn't exist (e.g. because the plug-in was unloaded) there is nothing to update
        if len(self.widgets) == 0:
            return

        assert self.ui_key_layout in CacheUiFullLayout.CONTROLS
        CacheUiFullLayout.CONTROLS[self.ui_key_layout].update_ui()
        CacheUiTimesliderPreferences().update_ui()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_deleted(tool):
        '''
        Invoked when the entire preference window is deleted - cleans up the class variables and client monitoring.
        :param tool: CacheUiPreferencesTab object attached to the UI that was deleted
        '''
        tool.widgets = {}
        tool.prefs_window       = None
        tool.prefs_template     = None
        tool.text_scroll_widget = None
        tool.text_scroll_index  = None

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
