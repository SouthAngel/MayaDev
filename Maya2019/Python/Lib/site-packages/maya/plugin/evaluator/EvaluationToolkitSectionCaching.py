import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of the cached playback portions of the evaluation toolkit.
Manages the UI creation, destruction, and synchronization of the cached playback
preferences with the state information.

These sections are managed, appearing in different places in the toolkit:
    Cache HUD
    Cache Correctness and Cache Performance tests
    Caching playback preferences section
'''
import maya.cmds as cmds
from maya.common.ui import LayoutManager, callback_tool
from maya.debug.DeformerEvaluatorManager import DeformerEvaluatorManager
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager
from maya.plugin.evaluator.CacheEvaluatorManager import CACHE_STANDARD_MODE_EVAL_SHAPES, CACHE_STANDARD_MODE_VP2_SW_NO_FALLBACK, CACHE_STANDARD_MODE_VP2_HW_NO_FALLBACK
from maya.plugin.evaluator.cache_preferences import CachePreferenceHud, CachePreferenceEnabled, CachePreferenceMode, CachePreferenceFillType
from maya.plugin.evaluator.cache_preferences import cache_ui_enabled
from maya.plugin.evaluator.cache_ui import cache_ui_full_layout_create, cache_ui_full_layout_update
from maya.app.evaluationToolkit.evaluation_toolkit_utilities import BUTTON_WIDTH, COLUMN_SPACING, ROW_SPACING, section_layout
from maya.app.evaluationToolkit.evaluation_toolkit_utilities import EvaluationToolkitSection, set_gpu_override_active

__all__ = ['EvaluationToolkitSectionCaching']

#======================================================================
SHOW_HYBRID_CACHE_GPU = False

#======================================================================
# Supported caching setups.
# Each setup in the list is a tuple with the following elements:
# - The string that should be displayed for this mode.
# - The creation parameters of the rules defining this mode
# - The description of this mode.
#
# If the description is an empty list, it means that caching is disabled.
# If the description is None, it means that caching has custom
# caching configuration, i.e. it was tweaked manually and does not match one
# of the presets.
DEBUG_CACHE_MODES = [
    (maya.stringTable['y_EvaluationToolkitSectionCaching.kApplyDebugCache' ],
     None,
     maya.stringTable['y_EvaluationToolkitSectionCaching.kApplyDebugCacheAnnotation' ]
     ),
    (maya.stringTable['y_EvaluationToolkitSectionCaching.kCachePreference' ],
     [],
     maya.stringTable['y_EvaluationToolkitSectionCaching.kCachePreferenceAnnotation' ]
     ),
    (maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheDBShapes' ],
     CACHE_STANDARD_MODE_EVAL_SHAPES,
     maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheDBShapesAnnotation' ]
     ),
    (maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheVP2AllNoFallback' ],
     CACHE_STANDARD_MODE_VP2_SW_NO_FALLBACK,
     maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheVP2AllNoFallbackAnnotation' ]
     ),
    (maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheVP2AllHWNoFallback' ],
     CACHE_STANDARD_MODE_VP2_HW_NO_FALLBACK,
     maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheVP2AllHWNoFallbackAnnotation' ]
     ),
    (maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheUnsupported' ],
     None,
     maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheUnsupportedAnnotation' ]
     ),
    ]

#======================================================================
def _menu(menu_grp_widget):
    '''Helper to convert a menu group widget name to its child menu name'''
    return menu_grp_widget + '|OptionMenu'

#======================================================================
class EvaluationToolkitSectionCaching(EvaluationToolkitSection, CacheUiBase):
    '''
    Class providing support for UI and functionality of the evaluation toolkit cachign section.

    :member ui_key: Unique identifier for this UI object. Used for client notification in CachePreferences()
    :member deformer_mgr: Local DeformerEvaluatorManager for easy access to evaluator parameters
    :member cache_mgr: Local CacheEvaluatorManager for easy access to evaluator parameters

    :member layout_root: Root control for everything in this section
    :member layout_actions: Layout control for the section containing action buttons
    :member layout_memory: Layout control for the memory management section
    :member layout_safe_mode: Layout control for the safe mode section
    :member menu_debug_cache_mode_list: Menu widget for debugging cache mode list
    :member checkbox_hybrid_gpu_cache: Checkbox widget for Hybrid GPU cache selection
    :member checkbox_flush_sync: Checkbox widget for whether flushing is synchronous
    :member widget_memory_usage: Text widget showing memory used
    :member widget_memory_available: Text widget showing memory available
    :member mode_change_job: scriptJob ID for the customEvaluatorChanged callback
    '''
    #----------------------------------------------------------------------
    def __init__(self, title, start_closed):
        '''
        Set up the framework for the caching tools
        :param title: Name of the main caching section
        :param start_closed: True means the section should be initially closed when the UI window is created
        '''
        CacheUiBase.__init__(self)

        # Unique ID used for client notifications from CachePreferences()
        self.ui_key = 'cache_section_in_toolkit'

        # Get a few managers so that evaluator states can be easily manipulated
        self.deformer_mgr = DeformerEvaluatorManager()
        self.cache_mgr = CacheEvaluatorManager()

        self.layout_root = cmds.frameLayout( label=title, **section_layout(start_closed) )

        with LayoutManager( self.layout_root ):
            # Values driving preferences
            cache_ui_full_layout_create( 'evaluationToolkit' )

            # Custom caching modes (not supported in preferences)
            self.menu_debug_cache_mode_list = cmds.optionMenuGrp( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kCacheMode' ]
                                                                  , changeCommand=callback_tool(self, self.callback_apply_debug_cache_mode)
                                                                  )
            for i,mode in enumerate(DEBUG_CACHE_MODES):
                label = mode[0]
                if i == 0:
                    label = label.format('') # Starts with no prior selection
                else:
                    label = u'{}. {}'.format(i, label) # Others are numbered
                menuItem = cmds.menuItem(parent=_menu(self.menu_debug_cache_mode_list), label=label, annotation=mode[2])
                if i == 0:
                    self.widget_last_debug_cache_mode = menuItem

            # Dev-only hybrid Caching-GPU mode
            if SHOW_HYBRID_CACHE_GPU:
                self.checkbox_hybrid_gpu_cache = cmds.checkBoxGrp( label=''
                                                                 , label1=maya.stringTable['y_EvaluationToolkitSectionCaching.kHybridGPUCache' ]
                                                                 , changeCommand=callback_tool(self, self.callback_update_hybrid_gpu_cache)
                                                                 )
            else:
                self.checkbox_hybrid_gpu_cache = None

            # Flush synchronization
            self.checkbox_flush_sync = cmds.checkBoxGrp( label=''
                                                       , label1=maya.stringTable['y_EvaluationToolkitSectionCaching.kFlushCacheSynchronously' ]
                                                       , annotation=maya.stringTable['y_EvaluationToolkitSectionCaching.kFlushCacheSynchronouslyAnnotation' ]
                                                       , changeCommand=callback_tool(self, self.callback_update_flush_cache_synchronously)
                                                       )

            # Buttons to perform one-shot operations on the cache
            self.layout_actions = cmds.rowLayout( numberOfColumns=5
                                                , columnWidth5=(COLUMN_SPACING,BUTTON_WIDTH+COLUMN_SPACING,BUTTON_WIDTH+COLUMN_SPACING,BUTTON_WIDTH+COLUMN_SPACING,COLUMN_SPACING)
                                                )
            with LayoutManager( self.layout_actions ):
                cmds.separator( style='none', width=COLUMN_SPACING )
                cmds.button( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kInvalidateCache' ], width=BUTTON_WIDTH, command=callback_tool(self, self.callback_invalidate_cache) )
                cmds.button( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kFlushCache' ],           width=BUTTON_WIDTH, command=callback_tool(self, self.callback_flush_cache) )
                self.button_trigger_rebuild = cmds.button( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kRebuildCache' ], width=BUTTON_WIDTH, command=callback_tool(self, self.callback_rebuild_cache) )
                cmds.separator( style='none', width=COLUMN_SPACING )

            self.layout_memory = cmds.frameLayout( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kMemoryManagement' ], **section_layout(False) )
            with LayoutManager( self.layout_memory ):

                with LayoutManager( cmds.rowLayout( numberOfColumns=2
                                                  , adjustableColumn=2
                                                  , columnAlign=[(1, 'center'), (2, 'left')]
                                                  , columnWidth=[(1, BUTTON_WIDTH + COLUMN_SPACING*2)]
                                                  ) ):

                    cmds.button(label=maya.stringTable['y_EvaluationToolkitSectionCaching.kUpdateMemory' ], width=BUTTON_WIDTH, command=callback_tool(self, self.callback_update_memory))

                    with LayoutManager( cmds.rowColumnLayout( numberOfColumns=2
                                                            , adjustableColumn=2
                                                            , columnAlign=[(1, 'right'), (2, 'left')]
                                                            , columnSpacing=[(1, COLUMN_SPACING), (2, COLUMN_SPACING)]
                                                            , rowSpacing=[(1, ROW_SPACING), (2, ROW_SPACING)]
                                                            ) ):
                        cmds.text( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kMemoryUsage' ] )
                        self.widget_memory_usage = cmds.text(label='')
                        cmds.text( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kMemoryAvailable' ] )
                        self.widget_memory_available = cmds.text(label='')

            self.layout_safe_mode = cmds.frameLayout( label=maya.stringTable['y_EvaluationToolkitSectionCaching.SafeMode' ], **section_layout(False) )
            with LayoutManager( self.layout_safe_mode ):
                with LayoutManager( cmds.rowColumnLayout( numberOfColumns=2
                                                        , columnAlign=[(1, 'right'), (2, 'center')]
                                                        , columnAttach=[(1, 'right', 0), (2, 'both', 0)]
                                                        , columnSpacing=[(1,COLUMN_SPACING), (2,COLUMN_SPACING)] ) ):
                    cmds.text(label=maya.stringTable['y_EvaluationToolkitSectionCaching.kSafeModeMessages' ])
                    cmds.button( label=maya.stringTable['y_EvaluationToolkitSectionCaching.kLabelPrint' ] , width=BUTTON_WIDTH , command=callback_tool(self, self.callback_print_safe_mode_messages) )

        CachePreferenceEnabled().add_client( self, callback_tool(self, self.callback_update_enabled) )
        CachePreferenceFillType().add_client( self, callback_tool(self, self.callback_update_fill_type) )
        self.monitor_window()
        self.plugin_state_change( new_state=self.cache_mgr.plugin_loaded )
        self.mode_change_job = cmds.scriptJob(event=('customEvaluatorChanged', callback_tool(self, self.callback_update_enabled)))

        cmds.scriptJob( uiDeleted=(self.layout_root, callback_tool(self, self.callback_ui_deleted)) )

        # Make sure the state information reflects the current values
        self.update_ui()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_apply_debug_cache_mode(tool):
        '''
        Callback invoked when one of the custom cache modes was selected. This does not
        affect the mode preferences, it just changes the current caching mode.
        '''
        selected_index = cmds.optionMenu(_menu(tool.menu_debug_cache_mode_list), query=True, select=True) - 1
        values_to_set = DEBUG_CACHE_MODES[selected_index][1]
        if values_to_set is not None:
            if values_to_set == []:
                CachePreferenceMode().set_state_from_preference()
            else:
                tool.cache_mgr.cache_mode = (values_to_set)
            # Select the "information" item again to let the user know they can choose again
            cmds.optionMenu(_menu(tool.menu_debug_cache_mode_list), edit=True, select=1)
            # Add the previous choice to the menu, for reference
            new_label = DEBUG_CACHE_MODES[0][0].format( maya.stringTable['y_EvaluationToolkitSectionCaching.kLastDebugModeChoice'].format(selected_index) )
            cmds.menuItem(tool.widget_last_debug_cache_mode, edit=True, label=new_label)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_hybrid_gpu_cache(tool):
        '''Invoked when the Hybrid GPU cache checkbox is pressed'''
        assert SHOW_HYBRID_CACHE_GPU
        hybrid_enabled = cmds.checkBoxGrp(tool.checkbox_hybrid_gpu_cache, query=True, value1=True)

        cache_loaded = tool.cache_mgr.plugin_loaded
        gpu_loaded = tool.deformer_mgr.plugin_loaded

        # Load the plugins and activate the deformer evaluator when turning on hybrid mode.
        # We need the plugins loaded to be able to change their priority.
        # The plugins load defaulting to "hybrid-off" so no need to load things if hybrid
        # setting is off.
        if hybrid_enabled:
            tool.cache_mgr.plugin_loaded = True
            set_gpu_override_active(True) # might be loaded but not active.  we want active.
            gpu_loaded = True

        if cache_loaded and gpu_loaded:
            # For hybrid mode set the deformer evaluator priority to 10 above the cache evaluator.  For
            # non-hybrid mode set it to 10 below.
            priority = tool.cache_mgr.priority
            priority = (priority + 10) if hybrid_enabled else (priority - 10)
            tool.deformer_mgr.priority = priority

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_flush_cache_synchronously(tool):
        '''Invoked when the checkbox for how to flush the cache is pressed'''
        tool.cache_mgr.flush_sync = cmds.checkBoxGrp(tool.checkbox_flush_sync, query=True, value1=True)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_invalidate_cache(tool):
        '''Invoked when the "invalidate cache" button is pressed'''
        tool.cache_mgr.invalidate_cache()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_flush_cache(tool):
        '''Invoked when the "flush cache" button is pressed'''
        tool.cache_mgr.flush_cache()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_rebuild_cache(tool):
        '''Invoked when the "trigger rebuild" button is pressed'''
        # We should not wait for cache when triggering a rebuild
        # since we should be in async mode.
        if CachePreferenceFillType().get_value() != 'syncOnly':
            tool.cache_mgr.rebuild_cache( False )
        else:
            cmds.warning( maya.stringTable['y_EvaluationToolkitSectionCaching.kNoRebuildInSync' ] )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_memory(tool):
        '''Invoked when the "update memory" button is pressed.  Recalculates and displays current memory usage.'''
        physical_memory = cmds.memory(asFloat=True, gigaByte=True, physicalMemory=True)
        virtual_memory = cmds.memory(asFloat=True, gigaByte=True, heapMemory=True)
        # this needs to get updated to include the heap offset value, right now the evaluation toolkit value is substantially different from what we see in the HUD
        percent = virtual_memory / physical_memory * 100

        cmds.text( tool.widget_memory_usage, edit=True, label='{0:5.1f} GB ({1:5.1f}%)'.format(virtual_memory,percent) )
        cmds.text( tool.widget_memory_available, edit=True, label='{0:5.1f} GB'.format(physical_memory) )

        print 'Virtual memory allocated by Maya : {0:5.1f} GB'.format( virtual_memory )
        print 'Physical memory on the system    : {0:5.1f} GB'.format( physical_memory )
        print '                                     ------'
        print '                                   {0:5.1f} %'.format( percent )

        if CachePreferenceHud().get_value():
            # Trigger viewport refresh to refresh the HUD.
            cmds.refresh()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_print_safe_mode_messages(tool):
        '''Invoked when the "print safe mode messages" button is pressed'''
        messages = tool.cache_mgr.safe_mode_messages
        if messages is not None:
            print maya.stringTable['y_EvaluationToolkitSectionCaching.kSafeModeMessagesAre' ]
            print messages
        else:
            print maya.stringTable['y_EvaluationToolkitSectionCaching.kSafeModeNotTriggered' ]

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        assert self.layout_root is not None
        cmds.frameLayout( self.layout_root, edit=True, visible=new_state )

    #----------------------------------------------------------------------
    def update_ui(self):
        '''Update the UI values to match the current external states'''
        # If the plug-in wasn't loaded then no state information can be retrieved so disable everything
        if not self.cache_mgr.plugin_loaded:
            return

        cache_ui_full_layout_update( 'evaluationToolkit' )

        if SHOW_HYBRID_CACHE_GPU:
            # Hybrid mode is assumed off if either of the plugins are not loaded yet.  Activating
            # it will load the plugins if they are missing.
            hybrid_enabled = False
            try:
                hybrid_enabled = self.cache_mgr.priority < self.deformer_mgr.priority
            except ValueError:
                # At least one of the evaluators was not active
                pass
            cmds.checkBoxGrp(self.checkbox_hybrid_gpu_cache, edit=True, value1=hybrid_enabled)

        cmds.checkBoxGrp( self.checkbox_flush_sync, edit=True, value1=self.cache_mgr.flush_sync )

        self.callback_update_fill_type( tool=self )
        self.callback_update_enabled( tool=self )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_enabled(tool):
        '''
        Callback to refresh the enabled state of the UI to match the cache evaluator state.
        '''
        # If the evaluator is disabled then the buttons that perform operations on it should also be disabled
        ui_enabled = cache_ui_enabled()
        cmds.frameLayout( tool.layout_memory, edit=True, enable=ui_enabled )
        cmds.frameLayout( tool.layout_safe_mode, edit=True, enable=ui_enabled )
        cmds.rowLayout( tool.layout_actions, edit=True, enable=ui_enabled )
        cmds.optionMenuGrp( tool.menu_debug_cache_mode_list, edit=True, enable=ui_enabled )
        if tool.checkbox_hybrid_gpu_cache is not None:
            cmds.checkBoxGrp( tool.checkbox_hybrid_gpu_cache, edit=True, enable=ui_enabled )
        cmds.checkBoxGrp( tool.checkbox_flush_sync, edit=True, enable=ui_enabled )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_fill_type(tool):
        '''
        Callback to refresh the enabled state of the "Rebuild Cache" button to match the cache evaluator fill type.
        '''
        cmds.button( tool.button_trigger_rebuild, edit=True, enable=CachePreferenceFillType().get_value() != 'syncOnly' )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_deleted(tool):
        '''Callback invoked when the UI was deleted. Clear out all of the local data.'''
        CachePreferenceFillType().remove_client( tool )
        CachePreferenceEnabled().remove_client( tool )

        tool.layout_root = None
        tool.layout_actions = None
        tool.layout_memory = None
        tool.layout_safe_mode = None
        tool.deformer_mgr = None
        tool.cache_mgr = None
        tool.menu_debug_cache_mode_list = None
        tool.checkbox_hybrid_gpu_cache = None
        tool.checkbox_flush_sync = None
        tool.widget_memory_usage = None
        tool.widget_memory_available = None

        tool.deformer_mgr = None
        tool.cache_mgr = None

        if tool.mode_change_job is not None:
            cmds.scriptJob( kill=tool.mode_change_job )
            tool.mode_change_job = None
# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
