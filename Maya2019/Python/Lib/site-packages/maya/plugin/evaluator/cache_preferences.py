import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Collection of classes embodying the implementation of Cached Playback preferences.

The main interface is the CachePreferences object, a singleton object that manages
all of the preferences, as well as the synchronization of those preferences between
the optionVars that hold them and the commands that implement them.

All of the preferences are driven by the helper classes derived from OptionVar.

The name of the optionVars each controls is their static ov_id member.

For access to the UI that controls the preferences see cache_ui.py
'''
from functools import partial
import maya.cmds as cmds
from maya.common.ui import callback_tool
from maya.common.utils import Singleton
from maya.debug.DebugTrace import DebugTrace
from maya.debug.PlaybackManager import PlaybackManager
from maya.app.prefs.OptionVar import OptionVar, OPTION_VAR_TYPE_BOOL
from maya.app.prefs.OptionVarManager import OptionVarManager
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager, CACHE_STANDARD_MODE_VP2_HW, CACHE_STANDARD_MODE_VP2_SW, CACHE_STANDARD_MODE_EVAL, CACHE_PLUGIN_NAME
from maya.plugin.evaluator.cache_optionvar_states import CachePreferenceHud, CachePreferenceResourceGuard, CachePreferenceMemoryThreshold, CachePreferenceDiscardFramesOutOfRange
from maya.plugin.evaluator.cache_optionvar_states import CachePreferenceShowCacheStatus, CachePreferenceShowWarningFrames, CachePreferenceShowWarningMessages
from maya.plugin.evaluator.cache_optionvar_states import CachePreferenceShowInvalidatedFrames, CachePreferenceShowSubframes, CachePreferenceTimesliderBarHeight
from maya.plugin.evaluator.cache_optionvar_states import CachePreferenceTimesliderBarSpacing, CachePreferenceTimesliderBarPosition
from maya.plugin.evaluator.CacheWarningMessages import CacheWarningMessages

__all__ = [ 'cache_preferences_initialize'
          , 'cache_ui_enabled'
          , 'CachePreferences'
          , 'CachePreferenceEnabled'
          , 'CachePreferenceMode'
          , 'CachePreferenceFillType'
          , 'CachePreferenceFillDirection'
          , 'CachePreferencePreventFrameSkipping'
          ]

#======================================================================
def _aggregate_enum_info(enum_data):
    '''
    Take the enum_info and aggregate the list of enum values and their descriptions into
    an overall description string.
    :param enum_data: List of lists for allowed enum values and their associated text.
    :return: Aggregated string consisting of one line per enum value and its description.
    '''
    aggregate = ''
    # Initialize the aggregate tooltips and reverse index lists used by the UI.
    for enum_info in enum_data:
        aggregate += u'\n{}: {}'.format( enum_info[CachePreferences.KEY_ENUM_NAME], enum_info[CachePreferences.KEY_ENUM_INFO] )
    return aggregate

#======================================================================
class CachePreferenceEnabled(OptionVar):
    '''
    Class containing the information for the "caching playback enabled" preference
    '''
    __metaclass__ = Singleton
    ov_id = 'cachedPlaybackEnable' # optionVar name and unique preference ID

    def __init__(self):
        ''' Initialize the preference interface '''
        super( CachePreferenceEnabled, self ).__init__(self.ov_id, OPTION_VAR_TYPE_BOOL, True)
        self.title = maya.stringTable['y_cache_preferences.kCachedPlaybackEnableText' ]
        self.info  = maya.stringTable['y_cache_preferences.kCachedPlaybackEnableTip'  ]

    def read_preference_from_state(self):
        '''Read the new value of the optionVar from the scene state'''
        self.set_value( CachePreferences().cache_mgr.enabled )

    def set_state_from_preference(self):
        '''Apply the current value of the optionVar to the scene state'''
        # Revert to previous value after attempting to sync to illegal value
        CachePreferences().cache_mgr.enabled = self.get_value()
        if not self.get_value():
            CachePreferences().cache_mgr.flush_cache()

#======================================================================
class CachePreferencePreventFrameSkipping(OptionVar):
    '''
    Class containing the information for the "caching playback prevent frame skipping" preference
    '''
    __metaclass__ = Singleton
    ov_id = 'cachedPlaybackPreventFrameSkipping' # optionVar name and unique preference ID

    def __init__(self):
        ''' Initialize the preference interface '''
        super( CachePreferencePreventFrameSkipping, self ).__init__(self.ov_id, OPTION_VAR_TYPE_BOOL, True)
        self.title = maya.stringTable['y_cache_preferences.kPreventFrameSkippingText' ]
        self.info  = maya.stringTable['y_cache_preferences.kPreventFrameSkippingTip'  ]

    def read_preference_from_state(self):
        '''Read the new value of the optionVar from the scene state'''
        self.set_value( CachePreferences().cache_mgr.prevent_frame_skipping )

    def set_state_from_preference(self):
        '''Apply the current value of the optionVar to the scene state'''
        CachePreferences().cache_mgr.prevent_frame_skipping = self.get_value()

#======================================================================
class CachePreferenceMode(OptionVar):
    '''
    Class containing the information for the "caching playback mode" preference
    '''
    __metaclass__ = Singleton
    ov_id = 'cachedPlaybackMode' # optionVar name and unique preference ID

    # This could be a dictionary but it's important to preserve the ordering so it's a list of lists.
    DATA = [ [ 'evaluationCache'  , maya.stringTable['y_cache_preferences.kCacheModeEval'    ]
                                  , maya.stringTable['y_cache_preferences.kCacheModeEvalTip' ]
                                  , CACHE_STANDARD_MODE_EVAL
                                  ]
           , [ 'viewportSoftware' , maya.stringTable['y_cache_preferences.kCacheModeVpS'    ]
                                  , maya.stringTable['y_cache_preferences.kCacheModeVpSTip' ]
                                  , CACHE_STANDARD_MODE_VP2_SW
                                  ]
           , [ 'viewportHardware' , maya.stringTable['y_cache_preferences.kCacheModeVpH'    ]
                                  , maya.stringTable['y_cache_preferences.kCacheModeVpHTip' ]
                                  , CACHE_STANDARD_MODE_VP2_HW
                                  ]
           ]
    # The first element of the list is treated as a dictionary key
    KEYS = [data[0] for data in DATA]

    def __init__(self):
        ''' Initialize the preference interface '''
        super( CachePreferenceMode, self ).__init__(self.ov_id, CachePreferenceMode.KEYS, CachePreferenceMode.KEYS[0] )
        self.title = maya.stringTable['y_cache_preferences.kPreferredCacheModeText' ]
        self.info  = maya.stringTable['y_cache_preferences.kPreferredCacheModeTip'  ] + _aggregate_enum_info(CachePreferenceMode.DATA)
        self.lookup = { mode : i+1 for i, mode in enumerate(CachePreferenceMode.KEYS) }

    def find_index(self, value):
        '''Find the index in the DATA list of the given enum value'''
        return self.lookup[value]

    def read_preference_from_state(self):
        '''Read the new value of the optionVar from the scene state'''
        cache_mode = CachePreferences().cache_mgr.cache_mode
        # Only the standard hardcoded caching modes are recognized. If the user changes to
        # some other custom caching mode the preferences will not change
        for enum_data in CachePreferenceMode.DATA:
            if cache_mode == enum_data[CachePreferences.KEY_ENUM_DATA]:
                self.set_value( enum_data[CachePreferences.KEY_ENUM_ID] )

    def set_state_from_preference(self):
        '''
        Apply the current value of the optionVar to the scene state.
        The preference is an enum name while the actual caching mode is a set of rules.
        Do the conversion, reverting to the original values if the preference didn't
        point to a legal type.
        '''

        # Only restore the state if the preference has changed
        new_mode_id = self.get_value()
        new_mode = CachePreferenceMode.DATA[self.lookup[new_mode_id]-1][CachePreferences.KEY_ENUM_DATA]
        CachePreferences().cache_mgr.cache_mode = new_mode

#======================================================================
class CachePreferenceFillType(OptionVar):
    '''
    Class containing the information for the "caching playback fill type" preference
    '''
    __metaclass__ = Singleton
    ov_id = 'cachedPlaybackFillType' # optionVar name and unique preference ID

    # This could be a dictionary but it's important to preserve the ordering so it's a list of lists.
    DATA = [ [ 'syncAsync' , maya.stringTable['y_cache_preferences.kCacheFillBoth'    ]
                           , maya.stringTable['y_cache_preferences.kCacheFillBothTip' ]
                           ]
           , [ 'syncOnly'  , maya.stringTable['y_cache_preferences.kCacheFillPlay'    ]
                           , maya.stringTable['y_cache_preferences.kCacheFillPlayTip' ]
                           ]
           , [ 'asyncOnly' , maya.stringTable['y_cache_preferences.kCacheFillBg'      ]
                           , maya.stringTable['y_cache_preferences.kCacheFillBgTip'   ]
                           ]
           ]
    # The first element of the list is treated as a dictionary key
    KEYS = [data[0] for data in DATA]

    def __init__(self):
        ''' Initialize the preference interface '''
        super( CachePreferenceFillType, self ).__init__(self.ov_id, CachePreferenceFillType.KEYS, CachePreferenceFillType.KEYS[0] )
        self.title = maya.stringTable['y_cache_preferences.kCacheFillTypeText' ]
        self.info  = maya.stringTable['y_cache_preferences.kCacheFillTypeTip'  ] + _aggregate_enum_info(CachePreferenceFillType.DATA)
        self.lookup = { fill_type : i+1 for i, fill_type in enumerate(CachePreferenceFillType.KEYS) }

    def find_index(self, value):
        '''Find the index in the DATA list of the given enum value'''
        return self.lookup[value]

    def read_preference_from_state(self):
        '''Read the new value of the optionVar from the scene state'''
        self.set_value( CachePreferences().cache_mgr.fill_mode )

    def set_state_from_preference(self):
        '''Apply the current value of the optionVar to the scene state'''
        new_fill_type = self.get_value()
        CachePreferences().cache_mgr.fill_mode = new_fill_type

#======================================================================
class CachePreferenceFillDirection(OptionVar):
    '''
    Class containing the information for the "caching playback fill direction" preference
    '''
    __metaclass__ = Singleton
    ov_id = 'cachedPlaybackFillDirection' # optionVar name and unique preference ID

    # This could be a dictionary but it's important to preserve the ordering so it's a list of lists.
    DATA = [ [ 'bidirectional'    , maya.stringTable['y_cache_preferences.kBgFillFwdBwd'          ]
                                  , maya.stringTable['y_cache_preferences.kBgFillFwdBwdTip'       ]
                                  ]
           , [ 'forward'          , maya.stringTable['y_cache_preferences.kBgFillFwd'             ]
                                  , maya.stringTable['y_cache_preferences.kBgFillFwdTip'          ]
                                  ]
           , [ 'backward'         , maya.stringTable['y_cache_preferences.kBgFillBwd'             ]
                                  , maya.stringTable['y_cache_preferences.kBgFillBwdTip'          ]
                                  ]
           , [ 'forwardFromBegin' , maya.stringTable['y_cache_preferences.kBgFillFwdFromStart'    ]
                                  , maya.stringTable['y_cache_preferences.kBgFillFwdFromStartTip' ]
                                  ]
           ]

    # The first element of the list is treated as a dictionary key
    KEYS = [data[0] for data in DATA]

    def __init__(self):
        ''' Initialize the preference interface '''
        super( CachePreferenceFillDirection, self ).__init__(self.ov_id, CachePreferenceFillDirection.KEYS, CachePreferenceFillDirection.KEYS[0] )
        self.title = maya.stringTable['y_cache_preferences.kCacheFillDirectionText' ]
        self.info  = maya.stringTable['y_cache_preferences.kCacheFillDirectionTip'  ] + _aggregate_enum_info(CachePreferenceFillDirection.DATA)
        self.lookup = { fill_direction : i+1 for i, fill_direction in enumerate(CachePreferenceFillDirection.KEYS) }

    def find_index(self, value):
        '''Find the index in the DATA list of the given enum value'''
        return self.lookup[value]

    def read_preference_from_state(self):
        '''Read the new value of the optionVar from the scene state'''
        self.set_value( CachePreferences().cache_mgr.fill_order )

    def set_state_from_preference(self):
        '''Apply the current value of the optionVar to the scene state'''
        new_fill_direction = self.get_value()
        CachePreferences().cache_mgr.fill_order = new_fill_direction

#======================================================================
class CachePreferences(object):
    '''
    Class that initializes and aggregates all of the caching playback preferences,
    as well as supplying an interface for updating the preference values (the
    CacheEvaluatorManager instance)

    As certain data, notably the caching preferences change event, relies on the
    plug-in being loaded this class also monitors for it being loaded and unloaded
    in order to modify its scriptJob callbacks.

    :member option_vars:     Dictionary of optionVars that implement caching preferences
                             KEY=optionVar name, VALUE=OptionVar object controlling it
    :member pref_change_job: scriptJob ID for the cachingPreferencesChanged event
    :member monitor_load:    True if monitoring for plug-in load events
    :member monitor_unload:  True if monitoring for plug-in unload events
    :member plugin_clients:  Dictionary of clients listening for plug-in load/unload
                             KEY=ID of client, VALUE=Function to call when plug-in is loaded/unloaded
                             This is preferred over having every little bit of UI have its
                             own plug-in load/unload callbacks because it manages which events
                             to monitor and provides verification of the plug-in changing all in
                             one place.
    :member cache_mgr:       Instance of a CacheEvaluationManager() that can be used to easily
                             handle state changes of the cache evaluator
    :member cache_warnings:  Instance of a CacheWarningMessages() used to manage scene configuration warnings
    '''
    __metaclass__ = Singleton

    #----------------------------------------------------------------------
    # Convenience index into the 'type' data below when the type is an enum list
    KEY_ENUM_ID    = 0
    KEY_ENUM_NAME  = 1
    KEY_ENUM_INFO  = 2
    KEY_ENUM_DATA  = 3

    #----------------------------------------------------------------------
    def add_preference(self, option_var):
        ''' Add a new OptionVar to be managed by the preferences class '''
        OptionVarManager.manage( option_var )
        self.option_vars[option_var.name] = option_var

    #----------------------------------------------------------------------
    @staticmethod
    def callback_plugin_loaded(plugin_name):
        '''
        Callback invoked whenever a plug-in is loaded. Used to manage the
        scriptJob that monitors the cachingPreferencesChanged event since
        it is controlled by the plug-in.
        :param plugin_name: Name of the plug-in that was loaded. Only 'cache' is of interest.
        '''
        if plugin_name == CACHE_PLUGIN_NAME:
            CachePreferences().monitor_state_changes( True )
            CachePreferences().monitor_load_plugin( False )
            CachePreferences().monitor_unload_plugin( True )
            # Make sure the state matches the current preferences
            for option_var in CachePreferences().option_vars.values():
                option_var.do_set_state_from_preference()

            # Notify clients that the plug-in was loaded.
            CachePreferences().update_plugin_clients( True )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_plugin_unloaded(plugin_name):
        '''
        Callback invoked whenever a plug-in is unloaded. Used to manage the
        scriptJob that monitors the cachingPreferencesChanged event since
        it is controlled by the plug-in.
        :param plugin_name: Name of the plug-in that was unloaded. Only 'cache' is of interest.
        '''
        if plugin_name == CACHE_PLUGIN_NAME:
            CachePreferences().monitor_unload_plugin( False )
            CachePreferences().monitor_state_changes( False )
            CachePreferences().monitor_load_plugin( True )

            # Notify clients that the plug-in was unloaded.
            CachePreferences().update_plugin_clients( False )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_state_changed(tool):
        '''
        Callback invoked when any of the state information on the cache evaluator affecting
        the preferences has changed. Only a generic event is triggered so all of the optionVars
        need to be updated even though only one is changing.
        '''
        for option_var in tool.option_vars.values():
            option_var.do_read_preference_from_state()
            option_var.update_clients()

    #----------------------------------------------------------------------
    def monitor_load_plugin(self, enable_monitor):
        '''
        Enable or disable monitoring of the loadPlugin command
        :param enable_monitor: Should loadPlugin calls be monitored?
        '''
        if enable_monitor:
            if not self.monitor_load:
                cmds.loadPlugin( addCallback=CachePreferences.callback_plugin_loaded )
                self.monitor_load = True
        elif self.monitor_load:
            cmds.loadPlugin( removeCallback=CachePreferences.callback_plugin_loaded )
            self.monitor_load = False

    #----------------------------------------------------------------------
    def monitor_unload_plugin(self, enable_monitor):
        '''
        Enable or disable monitoring of the unloadPlugin command
        :param enable_monitor: Should unloadPlugin calls be monitored?
        '''
        if enable_monitor:
            if not self.monitor_unload:
                cmds.unloadPlugin( addCallback=CachePreferences.callback_plugin_unloaded )
                self.monitor_unload = True
        elif self.monitor_unload:
            cmds.unloadPlugin( removeCallback=CachePreferences.callback_plugin_unloaded )
            self.monitor_unload = False

    #----------------------------------------------------------------------
    def monitor_state_changes(self, enable_listening):
        '''
        Set the state of monitoring for preference changes. Preference changes can
        only be monitored when the plug-in is loaded so confirm it's possible when
        enabling.

        :param enable_listening: True if preference changes should be monitored.
        '''
        if enable_listening:
            script_job_events = cmds.scriptJob( listEvents=True ) or []
            if 'cachingPreferencesChanged' in script_job_events:
                self.pref_change_job = cmds.scriptJob(event=('cachingPreferencesChanged', callback_tool(self, self.callback_state_changed)))
        elif self.pref_change_job is not None:
            cmds.scriptJob( kill=self.pref_change_job )
            self.pref_change_job = None

    #----------------------------------------------------------------------
    def update_plugin_clients(self, new_state):
        '''
        Update all of the clients listening to changes in the plug-in load/unload state
        '''
        for (client, plugin_callback) in self.plugin_clients.values():
            partial( plugin_callback, tool=client, new_state=new_state )()

    #----------------------------------------------------------------------
    def add_plugin_client(self, client, client_callback):
        '''
        Add a new client function to be called when the plug-in state changes
        :param client: Name of client owning the callback
        :param client_callback: Function to be called when the plug-in state changes.
        '''
        assert client.ui_key not in self.plugin_clients
        self.plugin_clients[client.ui_key] = (client, client_callback)

    #----------------------------------------------------------------------
    def remove_plugin_client(self, client):
        '''
        Remove all clients of the plug-in state change
        '''
        assert client.ui_key in self.plugin_clients
        del self.plugin_clients[client.ui_key]

    #----------------------------------------------------------------------
    @staticmethod
    def callback_flush_frames_out_of_range(tool):
        ''' Invoked when the frame range flush preference changes - decides if the cache should flush frames out of the new range '''
        if tool.cache_mgr.plugin_loaded and CachePreferenceDiscardFramesOutOfRange().get_value():
            play_mgr = PlaybackManager()
            tool.cache_mgr.flush_cache_range( play_mgr.minTime, play_mgr.maxTime, False )
            # If the HUD is active then the values in it will change and need updating
            if CachePreferenceHud().get_value():
                cmds.refresh()

    #----------------------------------------------------------------------
    def __init__(self):
        ''' Create all of the OptionVar objects used to manage the preferences.  '''
        self.option_vars = {}
        self.pref_change_job = None
        self.monitor_load = False
        self.monitor_unload = False
        self.plugin_clients = {}

        # No need to save and restore the state here since the whole point of this class is to change it
        self.cache_mgr = CacheEvaluatorManager()

        self.cache_warnings = CacheWarningMessages()

        # Add each of the preferences to the internal list
        try:
            self.add_preference( CachePreferenceEnabled() )
            self.add_preference( CachePreferencePreventFrameSkipping() )
            self.add_preference( CachePreferenceHud() )
            self.add_preference( CachePreferenceMode() )
            self.add_preference( CachePreferenceFillType() )
            self.add_preference( CachePreferenceFillDirection() )
            self.add_preference( CachePreferenceResourceGuard() )
            self.add_preference( CachePreferenceMemoryThreshold() )
            self.add_preference( CachePreferenceDiscardFramesOutOfRange() )
            self.add_preference( CachePreferenceShowCacheStatus() )
            self.add_preference( CachePreferenceShowWarningFrames() )
            self.add_preference( CachePreferenceShowWarningMessages() )
            self.add_preference( CachePreferenceShowInvalidatedFrames() )
            self.add_preference( CachePreferenceShowSubframes() )
            self.add_preference( CachePreferenceTimesliderBarHeight() )
            self.add_preference( CachePreferenceTimesliderBarSpacing() )
            self.add_preference( CachePreferenceTimesliderBarPosition() )
        except Exception, ex:
            pass

        # The C++ code handles listening to playback range changes since it has to coordinate more
        # information. This callback will handle changes to the discard state.
        CachePreferenceDiscardFramesOutOfRange().add_client( self, callback_tool(self, self.callback_flush_frames_out_of_range) )

        if self.cache_mgr.plugin_loaded:
            self.monitor_unload_plugin( True )
            self.monitor_state_changes( True )
        else:
            self.monitor_load_plugin( True )

#======================================================================
def cache_ui_enabled():
    '''
    :return: False if any current condition requires disabling of the caching UI (caching disabled
    or EM evaluation not enabled)
    '''
    enabled = CachePreferenceEnabled().get_value() and cmds.evaluationManager( query=True, mode=True )[0] != 'off'
    return enabled

#======================================================================
def cache_preferences_initialize():
    '''
    Initialize all of the optionVar monitoring used by the cache preferences.
    This doesn't set up or read any optionVar values, it only creates the
    OptionVar classes required to manage the preferences.

    This function must be called on startup so that the management is in place
    before any commands or UI try to access them.
    '''
    # If there was already an existing singleton then no initialization is needed
    if Singleton.singleton_exists( CachePreferences ):
        return

    # Just creating an object will create the singleton that persists independently
    # from this code. It doesn't have to be referenced here.
    CachePreferences()

    # Ensure that the Maya state starts in agreement with the optionVar values
    OptionVarManager.set_state_from_preferences()

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
