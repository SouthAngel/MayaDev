'''
Module containing the code common to all of the CacheUiXXX caching UI element managers.
'''

import re
from functools import partial
import maya.cmds as cmds
from maya.common.ui import callback_tool
from maya.plugin.evaluator.cache_preferences import CachePreferences

RE_WINDOW_FROM_ELEMENT = re.compile(r'([^|]*)\|')

#======================================================================
class CacheUiBase(object):
    '''
    Base class providing common behaviour for all CacheUiXXX caching UI element manager classes.

    :member delete_window_jobs: A dictionary containing the currently active uiDeleted scriptJobs
                                KEY = Window being monitored for deletion
                                VALUE = (ID, COUNT)
                                    ID    = scriptJob ID of the monitoring job
                                    COUNT = number of elements monitoring this particular window
    '''
    def __init__(self):
        '''Initialize local variables to be empty'''
        self.delete_window_jobs = {}

    #----------------------------------------------------------------------
    def monitor_window(self):
        '''
        Find the window above the current tool location and monitor for its deletion.
        This should be called whenever the UI code has setParent() to the proper location
        for inserting this UI element (even when it won't be inserted if the plug-in
        is unloaded since it has to monitor for plug-in loading events).
        :param element: UI element whose window is to be monitored
        '''
        # On the first UI element to be monitored add the plugin client. It will be removed after
        # the last UI element is removed since at that point there is no more UI to rebuild on load.
        if len(self.delete_window_jobs) == 0:
            CachePreferences().add_plugin_client( self, self.callback_update_plugin_state )

        window = self.find_window()
        if window is not None:
            if window not in self.delete_window_jobs:
                self.delete_window_jobs[window] = [cmds.scriptJob( uiDeleted=(window, callback_tool(self, partial(self.callback_window_deleted, window=window))) ), 1]
            else:
                self.delete_window_jobs[window][1] = self.delete_window_jobs[window][1] + 1

    #----------------------------------------------------------------------
    @staticmethod
    def find_window():
        '''
        :return: The name of the window in which the current UI context lives
        '''
        top_level = cmds.setParent( query=True, topLevel=True )
        window_match = RE_WINDOW_FROM_ELEMENT.match( top_level )
        if window_match is not None:
            window = window_match.group(1)
            # If you are in a tearoff menu you'll get NONE, so revert back to the top level item
            if window == 'NONE' or len(window) == 0:
                window = top_level
        else:
            # If the monitoring isn't being done within any particular UI context monitor the main window.
            # When this happens it will monitor for the duration of the session.
            window = 'MayaWindow'

        return window

    #----------------------------------------------------------------------
    @staticmethod
    def callback_window_deleted(tool, window):
        '''
        Callback invoked when the window of the UI element was destroyed
        :param tool: Reference to this object (self)
        :param window: Window that was just deleted
        '''
        # Remove the reference to the monitoring job once the event was triggered. If the number
        # of elements monitoring that window drops to 0 then kill the job and remove the monitor.
        if window in tool.delete_window_jobs:
            if tool.delete_window_jobs[window][1] == 1:
                del tool.delete_window_jobs[window]
            else:
                tool.delete_window_jobs[window][1] = tool.delete_window_jobs[window][1] - 1

        # Stop monitoring when there is no more active UI to rebuild
        if len(tool.delete_window_jobs) == 0:
            CachePreferences().remove_plugin_client( tool )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_plugin_state(tool, new_state):
        '''
        Callback to match the visibility of the UI elements with the plug-in loaded state.
        Derived classes must implement the plugin_state_change() methods to use this.
        :param tool: Reference to this object (self)
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        tool.plugin_state_change( new_state )

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
