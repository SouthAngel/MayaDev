import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of a subsection of UI that controls the caching elements that
are accessed through the preferences window. The same elements are used in
the evaluation toolkit so the code is location-agnostic.
'''
import maya.cmds as cmds
from maya.common.ui import LayoutManager
from maya.common.ui import callback_tool
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager
from maya.plugin.evaluator.cache_preferences import CachePreferences, CachePreferenceEnabled, CachePreferenceMode, CachePreferenceFillType, CachePreferenceFillDirection, CachePreferencePreventFrameSkipping
from maya.plugin.evaluator.cache_preferences import cache_preferences_initialize, cache_ui_enabled
from maya.plugin.evaluator.cache_optionvar_states import CachePreferenceResourceGuard, CachePreferenceMemoryThreshold, CachePreferenceDiscardFramesOutOfRange, CachePreferenceHud, CachePreferenceShowWarningMessages

__all__ = ['CacheUiFullLayout']

PREFS_MONITORED = [ CachePreferenceEnabled()
                  , CachePreferenceMode()
                  , CachePreferenceFillType()
                  , CachePreferenceFillDirection()
                  , CachePreferencePreventFrameSkipping()
                  , CachePreferenceResourceGuard()
                  , CachePreferenceMemoryThreshold()
                  , CachePreferenceDiscardFramesOutOfRange()
                  , CachePreferenceHud()
                  , CachePreferenceShowWarningMessages()
                  ]

#======================================================================
def _menu(menu_grp_widget):
    '''Helper to convert a menu group widget name to its child menu name'''
    return menu_grp_widget + '|OptionMenu'

#======================================================================
class CacheUiFullLayout(CacheUiBase):
    '''
    Class managing the cache preferences UI.

    :member preferences: CachePreferences object that handles updating the actual preference values
    :member ui_key: Unique identifier for this UI object. Used for smart deletion from CONTROLS dictionary
    :member widgets: Dictionary of widgets used by the UI (KEY=widget_id, VALUE=ui control name)
    :member mode_change_job: scriptJob ID for the customEvaluatorChanged callback
    '''
    #----------------------------------------------------------------------
    # UI objects holding the information on how the cache preferences are displayed and managed
    CONTROLS = {}

    #----------------------------------------------------------------------
    # Unique ID for the top level control
    # Must not be equal to any of the ID values on the CachePreferenceXXX classes
    ID_ROOT = 'cachedPlaybackMasterControl'

    # Unique ID for the warning icon controls
    # Must not be equal to any of the ID values on the CachePreferenceXXX classes or ID_ROOT
    ID_WARNING_PERCENT = 'cachedPlaybackRAMPercentWarningIcon'
    ID_WARNING_NO_LIMIT = 'cachedPlaybackRAMLimitWarningIcon'

    def __init__(self, ui_key):
        '''
        Initialize the cache preferences UI with a specific parent control.
        There is no reason to create this class without having a UI to be controlled
        so the setup of the actual UI elements is done right here in the initializer.
        :param ui_key: Unique identifier for this set of controls.
        '''
        super(CacheUiFullLayout, self).__init__()

        assert ui_key not in CacheUiFullLayout.CONTROLS, maya.stringTable['y_CacheUiFullLayout.kCachePrefControlExists' ].format( ui_key )
        CacheUiFullLayout.CONTROLS[ui_key] = self
        self.ui_key = ui_key

        # Make sure the prefs have already been set up
        cache_preferences_initialize()

        # Set of widgets used for controlling the various preferences
        self.widgets = {}

        # Layout the UI implementing the preferences
        self.widgets[self.ID_ROOT] = cmds.frameLayout(maya.stringTable['y_CacheUiFullLayout.kFrameCachedPlayback' ])
        with LayoutManager( self.widgets[self.ID_ROOT] ):
            with LayoutManager( cmds.columnLayout( adjustableColumn=True ) ):

                control = cmds.checkBoxGrp( label=''
                                          , label1=CachePreferenceEnabled().title
                                          , annotation=CachePreferenceEnabled().info
                                          , changeCommand=callback_tool(self, self.callback_change_cache_enabled)
                                          )
                self.widgets[CachePreferenceEnabled().ov_id] = control

                #----------------------------------------

                control = cmds.optionMenuGrp( label=CachePreferenceMode().title
                                            , annotation=CachePreferenceMode().info
                                            , changeCommand=callback_tool(self, self.callback_change_cache_mode)
                                            )
                for enum_info in CachePreferenceMode().DATA:
                    cmds.menuItem( parent=_menu(control)
                                 , label=enum_info[CachePreferences.KEY_ENUM_NAME]
                                 , annotation=enum_info[CachePreferences.KEY_ENUM_INFO]
                                 )
                self.widgets[CachePreferenceMode().ov_id] = control

                #----------------------------------------

                control = cmds.optionMenuGrp( label=CachePreferenceFillType().title
                                            , annotation=CachePreferenceFillType().info
                                            , changeCommand=callback_tool(self, self.callback_change_cache_fill_type)
                                            )
                for enum_info in CachePreferenceFillType().DATA:
                    cmds.menuItem( parent=_menu(control)
                                 , label=enum_info[CachePreferences.KEY_ENUM_NAME]
                                 , annotation=enum_info[CachePreferences.KEY_ENUM_INFO]
                                 )
                self.widgets[CachePreferenceFillType().ov_id] = control

                #----------------------------------------

                control = cmds.optionMenuGrp( label=CachePreferenceFillDirection().title
                                            , annotation=CachePreferenceFillDirection().info
                                            , changeCommand=callback_tool(self, self.callback_change_cache_fill_direction)
                                            )
                for enum_info in CachePreferenceFillDirection().DATA:
                    cmds.menuItem( parent=_menu(control)
                                 , label=enum_info[CachePreferences.KEY_ENUM_NAME]
                                 , annotation=enum_info[CachePreferences.KEY_ENUM_INFO]
                                 )
                self.widgets[CachePreferenceFillDirection().ov_id] = control

                #----------------------------------------

                control = cmds.checkBoxGrp( label=''
                                          , label1=CachePreferencePreventFrameSkipping().title
                                          , annotation=CachePreferencePreventFrameSkipping().info
                                          , changeCommand=callback_tool(self, self.callback_change_prevent_frame_skipping)
                                          )
                self.widgets[CachePreferencePreventFrameSkipping().ov_id] = control

                #----------------------------------------

                control = cmds.checkBoxGrp( label=''
                                          , label1=CachePreferenceShowWarningMessages().title
                                          , annotation=CachePreferenceShowWarningMessages().info
                                          , changeCommand=callback_tool(self, self.callback_change_show_warning_messages)
                                          )
                self.widgets[CachePreferenceShowWarningMessages().ov_id] = control

                #----------------------------------------

                cmds.separator()

                #----------------------------------------

                with LayoutManager( cmds.rowColumnLayout( numberOfColumns=2
                                                        , columnAlign=[(1,'left'), (3,'left')]
                                                        , columnAttach=[(1,'left',0), (2,'both',10)]
                                                        , rowSpacing=[1,5]
                                                        ) ):

                    control = cmds.checkBoxGrp( label=''
                                              , label1=CachePreferenceDiscardFramesOutOfRange().title
                                              , annotation=CachePreferenceDiscardFramesOutOfRange().info
                                              , changeCommand=callback_tool(self, self.callback_update_memory_management)
                                              )
                    self.widgets[CachePreferenceDiscardFramesOutOfRange().ov_id] = control
                    cmds.text( label='' )

                    #-----

                    ranges = CachePreferenceMemoryThreshold().ranges()
                    control = cmds.floatSliderGrp( label=CachePreferenceMemoryThreshold().title
                                                 , annotation=CachePreferenceMemoryThreshold().info
                                                 , field=True
                                                 , minValue=ranges[0]
                                                 , maxValue=ranges[1]
                                                 , fieldMinValue=ranges[2]
                                                 , fieldMaxValue=ranges[3]
                                                 , changeCommand=callback_tool(self, self.callback_update_memory_management)
                                                 )
                    self.widgets[CachePreferenceMemoryThreshold().ov_id] = control

                    control = cmds.image( visible=False, image='caution.png'
                                        , annotation=maya.stringTable['y_CacheUiFullLayout.kMemoryAllocationWarningTip' ] )
                    self.widgets[self.ID_WARNING_PERCENT] = control

                    #-----

                    control = cmds.checkBoxGrp( label=''
                                              , label1=CachePreferenceResourceGuard().title
                                              , annotation=CachePreferenceResourceGuard().info
                                              , changeCommand=callback_tool(self, self.callback_update_memory_management)
                                              )
                    self.widgets[CachePreferenceResourceGuard().ov_id] = control

                    control = cmds.image( visible=False, image='caution.png'
                                        , annotation=maya.stringTable['y_CacheUiFullLayout.kMemoryLimitWarningTip' ] )
                    self.widgets[self.ID_WARNING_NO_LIMIT] = control

        # Initialize the state of the widgets to the current state of the preferences
        self.update_ui()

        # Initialize the callbacks used to monitor for optionVar changes
        option_var_callback = callback_tool(self, self.callback_option_var_changed)
        for preference in PREFS_MONITORED:
            preference.add_client( self, option_var_callback )

        self.monitor_window()
        self.plugin_state_change( new_state=CacheEvaluatorManager().plugin_loaded )
        self.mode_change_job = cmds.scriptJob(event=('customEvaluatorChanged', callback_tool(self, self.callback_mode_changed)))

        # Automatically remove this class when the root control is deleted
        cmds.scriptJob( uiDeleted=(self.widgets[self.ID_ROOT], callback_tool(self, self.callback_ui_deleted)) )

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        cmds.frameLayout( self.widgets[self.ID_ROOT], edit=True, visible=new_state )

    #----------------------------------------------------------------------
    def update_warning_states(self):
        '''Update the visibility of the warning icons given the current preference values'''
        cmds.image( self.widgets[self.ID_WARNING_PERCENT],  edit=True, visible=CachePreferenceMemoryThreshold().get_value() > 90 )
        cmds.image( self.widgets[self.ID_WARNING_NO_LIMIT], edit=True, visible=not CachePreferenceResourceGuard().get_value() )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_option_var_changed(tool):
        '''
        Callback invoked when any of the optionVars affecting the cached playback preferences has changed.
        There are only a few of them and the entire UI has to be redrawn anyway so there is no
        need to provide separate handling for each of the optionVars.
        '''
        tool.update_ui()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_mode_changed(tool):
        '''
        Callback invoked when the evaluation manager state changes.
        '''
        tool.update_ui()

    #----------------------------------------------------------------------
    def update_ui(self):
        '''
        Update the state of all of the managed widgets based on the current state of the
        optionVars that drive them. There isn't much benefit to modifying one at a time
        '''
        assert self.ui_key in CacheUiFullLayout.CONTROLS

        # Just in case an idle update is waiting after the UI was deleted.
        # Have to check for widget existence too since the toolkit doesn't destroy its info until reopening.
        if len(self.widgets) == 0 or self.ID_ROOT not in self.widgets or not cmds.frameLayout( self.widgets[self.ID_ROOT], exists=True ):
            return

        caching_enabled = CachePreferenceEnabled().get_value()
        ui_enabled = cache_ui_enabled()
        cmds.checkBoxGrp( self.widgets[CachePreferenceEnabled().ov_id], edit=True, enable=cmds.evaluationManager(query=True,mode=True)[0] != 'off', value1=caching_enabled )

        resource_guard_enabled = CachePreferenceResourceGuard().get_value()
        cmds.checkBoxGrp( self.widgets[CachePreferenceResourceGuard().ov_id],           edit=True, enable=ui_enabled, value1=resource_guard_enabled )
        cmds.checkBoxGrp( self.widgets[CachePreferenceDiscardFramesOutOfRange().ov_id], edit=True, enable=ui_enabled, value1=CachePreferenceDiscardFramesOutOfRange().get_value() )

        cmds.image( self.widgets[self.ID_WARNING_PERCENT],  edit=True, enable=ui_enabled )
        cmds.image( self.widgets[self.ID_WARNING_NO_LIMIT], edit=True, enable=ui_enabled )
        self.update_warning_states()

        cmds.floatSliderGrp( self.widgets[CachePreferenceMemoryThreshold().ov_id], edit=True, enable=ui_enabled and resource_guard_enabled, value=CachePreferenceMemoryThreshold().get_value() )

        try:
            for option in [CachePreferenceMode(), CachePreferenceFillType(), CachePreferenceFillDirection()]:
                cmds.optionMenu ( _menu(self.widgets[option.ov_id]), edit=True, select=option.find_index( option.get_value() ) )
        except Exception, ex:
            pass

        # Split the updates so that the option menu label is also disabled when caching is disabled
        for option in [CachePreferenceMode(), CachePreferenceFillType(), CachePreferenceFillDirection()]:
            cmds.optionMenuGrp( self.widgets[option.ov_id], edit=True, enable=ui_enabled )

        cmds.checkBoxGrp( self.widgets[CachePreferencePreventFrameSkipping().ov_id], edit=True, enable=ui_enabled, value1=CachePreferencePreventFrameSkipping().get_value() )
        cmds.checkBoxGrp( self.widgets[CachePreferenceShowWarningMessages().ov_id],  edit=True, enable=ui_enabled, value1=CachePreferenceShowWarningMessages().get_value() )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_change_cache_enabled(tool):
        '''
        Callback invoked when the enabled state changes. Read the new value for the optionVar,
        set the new state, and update the UI
        '''
        cache_enabled = bool(cmds.checkBoxGrp( tool.widgets[CachePreferenceEnabled().ov_id], query=True, value1=True ))

        CachePreferenceEnabled().set_value_directly( tool, cache_enabled )

        # The widgets may enable or disable based on the value of this pref so reset their state
        CacheUiFullLayout.update_ui(tool)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_change_cache_mode(tool):
        '''
        Callback invoked when the cache mode type changes.
        Read the new value for the optionVar and set the new state.
        '''
        assert tool
        try:
            selected_item = cmds.optionMenu( _menu(tool.widgets[CachePreferenceMode().ov_id]), query=True, select=True ) - 1
            selected_name = CachePreferenceMode().KEYS[selected_item]

            CachePreferenceMode().set_value_directly( tool, selected_name )

        except KeyError, ex:
            pass

    #----------------------------------------------------------------------
    @staticmethod
    def callback_change_cache_fill_type(tool):
        '''
        Callback invoked when the cache fill type changes.
        Read the new value for the optionVar and set the new state.
        '''
        assert tool
        try:
            selected_item = cmds.optionMenu( _menu(tool.widgets[CachePreferenceFillType().ov_id]), query=True, select=True ) - 1
            selected_name = CachePreferenceFillType().KEYS[selected_item]

            CachePreferenceFillType().set_value_directly( tool, selected_name )
        except KeyError, ex:
            pass

    #----------------------------------------------------------------------
    @staticmethod
    def callback_change_cache_fill_direction(tool):
        '''
        Callback invoked when the cache fill direction changes.
        Read the new value for the optionVar and set the new state.
        '''
        assert tool
        try:
            selected_item = cmds.optionMenu( _menu(tool.widgets[CachePreferenceFillDirection().ov_id]), query=True, select=True ) - 1
            selected_name = CachePreferenceFillDirection().KEYS[selected_item]

            CachePreferenceFillDirection().set_value_directly( tool, selected_name )

        except KeyError, ex:
            pass

    #----------------------------------------------------------------------
    @staticmethod
    def callback_change_prevent_frame_skipping(tool):
        '''
        Callback invoked when the prevent-frame-skipping state changes.
        Read the new value for the optionVar and set the new state.
        '''
        assert tool
        prevent_frame_skipping = bool(cmds.checkBoxGrp( tool.widgets[CachePreferencePreventFrameSkipping().ov_id], query=True, value1=True ))

        CachePreferencePreventFrameSkipping().set_value_directly( tool, prevent_frame_skipping )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_change_show_warning_messages(tool):
        '''
        Callback invoked when the show-warning-messages state changes.
        Read the new value for the optionVar and set the new state.
        '''
        assert tool
        show_warnings = bool(cmds.checkBoxGrp( tool.widgets[CachePreferenceShowWarningMessages().ov_id], query=True, value1=True ))

        CachePreferenceShowWarningMessages().set_value_directly( tool, show_warnings )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_memory_management(tool):
        '''Invoked when one of the "stop caching" or "discard frames" checkboxes are pressed or the memory threshold is changed'''
        CacheEvaluatorManager().discard_frames_out_of_range = cmds.checkBoxGrp(tool.widgets[CachePreferenceDiscardFramesOutOfRange().ov_id], query=True, value1=True)
        CacheEvaluatorManager().resource_guard = cmds.checkBoxGrp(tool.widgets[CachePreferenceResourceGuard().ov_id], query=True, value1=True)
        CacheEvaluatorManager().memory_threshold = cmds.floatSliderGrp( tool.widgets[CachePreferenceMemoryThreshold().ov_id], query=True, value=True )

        tool.update_warning_states()

        # The memory information is displayed in the HUD so if it changes the HUD needs to update
        if CachePreferenceHud().get_value():
            # Trigger a refresh of the memory management and the HUD in the viewport
            cmds.memory( asFloat=True, gigaByte=True, adjustedVirtualMemory=True )
            cmds.refresh()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_deleted(tool):
        '''
        :param tool: CacheUiFullLayout object attached to the UI that was deleted
        '''
        assert tool
        assert tool.ui_key in CacheUiFullLayout.CONTROLS, maya.stringTable['y_CacheUiFullLayout.kCachePrefControlDelete' ].format( tool.ui_key )

        # Remove the scriptJob first to avoid extra idle events after destruction
        if tool.mode_change_job is not None:
            cmds.scriptJob( kill=tool.mode_change_job )
            tool.mode_change_job = None

        # Remove the callbacks used to monitor for optionVar changes
        for preference in PREFS_MONITORED:
            preference.remove_client( tool )

        # Clear the class data
        del CacheUiFullLayout.CONTROLS[tool.ui_key]
        tool.widgets = {}

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
