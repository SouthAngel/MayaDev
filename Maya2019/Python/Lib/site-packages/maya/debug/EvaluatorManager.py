"""
Helper class that maintains the evaluator mode information.

Derived classes will handle evaluator-specific information, this
one just handles the information that is common to all evaluators.

The object is set up to use the Python "with" syntax as follows:

    class MyEvaluatorManager(EvaluatorManager):
        ...

    from maya.debug.MyEvaluatorManager import MyEvaluatorManager
    with MyEvaluatorManager() as mgr:
        mgr.setMode( someMode )

That will ensure the original states are all restored.

If you need different control you can manually complete the sequence:

    mgr = MyEvaluatorManager()
    mgr.save_state()
    mgr.setMode( someMode )
    mgr.restore_state()
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)

import json
import maya.cmds as cmds
from maya.debug.DebugTrace import DebugTrace
from maya.app.prefs.OptionVar import OptionVar
from traceback import format_list, extract_tb

__all__ = ['EvaluatorManager', 'as_list'
          , 'KEY_NAME'
          , 'KEY_PLUGIN'
          , 'KEY_ENABLED'
          , 'KEY_LOADED'
          , 'KEY_PRIORITY'
          , 'KEY_NODE_TYPES'
          , 'KEY_CONSOLIDATION']

# Key values for storing the evaluator state
KEY_NAME             = 'name'
KEY_PLUGIN           = 'plugin'
KEY_ENABLED          = 'enabled'
KEY_LOADED           = 'plugin_loaded'
KEY_PRIORITY         = 'priority'
KEY_NODE_TYPES       = 'node_types'
KEY_CONSOLIDATION    = 'consolidation'


#======================================================================
def as_list(thing):
    '''Simple utility to ensure the thing is a list, return None as an empty list'''
    if thing is None:
        return []
    elif isinstance(thing,list):
        return thing
    elif hasattr(thing, '__iter__'):
        return list(thing)
    return list([thing])

#======================================================================
class EvaluatorManager(DebugTrace):
    '''
    Class for managing the shared evaluator state in a 'with' format. Remembers
    and restores the mode and parameters, including the load state of any plug-in
    associated with the manager.
    '''
    #----------------------------------------------------------------------
    class EvaluatorState(object):
        '''
        State information of the evaluator
            enabled          : Was the evaluator enabled on entry?
            priority         : Evaluation priority
            plugin_loaded    : Was the plugin loaded?
            node_types       : What node types were enabled on the evaluator?
            consolidation    : Name of consolidation type used (subgraph or none)
        '''
        def __init__(self):
            '''Set the state information to some default values'''
            self.enabled = False
            self.priority = 0
            self.plugin_loaded = False
            self.node_types = []
            self.consolidation = 'subgraph'

    #----------------------------------------------------------------------
    def save_state(self):
        '''
        Remember the current state of all evaluator parameters so that they
        can be restored on exit.

        self.state must be initialized to an object of type EvaluatorState
            (or derived class) before calling here
        '''
        self.dbg( 'EvaluatorManager.save_state' )

        self.state.plugin_loaded = self.plugin_loaded

        # If the plug-in is not loaded there's no data to collect
        if not self.state.plugin_loaded:
            return

        self.state.enabled = self.enabled
        self.state.priority = self.priority
        self.state.node_types = self.node_types
        self.state.consolidation = self.consolidation

    #----------------------------------------------------------------------
    def __enter__(self):
        '''
        Defining both __enter__ and __init__ so that either one can be used
        '''

        self.dbg( 'EvaluatorManager.__enter__' )

        self.save_state()

        return self

    #----------------------------------------------------------------------
    def __init__(self, name, plugin):
        '''
        Defining both __enter__ and __init__ so that either one can be used

        Members:
            state          : Values of the various states when save_state was called
            evaluator_name : Name of the evaluator this object manages
            plugin_name    : Name of the plug-in in which the evaluator is found (None if native)
            in_debug_mode  : True if debugging messages are to be printed
        '''
        super( EvaluatorManager, self ).__init__()

        self.dbg( 'EvaluatorManager.__init__' )

        self.state = EvaluatorManager.EvaluatorState()  # Sensible default
        self.evaluator_name = name
        self.plugin_name = plugin
        self.in_debug_mode = False

    #----------------------------------------------------------------------
    def __exit__(self,event_type,value,traceback):
        '''Ensure the state is restored if this object goes out of scope'''

        self.dbg( 'EvaluatorManager.__exit__' )
        self.dbg( '    Type      = {}'.format(event_type) )
        self.dbg( '    Value     = {}'.format(value) )
        self.dbg( '    Traceback = {}'.format('\n              > '.join(format_list(extract_tb(traceback)))) )

        self.restore_state()

    #----------------------------------------------------------------------
    def as_json(self):
        '''Display mechanism to retrieve evaluator information in a format conducive to JSON formatting'''
        if not self.plugin_loaded:
            return { 'error' : maya.stringTable['y_EvaluatorManager.kEvaluatorDisabled' ] }

        info  = { KEY_NAME          : self.evaluator_name
                , KEY_ENABLED       : self.enabled
                , KEY_PRIORITY      : self.priority
                , KEY_NODE_TYPES    : self.node_types
                , KEY_CONSOLIDATION : self.consolidation
                }

        # No need to bloat the data with plug-in information when none is present
        if self.plugin_name is not None:
            info[KEY_PLUGIN] = self.plugin_name
            info[KEY_LOADED] = self.plugin_loaded

        return info

    #----------------------------------------------------------------------
    def __str__(self):
        '''Display mechanism to show evaluator information in JSON format'''
        return json.dumps( self.as_json() )

    #----------------------------------------------------------------------
    def claimed_nodes(self, flatten):
        '''
        :param flatten: Boolean determining how to return the claimed nodes
        :return: If flatten is True then returns a single list of all nodes
                 claimed by this evaluator.
                 If flatten is False then return a list of clusters created
                 by this evaluator, where each cluster is in turn a list of
                 nodes contained within that cluster.
        '''
        claimed_list = []
        # Querying a non-existent evaluator returns a list of evaluators, not clustered nodes,
        # so catch that case first
        try:
            if self.evaluator_name in cmds.evaluator( query=True ):
                raw_list = cmds.evaluator( name=self.evaluator_name, query=True, clusters=True )
                # Deconstruct the raw_list format, which is a number N indicating the cluster
                # size, followed by the N nodes in that cluster, repeated for each cluster that
                # the evaluator has created.
                index = 0
                while index < len(raw_list):
                    cluster_size = int(raw_list[index])
                    cluster_list = []
                    for _ in range(0, cluster_size):
                        index += 1
                        cluster_list.append( raw_list[index] )
                    if flatten:
                        claimed_list = claimed_list + cluster_list
                    else:
                        claimed_list.append( cluster_list )
                    index += 1
        except Exception,ex:
            self.err( 'Could not find claimed nodes on {} - ignoring ({})'.format(self.evaluator_name, ex) )

        return claimed_list

    #----------------------------------------------------------------------
    def set_state(self, new_state):
        '''
        Define the evaluator state parameters.
        :param new_state: State information in the format provided by as_json
                          Only key values specified will change. Others retain
                          their current values (*not* default values).
        '''
        if not self.plugin_loaded:
            return

        self.dbg( 'EvaluatorManager.set_state to {}'.format( new_state ) )

        for key,value in new_state.iteritems():
            if key == KEY_NAME:
                self.evaluator_name = value
            elif key == KEY_PLUGIN:
                self.plugin_name = value
            elif key == KEY_ENABLED:
                self.enabled = value
            elif key == KEY_LOADED:
                self.plugin_loaded = value
            elif key == KEY_PRIORITY:
                self.priority = value
            elif key == KEY_NODE_TYPES:
                self.node_types = value
            elif key == KEY_CONSOLIDATION:
                self.consolidation = value
            # No else case because the child class has its own keys

    #----------------------------------------------------------------------
    def restore_state(self):
        '''
        Restore the evaluator to its original mode prior to creation of this
        object. Using the "with" syntax this will be called automatically.

        You only need to call explicitly when you instantiate the mode manager
        as an object.
        '''
        self.dbg( 'EvaluatorManager.restore_state' )
        # If the state wasn't stored it cannot be restored
        if self.state is None:
            self.dbg( '... skipping - no state was stored' )
            return

        # Restore the evaluator state. If the plug-in is not currently loaded
        # but will be then load it first to be able to set the old values.
        # If the plug-in will not be loaded, or will be unloaded, there is
        # nothing to do
        if self.state.plugin_loaded:
            if not self.plugin_loaded:
                self.plugin_loaded = self.state.plugin_loaded
            self.enabled = self.state.enabled
            self.priority = self.state.priority
            self.node_types = self.state.node_types
            self.consolidation = self.state.consolidation

        # Safe to do this twice so no need to confuse the logic above to avoid it
        self.plugin_loaded = self.state.plugin_loaded

    #----------------------------------------------------------------------
    #
    def check_evaluator(self):
        '''
        Check to see if the evaluator is known by the system
        :raise OptionVar.StateError: The evaluator is not known
        '''
        if self.evaluator_name not in cmds.evaluator( query=True ):
            raise OptionVar.StateError( maya.stringTable['y_EvaluatorManager.kNoEvaluator' ].format( self.evaluator_name ) )

    #----------------------------------------------------------------------
    #
    # Use properties to make it easier to access the evaluator information
    #
    @property
    def enabled(self):
        '''Return the evaluator's enabled state'''
        self.check_evaluator()
        return cmds.evaluator( name=self.evaluator_name, enable=True, query=True )

    @enabled.setter
    def enabled(self, new_value):
        '''
        Enable or disable the evaluator
        :param new_value: New enabled state for the evaluator
        '''
        if self.enabled == new_value:
            return

        # If the evaluator is not available, disabling it is silently accepted.
        # We do not try to remember that it was going to be enabled for when it
        # is potentially available in the future (i.e. by a plugin_load) as the
        # initialization of the evaluator has its own idea of whether it should
        # be enabled on load.
        try:
            self.check_evaluator()
        except OptionVar.StateError, ex:
            if new_value == True:
                raise ex

        self.dbg( 'Setting enabled state to {}'.format(new_value) )
        try:
            cmds.evaluator( name=self.evaluator_name, enable=new_value )
        except Exception, ex:
            self.err( '--- Failed : {}'.format(ex) )

    #----------------------------------------
    @property
    def priority(self):
        '''Return the evaluator's evaluation priority'''
        self.check_evaluator()
        return cmds.evaluator( name=self.evaluator_name, priority=True, query=True )

    @priority.setter
    def priority(self, new_value):
        '''
        Give the evaluator a new priority
        :param new_value: New priority for the evaluator
        '''
        self.check_evaluator()
        if self.priority == new_value:
            return

        self.dbg( 'Setting priority to {}'.format(new_value) )
        try:
            cmds.evaluator( name=self.evaluator_name, priority=new_value )
        except Exception, ex:
            self.err( '--- Failed : {}'.format(ex) )

    #----------------------------------------
    @property
    def plugin_loaded(self):
        '''Return whether the evaluator's plug-in was loaded'''
        if self.plugin_name is None:
            return True
        return cmds.pluginInfo( self.plugin_name, loaded=True, query=True )

    @plugin_loaded.setter
    def plugin_loaded(self, new_value):
        '''
        Load or unload the evaluator's plug-in
        :param new_value: New load state for the evaluator's plug-in
        '''
        if new_value == self.plugin_loaded or self.plugin_name is None:
            return

        self.dbg( '   {}oading plug-in {}'.format('L' if new_value else 'Unl', self.plugin_name) )
        try:
            if new_value:
                cmds.loadPlugin( self.plugin_name )
            else:
                cmds.unloadPlugin( self.plugin_name )
        except RuntimeError, ex:
            self.err( '--- Failed : {}'.format(ex) )

    #----------------------------------------
    @property
    def node_types(self):
        '''Return the evaluator's enabled node type list'''
        self.check_evaluator()
        return as_list( cmds.evaluator( name=self.evaluator_name, nodeType=True, query=True ) )

    @node_types.setter
    def node_types(self, new_value):
        '''
        Give the evaluator a new set of enabled node types. This is a replacement set,
        not an addition to existing node types.
        :param new_value: New node type list for the evaluator.
                          If the node type starts with a "+" then all children of that
                          node type will be added as well.
        '''
        self.dbg( 'Setting node type list to {} on {}'.format(new_value, self.evaluator_name) )

        self.check_evaluator()
        current_node_types = self.node_types
        # Checking the length first since it's cheaper than checking the whole set
        if len(new_value) == len(current_node_types) and set(new_value) == set(current_node_types):
            return

        try:
            # Since there's no easy way to know how node types are related in a hierarchy the
            # only reliable way to toggle the types properly is to shut everything off and then
            # turn on only what is requested.
            self.dbg( '     Disabling all node types' )
            cmds.evaluator( name=self.evaluator_name, nodeType='node', enable=False, nodeTypeChildren=True )

            if len(new_value) > 0:
                for new_type in new_value:
                    if new_type[0] == '+':
                        self.dbg( '     Enabling node type {} and all of its children'.format(new_type) )
                        cmds.evaluator( name=self.evaluator_name, nodeType=new_type[1:], enable=True, nodeTypeChildren=True )
                    else:
                        self.dbg( '     Enabling node type {} only'.format(new_type) )
                        cmds.evaluator( name=self.evaluator_name, nodeType=new_type, enable=True )

        except Exception, ex:
            self.err( '--- Failed : {}'.format(ex) )

    #----------------------------------------
    @property
    def consolidation(self):
        '''Return the cluster consolidation method to use (none or subgraph)'''
        self.check_evaluator()
        return cmds.evaluator( name=self.evaluator_name, valueName='cluster', query=True )

    @consolidation.setter
    def consolidation(self, new_value):
        '''
        Load or unload the evaluator's plug-in
        :param new_value: New load state for the evaluator's plug-in
        '''
        self.check_evaluator()
        if new_value == self.consolidation:
            return

        self.dbg( 'Setting cluster consolidation to {}'.format(new_value) )
        try:
            cmds.evaluator( name=self.evaluator_name, configuration='cluster={}'.format(new_value) )
        except RuntimeError, ex:
            self.err( '--- Failed : {}'.format(ex) )

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
