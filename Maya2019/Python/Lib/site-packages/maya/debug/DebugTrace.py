'''
Debug trace class. Make it a base class to your class to add debugging capabilities to it:

    class A(DebugTrace):
        def __init__(self):
            super( self.__class__, self ).__init__()
        def inner(self):
            self.dbg( "Inner method" )
        def outer(self):
            self.dbg( "Outer method" )
            self.inner()

The trace output for these commands:
    a = A()
    a.debugging = True
    a.outer()
will be:
    DBG: Outer method
    DBG:     Inner method
'''
__all__ = ['DebugTrace']

class DebugTrace(object):
    '''
    Simple base class that lets you selectively debug code, with hierarchical
    printing capabilities for more readability.

    The output lines are tagged with a 3 character identifier line to make them
    easier to differentiate in your output.
    '''
    def __init__(self):
        self.__indent_string = ''
        self.__enabled = False
        self.__indent_level = False

    #----------------------------------------------------------------------
    def dbg(self, message):
        '''
        Print out the message if debugging is enabled.
        :param message: Message to print
        '''
        if self.__enabled:
            print 'DBG: {}{}'.format( self.__indent_string, message )

    #----------------------------------------------------------------------
    def dbg_err(self, message):
        '''
        Print out the error message if debugging is enabled.
        :param message: Message to print
        '''
        if self.__enabled:
            print 'ERR: {}{}'.format( self.__indent_string, message )

    #----------------------------------------------------------------------
    def dbg_warn(self, message):
        '''
        Print out the arning message if debugging is enabled.
        :param message: Message to print
        '''
        if self.__enabled:
            print 'WRN: {}{}'.format( self.__indent_string, message )

    #----------------------------------------------------------------------
    def err(self, message):
        '''
        Print out the error message whether debugging is enabled or not.
        :param message: Message to print
        '''
        print 'ERR: {}{}'.format( self.__indent_string, message )

    #----------------------------------------------------------------------
    def warn(self, message):
        '''
        Print out the arning message whether debugging is enabled or not.
        :param message: Message to print
        '''
        print 'WRN: {}{}'.format( self.__indent_string, message )

    #----------------------------------------------------------------------
    class DebugSection(object):
        '''
        Helper class to scope debugging sections. Use it like this:

            with DebugSection("New section", debug_trace):
                debug_trace.dbg( "Hello" )
            debug_trace.dbg( "Goodbye" )

        which would yield this output, when the trace is enabled:

            New section
                Hello
            Goodbye
        '''
        def __enter__(self):
            '''
            Start a new debugging section with the given title.
            Prints the title then increments indentation
            :param title: Name of the new section
            '''
            # Nothing to do here, __init__ handles it
            pass

        def __exit__(self,exit_type,value,traceback): # pylint: disable=redefined-builtin
            '''
            Terminates a debugging section by decrementing the indentation.
            '''
            self.end_section()

        def end_section(self):
            '''
            Terminate an active section - only use this if you manually create
            a DebugSection rather than using the with() syntax
            '''
            self.trace.indent_level = self.trace.indent_level - 1

        def __begin_section(self, title):
            '''
            Start a new section - used both through __init__ and __enter__ entry points.
            :param title: Title of the new section
            '''
            self.trace.indent_level = self.trace.indent_level + 1
            self.trace.dbg( title )

        def __init__(self, title, trace):
            '''
            Initialize a new section manually
            '''
            self.trace = trace
            self.trace.dbg( title )
            self.trace.indent_level = trace.indent_level + 1

    #----------------------------------------------------------------------
    def section(self, title):
        '''
        Start a new debug section, returning the section object for manual closing.
        :param title: Title of the new section
        Be careful to match the starts and ends or the indentation level will
        go wonky as no sanity checks are performed on it.

            dbg.debugging( True )
            section = dbg_section( "New section" )
            dbg.dbg( "Hello" )
            section.end_section()
        or
            with dbg_section( "New section" ) as section:
                dbg.dbg( "Hello" )
        '''
        return DebugTrace.DebugSection( title, self )

    #----------------------------------------------------------------------
    #
    # Use the indent_level as a property so that __indent_string is kept up to date
    #
    @property
    def indent_level(self):
        '''Retrieve the internal indentation level'''
        return self.__indent_level

    @indent_level.setter
    def indent_level(self, new_level):
        '''
        Set the internal indentation level and update the indentation string.
        :param new_level: New level of indentation to use
        '''
        self.__indent_level = new_level
        self.__indent_string = '    ' * new_level

    #----------------------------------------------------------------------
    #
    # Enable and disable debugging through this property
    #
    @property
    def debugging(self):
        '''Retrieve the internal enabled state'''
        return self.__enabled

    @debugging.setter
    def debugging(self, new_state):
        '''
        Set the internal enabled state
        :param new_state: New enabled state
        '''
        self.__enabled = new_state

#######################################################################
if __name__ == '__main__':
    import unittest
    import sys
    from cStringIO import StringIO

    class TestDebugTrace(unittest.TestCase):
        """
        Unit tests for the DebugTrace class.
        """
        #----------------------------------------------------------------------
        def setUp(self):
            """Redirect stdout to a local variable"""
            self.old_stdout = sys.stdout
            sys.stdout = self.result = StringIO()

        #----------------------------------------------------------------------
        def tearDown(self):
            """Restore stdout"""
            sys.stdout = self.old_stdout

        #----------------------------------------------------------------------
        def test_simple_output(self):
            '''Test the normal string output with the trace on and off'''
            dbg = DebugTrace()
            # Test 1 - Not enabled by default
            dbg.dbg( "Hello" )
            self.assertEqual( self.result.getvalue(), "" )

            # Test 2 - Simple string
            dbg.debugging = True
            dbg.dbg( "Hello" )
            self.assertEqual( self.result.getvalue(), "DBG: Hello\n" )

            # Test 3 - Joined string
            dbg.dbg( "Goodbye" )
            self.assertEqual( self.result.getvalue(), "DBG: Hello\nDBG: Goodbye\n" )

        #----------------------------------------------------------------------
        @staticmethod
        def inner_section(dbg):
            '''
            Add an inner section detail to debugging output.
            :param dbg: Trace object to add section details
            '''
            with dbg.section("Inner Section"):
                dbg.dbg( "Core" )

        #----------------------------------------------------------------------
        def test_section_output(self):
            '''Test the normal string output inside sections'''
            dbg = DebugTrace()
            # Test 1 - Manual section
            dbg.debugging = True
            lines_expected = [ "DBG: New Section\n"
                             , "DBG:     Inner\n"
                             , "DBG:     Inner Section\n"
                             , "DBG:         Core\n"
                             , "DBG: Outer\n"
                             ]
            with dbg.section("New Section"):
                self.assertEqual( self.result.getvalue(), lines_expected[0] )
                dbg.dbg( "Inner" )
                self.assertEqual( self.result.getvalue(), "".join( lines_expected[0:2] ) )
                self.inner_section( dbg )
                self.assertEqual( self.result.getvalue(), "".join( lines_expected[0:4] ) )
            dbg.dbg( "Outer" )
            self.assertEqual( self.result.getvalue(), "".join( lines_expected[0:5] ) )

    unittest.main()

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
