'''
Utility script to scour the known debugging commands and dump a formatted collection of
information on what capabilities are available. Done in a backwards compatible manner
so that it can be run on earlier versions to find capabilities retroactively.

    from maya.debug.current_debug_capabilities import current_debug_capabilities
    print current_debug_capabilities( None )

Output is formatted as JSON for easy parsing for document creation. Here's a simple
example for the dbtrace command, which initially only supported the "compute" keyword
in customer cuts.

{
    "debugging" :
    {
        "dbtrace" :
        {
            "help" : "Synopsis: dbtrace [flags]\
Flags:\
   -q -query\
   -f -filter   String\
   -i -info    \
   -k -keyword  String (multi-use) (Query Arg Optional)\
   -l -level    UnsignedInt (multi-use) (Query Arg Mandatory)\
   -m -mark    \
   -o -output   String\
 -off -        \
   -t -title    String\
  -tm -timed    on|off\
   -v -verbose \
\
\
Command Type: Command",
            "keywords" :
            {
                "compute" : "High level trace of the compute path."
            }
        }
    }

For any section requiring commands not available in the current cut an
abbreviated output is provided:

{
    "debugging" :
    {
        "dbtrace" : { "help" : "The dbtrace command is not available in this cut" }
    }
'''
import json
import re

#======================================================================
def command_available(command, results):
    '''
    Check to see if a command is available in this cut.
    :param command: Name of command to check
    :param results: Returned help information. If the command is available
                    it will have the output from 'help command' appended,
                    otherwise it will have a notice that the command is
                    not available.
    :return: True if the command is available, False if not
    '''
    if not command in maya.cmds.__dict__:
        results['help'] = 'The {} command is not available in this cut'.format(command)
        return False

    results['help'] = cmds.help( command )
    return True

#======================================================================
def dbcount_capabilities():
    '''
    Find the current capabilities of the dbcount command if it exists.
    '''
    results = {}
    if not command_available( 'dbcount', results ):
        return results

    results['info'] = '''The dbcount command maintains counters for when certain locations are hit.
It is used to detect redundant or excessive code traversal without the overhead of performance tools.'''

    return results

#======================================================================
def dbmessage_capabilities():
    '''
    Find the current capabilities of the dbmessage command if it exists.
    '''
    results = {}
    if not command_available( 'dbmessage', results ):
        return results

    results['info'] = '''The dbmessage command monitors the flow of messages through the graph.
It is used to detect excess or incorrect messaging.'''

    return results

#======================================================================
def dbpeek_capabilities():
    '''
    Find the current capabilities of the dbpeek command if it exists.
    Only embedded help is available for specific dbpeek operations so
    that is all provided here. Documentation for the command itself is
    available online in the command documentation.

        {
            "help" : "HELP INFORMATION FROM 'help dbpeek'"
            "operations" :
            {
                "OPERATION" : "SUMMARY FROM 'dbpeek -op OPERATION -q'"
            }
        }
    '''
    results = {}
    if not command_available( 'dbpeek', results ):
        return results

    operations = {}
    for operation in cmds.dbpeek( q=True, op=True ):
        try:
            operations[operation] = cmds.dbpeek( q=True, op=operation )
        except:
            operations[operation] = 'No details available in this cut'

    results['operations'] = operations
    return results

#======================================================================
RE_DBTRACE_KEYWORD_LEVEL = re.compile( '(.+)\[([0-9]+)\]' )
def dbtrace_keyword_split(keyword):
    '''
    Split a dbtrace keyword into key and level. Formatting is KEY[LEVEL]
    for internal traces and just KEY for customer-facing ones. In the
    latter case a level of 0 is returned for consistency.
    '''
    match = RE_DBTRACE_KEYWORD_LEVEL.match( keyword )
    level = 0
    if match:
        keyword = match.group(1)
        level = int(match.group(2))

    return (keyword, level)

def dbtrace_capabilities():
    '''
    Find the current capabilities for the dbtrace command and return it
    in a dictionary. Only the help information and a summary of each
    available keyword derived from the 'info' flag is provided.

        {
            "help" : "HELP INFORMATION FROM 'help dbtrace'"
            "keywords" :
            {
                "KEYWORD" : "SUMMARY FROM 'dbtrace -k KEYWORD -q -info'"
            }
        }
    '''
    results = {}
    if not command_available( 'dbtrace', results ):
        return results

    # Get the list of both the enabled and disabled keywords.
    keywords = {}
    for keyword in cmds.dbtrace( q=True ) + cmds.dbtrace( q=True, off=True ):
        try:
            (key, level) = dbtrace_keyword_split( keyword )
            # The "-1" works around a bug in the dbtrace command that dumps the info for
            # all levels up to the named one (so level 2 gets a list of the info for both
            # level 1 and level 2)
            keywords[keyword] = cmds.dbtrace( k=key, l=level, info=True, q=True )[-1]
        except Exception, ex:
            # Gracefully skip any errors that could be caused by changes in command args
            print 'WARN: Parsing dbtrace keyword {} failed : {}'.format(keyword, ex)
    results['keywords'] = keywords
    return results

#======================================================================
def dgdebug_capabilities():
    ''' Find the current capabilities of the dgdebug command if it exists.  '''
    results = {}
    if not command_available( 'dgdebug', results ):
        return results

    results['info'] = '''The dgdebug command is a back door to getting certain information about the graph.
It has mostly been deprecated by the dbpeek command, use that where available.
See the dgdebug command documentation for a description of the options and output provided.'''

    return results

#======================================================================
def dgdirty_capabilities():
    ''' Find the current capabilities of the dgdirty command if it exists.  '''
    results = {}
    if not command_available( 'dgdirty', results ):
        return results

    results['info'] = '''The dgdirty command forces dirty states onto specified plugs and everything downstream from them.
See the dgdirty command documentation for a description of the options and output provided.'''

    return results

#======================================================================
def dgeval_capabilities():
    ''' Find the current capabilities of the dgeval command if it exists.  '''
    results = {}
    if not command_available( 'dgeval', results ):
        return results

    results['info'] = '''The dgeval command forces compute to be called on certain plugs.
See the dgeval command documentation for a description of the options and output provided.'''

    return results

#======================================================================
def dgInfo_capabilities():
    ''' Find the current capabilities of the dgInfo command if it exists.  '''
    results = {}
    if not command_available( 'dgInfo', results ):
        return results

    results['info'] = '''The dgInfo command dumps information about the current state of the graph.
It has mostly been deprecated by the dbpeek command, use that where available.
See the dgInfo command documentation for a description of the options and output provided.'''

    return results

#======================================================================
def dgmodified_capabilities():
    ''' Find the current capabilities of the dgmodified command if it exists.  '''
    results = {}
    if not command_available( 'dgmodified', results ):
        return results

    results['info'] = '''The dgmodified command checks on why a file is asking to save when no changes have been made.
See the dgmodified command documentation for a description of the options and output provided.'''

    return results

#======================================================================
def current_debug_capabilities(file_name):
    '''
    Dump out the current debugging capabilities to the named file.
    :param file_name: Name of file to receive the results. If None then
                      the results are returned in a JSON dictionary.
    '''
    results = { 'debugging' :
                {
                  'dbcount'    : dbcount_capabilities()
                , 'dbmessage'  : dbmessage_capabilities()
                , 'dbpeek'     : dbpeek_capabilities()
                , 'dbtrace'    : dbtrace_capabilities()
                , 'dgdebug'    : dgdebug_capabilities()
                , 'dgdirty'    : dgdirty_capabilities()
                , 'dgeval'     : dgeval_capabilities()
                , 'dgInfo'     : dgInfo_capabilities()
                , 'dgmodified' : dgmodified_capabilities()
                }
              }
    if file_name == None:
        return results
    else:
        json.dump( results, open(file_name,'w') )

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
