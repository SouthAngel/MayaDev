"""
Utility to verify that the background evaluation and caching system are
yielding the same results as the Maya parallel evaluation.

It is a simple wrapper around run_correctness_test().  See its documentation
for more details.

Sample usage to run the tests on a single file:

    from maya.debug.cacheCorrectnessTest import cacheCorrectnessTest
    from maya.plugin.evaluator.CacheEvaluatorManager import CACHE_STANDARD_MODE_EVAL
    cacheErrors = cacheCorrectnessTest(file_name='MyDir/MyFile.ma', results_path='MyDir/cacheCorrectness', modes=[{KEY_CACHE_MODE: CACHE_STANDARD_MODE_EVAL}])

Sample usage to run the tests on the current scene and ignore output:

    from maya.debug.cacheCorrectnessTest import cacheCorrectnessTest
    from maya.plugin.evaluator.CacheEvaluatorManager import CACHE_STANDARD_MODE_EVAL
    cacheErrors = cacheCorrectnessTest(modes=[{KEY_CACHE_MODE: CACHE_STANDARD_MODE_EVAL}])
"""
import sys
import json
import maya.cmds as cmds
from maya.debug.EvaluatorManager import EvaluatorManager
from maya.debug.DeformerEvaluatorManager import DeformerEvaluatorManager
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager, standard_modes, KEY_CACHE_MODE
from maya.debug.correctnessUtils import run_correctness_test, multichain_nodes, CORRECTNESS_MAX_FRAMECOUNT, CORRECTNESS_INVALIDATE

__all__ = [ 'cacheCorrectnessTest',
            'getModeString' ]

# Maximum amount of time to wait for cache to fill.
MAX_CACHE_TIMEOUT = 1800

#======================================================================

class CacheCorrectnessContext(object):
    """
    This class configures the cache evaluator according to a set of options and
    shuts off the HIK and GPU deformer evaluators to help isolate correctness errors.
    """
    def __init__(self, mode, cache_timeout):
        '''Create the evaluator managers and remember the desired configuration values'''
        # This context requires changes to both the cache evaluator and the
        # deformer evaluator so it uses members instead of overriding CacheEvaluatorManager
        self.deformer_mgr = DeformerEvaluatorManager()
        self.cache_mgr = CacheEvaluatorManager()
        self.hik_mgr = EvaluatorManager('hik','mayaHIK')

        self.mode = mode
        self.cache_timeout = cache_timeout

    #----------------------------------------------------------------------
    def should_pull_values(self):
        '''
        Ask if the values in this context are good as-is or if they have to be pulled to be valid
        :return: True always - cached values need to be pulled to ensure correctness
        '''
        return True

    #----------------------------------------------------------------------
    def __enter__(self):
        '''Enter the section controlled by the context'''
        try:
            self.deformer_mgr.__enter__()
        except Exception, ex:
            self.deformer_mgr.__exit__(*sys.exc_info())
            raise ex
        try:
            self.cache_mgr.__enter__()
        except Exception, ex:
            self.cache_mgr.__exit__(*sys.exc_info())
            raise ex
        try:
            self.hik_mgr.__enter__()
        except Exception, ex:
            self.hik_mgr.__exit__(*sys.exc_info())
            raise ex

        if self.mode is None:
            # In the reference mode the cache evaluator should be disabled
            self.cache_mgr.enabled = False
        else:
            # The cache evaluator should be enabled
            self.cache_mgr.enabled = True

            # Enable the node types specified in the cache evaluator
            self.cache_mgr.set_state( self.mode )

        # Disable the deformer evaluator. Caching doesn't deal with the GPU so there is no point
        # in using it. (Also there are artifacts because GPU calculation is intentionally
        # different from regular evaluation.)
        self.deformer_mgr.enabled = False

        # Disable the HIK evaluator. Background evaluation doesn't use the HIK evaluator due
        # to code in the evaluator itself so it isn't a fair comparison to enable it in the
        # foreground.
        self.hik_mgr.enabled = False

        # If caching is enabled then fill the cache in the background
        if self.mode is not None:
            cmds.currentTime(cmds.currentTime(query=True))
            if not cmds.cacheEvaluator( waitForCache=self.cache_timeout ):
                self.cache_mgr.warn( 'Cache was not completely filled in {} seconds'.format(self.cache_timeout) )

        return self

    #----------------------------------------------------------------------
    def __exit__(self,exit_type,value,traceback):
        '''Exit the section controlled by the context, raising an exception if any restore failed'''
        exception = None

        try:
            self.deformer_mgr.__exit__(exit_type, value, traceback)
        except Exception, ex:
            exception = ex

        try:
            self.cache_mgr.__exit__(exit_type, value, traceback)
        except Exception, ex:
            exception = ex

        try:
            self.hik_mgr.__exit__(exit_type, value, traceback)
        except Exception, ex:
            exception = ex

        if exception is not None:
            raise exception

    #----------------------------------------------------------------------
    def __str__(self):
        ''':return: a string with information on the managed evaluator's states'''
        return json.dumps( { 'cache'    : self.cache_mgr.as_json()
                           , 'hik'      : self.hik_mgr.as_json()
                           , 'deformer' : self.deformer_mgr.as_json()
                           }
                         , indent=4
                         )

#======================================================================

class CacheCorrectnessMode(object):
    """
    This class represents a mode to be tested in cache correctness tests.

    It knows about the cache mode (i.e. what caching point to be enabled).

    It always requires the same evaluation mode:
    - Parallel evaluation
    - Cache evaluator enabled
    """
    def __init__(self, cache_mode, cache_timeout):
        self.cache_mode = cache_mode
        self.cache_timeout = cache_timeout

    def title(self):
        """
        Returns the identifying string for this cache mode.
        """
        if self.cache_mode is None:
            mode_string = self.em_mode()
        else:
            mode_string = ''
            if KEY_CACHE_MODE in self.cache_mode:
                for standard_mode in standard_modes():
                    if self.cache_mode[KEY_CACHE_MODE] == standard_mode[1]:
                        mode_string = standard_mode[0]

                if not mode_string:
                    # The mode is not a standard one, generate a hash.
                    mode_string = 'Custom_{}'.format(hash(str(self.cache_mode)))

        return mode_string

    def em_mode(self):
        """
        Returns the evaluation mode in which the cache correctness test must be run.
        """
        if self.cache_mode is None:
            return 'emp-cache-deformer-hik'

        return 'emp+cache-deformer-hik'

    def context(self):
        """
        Returns the context object that will set up and tear down the required
        caching configuration to be tested.
        """
        return CacheCorrectnessContext(self.cache_mode, self.cache_timeout)

    @staticmethod
    def relevant_nodes(potential_nodes):
        '''
        :param potential_nodes: Set of nodes that could be evaluated/compared in the current mode
        :return: a subset of nodes relevant to the defined evaluation caching mode
        '''
        # Filter out the nodes to include only those that are caching points
        relevant_nodes = set()
        try:
            with CacheEvaluatorManager() as cache_mgr:
                relevant_nodes = cache_mgr.cached_nodes( potential_nodes )
            relevant_nodes = potential_nodes & relevant_nodes
        except Exception:
            # If we can't find the cached nodes it's safest to prevent any filtering
            relevant_nodes = potential_nodes

        # Multi-chain solver nodes do not play well with correctness tests
        relevant_nodes = relevant_nodes - multichain_nodes()

        return relevant_nodes

#======================================================================

def getModeString(mode):
    """
    Returns the identifying string for this cache mode.
    Temporary function here while QATA is refactored.
    """
    mode_string = ''
    if KEY_CACHE_MODE in mode:
        for standard_mode in standard_modes():
            if mode[KEY_CACHE_MODE] == standard_mode[1]:
                mode_string = standard_mode[0]

        if not mode_string:
            # The mode is not a standard one, generate a hash.
            mode_string = 'Custom_{}'.format(hash(str(mode)))

    return mode_string

#======================================================================

def cacheCorrectnessTest( file_name=None
                        , results_path=None
                        , verbose=False
                        , modes=None
                        , max_frames=CORRECTNESS_MAX_FRAMECOUNT
                        , data_types=['matrix','vertex','screen']
                        , em_setup=CORRECTNESS_INVALIDATE
                        , cache_timeout=MAX_CACHE_TIMEOUT ):
    """
    Evaluate the file in multiple caching modes and compare the results.

    :param file_name:    Name of file to load for comparison. None means use the current scene.
    :param results_path: Where to store the results. None means don't store anything.
    :param verbose:      If True then dump the differing values when they are encountered.
    :param modes:        List of modes to run the tests in.  A mode is a list of options to activate
                         in the cache system.  See the CacheEvaluatorManager set_state() method for
                         the format it expects for these modes.
    :param max_frames:   Maximum number of frames in the playback, to avoid long tests.
    :param data_types:   List of data types to include in the analysis.
                            See run_correctness_test for the possible values.
    :param em_setup:     What to do before running an EM mode test, in bitfield combinations.
                            See run_correctness_test for the possible values.
    :param cache_timeout: The maximum amount of time to wait for cache to fill.

    :return: a list of value tuples indicating the run mode and the number of
             changes encountered in that mode. e.g. ['ems', 0]
    """
    # No modes means no testing to run
    if modes is None:
        return []

    test_modes = [CacheCorrectnessMode(mode, cache_timeout) for mode in modes]

    return run_correctness_test( CacheCorrectnessMode(None, None)
                               , test_modes
                               , file_name
                               , results_path
                               , verbose
                               , max_frames
                               , data_types
                               , em_setup
                               )

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
