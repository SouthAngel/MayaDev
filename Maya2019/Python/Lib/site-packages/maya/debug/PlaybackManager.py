"""
Holds the helper class PlaybackManager used to change and restore
the playbackOptions within a scope and manages simple playing.

Load with:
        from maya.debug.PlaybackManager import PlaybackManager

See the class docs for how to use this to control playback.
"""
import maya.cmds as cmds
import math
from maya.debug.DebugTrace import DebugTrace
from traceback import format_list, extract_tb

__all__ = [ 'PlaybackManager' ]

#======================================================================
class PlaybackManager(DebugTrace):
    '''
    Helper class that maintains the playback mode information.

    It maintains state information for all playback options so that they can be
    modified within a scope and have the original settings restored on completion.

    Calling any of the setXXX() methods

    The object is set up to use the Python "with" syntax as follows:

        with PlaybackManager() as mgr:
            mgr.minTime = new_start_frame

    That will ensure the original states are all restored. There's no other
    reliable way to do it in Python. If you need different scoping that can't
    be put into a nice code block like this you can manually call the methods
    to complete the sequence:

        mgr = PlaybackManager()
            ...
        mgr.minTime = new_start_frame )
            ...
        mgr.restore()

    You may also be interested in this utility method that will playback the
    entire range from the start in 'wait' mode. You want this because if you
    don't play in 'wait' mode then your manager can go out of scope while
    playback is running, messing up your state on exit.

        with PlaybackManager() as mgr:
            mgr.play_all()

    See also mgr.play_range() and mgr.play_limited_range() for other options.
    '''
    # List of all arguments the playbackOptions command accepts
    PLAYBACK_OPTIONS = [ 'animationStartTime'
                       , 'animationEndTime'
                       , 'blockingAnim'
                       , 'by'
                       , 'framesPerSecond'
                       , 'loop'
                       , 'maxPlaybackSpeed'
                       , 'maxTime'
                       , 'minTime'
                       , 'playbackSpeed'
                       , 'view'
                       ]

    #----------------------------------------------------------------------
    class PlaybackManagerState(object):
        '''
        State information of playback options. Used by PlaybackManager to
        preserve and restore state.
        '''
        def __init__(self):
            '''Set all of the options to None to flag unread values'''
            for option in PlaybackManager.PLAYBACK_OPTIONS:
                setattr( self, option, None )
            self.current_time = None
            self.current_time_unit = None
            self.needs_restoring = False

        #----------------------------------------------------------------------
        def __str__(self):
            '''Nicer formatting for the playback options'''

            as_str = 'STATE :\n'

            for option in PlaybackManager.PLAYBACK_OPTIONS:
                as_str += '    {} = {}\n'.format( option, getattr( self, option ) )

            as_str += '    current_time = {}'.format( self.current_time )
            as_str += '    current_unit = {}'.format( self.current_time_unit )

            return as_str

        #----------------------------------------
        def save_state(self, manager):
            '''
            Save the current state values of the manager
            :param manager: PlaybackManager whose state is to be saved
            '''
            for option in PlaybackManager.PLAYBACK_OPTIONS:
                setattr( self, option, getattr( manager, option ) )
                manager.dbg( 'Save {} = {}'.format(option, getattr( manager, option )) )

            self.current_time = manager.current_time
            self.current_time_unit = manager.current_time_unit

        #----------------------------------------
        def restore_state(self, manager):
            '''
            Restore the manager's state from this state object.
            If nothing changed then the restore is skipped, for efficiency.
            If the current time hasn't changed then it is not explicitly set again,
            to avoid an unnecessary evaluation.
            :param manager: PlaybackManager whose state is to be restored
            '''
            # Prevent multiple calls
            if not self.needs_restoring:
                manager.dbg( '    Oops, nothing to restore' )
                return

            # The playbackOptions command can probably handle restoring multiple
            # options at once but why tempt fate. This way allows for easier
            # debugging should any of the individual option restores not work.
            #
            try:
                for option in PlaybackManager.PLAYBACK_OPTIONS:
                    manager.dbg( '    Restore {} = {}'.format(option, getattr(self, option)) )
                    setattr( manager, option, getattr(self, option) )

                manager.current_time_unit = self.current_time_unit

                # Do not restore current if it is unchanged. It would trigger an unwanted evaluation.
                if manager.current_time != self.current_time:
                    manager.dbg( '    Restore current time = {}'.format(self.current_time) )
                    manager.current_time = self.current_time
            except Exception,ex:
                manager.dbg_err( '    Oops, error in restoring options ({})'.format(ex) )

            self.needs_restoring = False

    #----------------------------------------------------------------------
    def __enter__(self):
        '''Beginning of scope object for "with" statement. __init__ does all intialization'''
        self.dbg( 'PlaybackManager::__enter__' )
        return self

    #----------------------------------------------------------------------
    def __init__(self):
        '''Defining both __enter__ and __init__ so that either one can be used'''

        super( PlaybackManager, self ).__init__()
        self.dbg( 'PlaybackManager::__init__' )

        self.state = self.PlaybackManagerState()
        self.state.save_state( self )

    #----------------------------------------------------------------------
    def __exit__(self,exit_type,exit_value,traceback):
        '''Ensure the state is restored if this object goes out of scope'''
        self.dbg( 'PlaybackManager::__exit__' )
        self.dbg( '    Type      = {}'.format(exit_type) )
        self.dbg( '    Value     = {}'.format(exit_value) )
        self.dbg( '    Traceback = {}'.format('\n              > '.join(format_list(extract_tb(traceback)))) )
        self.restore()

    #----------------------------------------------------------------------
    def __str__(self):
        '''Nicer formatting for the playback options'''

        as_str = 'PlaybackManager\n'
        as_str += '    {}\n'.format( ['Does not need restoring', 'Needs restoring'][self.state.needs_restoring] )
        as_str += str( self.state )

        return as_str

    #----------------------------------------------------------------------
    def get_current_state(self):
        '''
        :return: PlaybackManagerState object containing the current state of the playback options.
        Meant to be mainly used for testing.
        '''
        current_state = self.PlaybackManagerState()
        current_state.save_state( self )
        return current_state

    #----------------------------------------------------------------------
    def play_all(self):
        '''
        Playback the entire animation sequence, once

        :return: 3-tuple (TIME,START,END) indicating the elapsed play time and the
                frame numbers that were played
        '''
        min_time = self.minTime
        max_time = self.maxTime

        loop = self.loop
        self.loop = 'once'

        self.dbg( 'PlaybackManager::play_all ({} to {})'.format(min_time,max_time) )

        self.current_time = min_time
        start_time = cmds.timerX()
        cmds.play( wait=True )
        elapsed_time = cmds.timerX(startTime=start_time)

        if self.current_time != max_time:
            self.dbg_err( 'Play All to {} ended on frame {}'.format(max_time, self.current_time) )

        self.loop = loop

        return (elapsed_time, min_time, max_time)

    def play_for(self, seconds):
        '''
        Playback the entire animation sequence until "seconds" time has elapsed.
        If the total time it takes to play the animation range is less than seconds,
        loop until seconds time has elapsed.

        :return: 2-tuple (ELAPSED_TIME,PLAYED_FRAMES) indicating the total elapsed time and
                the number of played back frames.
        '''

        min_time = self.minTime
        max_time = self.maxTime

        loop = self.loop
        self.loop = 'once'

        self.dbg( 'PlaybackManager::play_for ({} to {}) for {} seconds'.format(min_time,max_time, seconds) )

        # We can't start on min_time becuase if when we loop the playback we'll have a frame changing from
        # max_time to min_time.  If we start on min_time we won't have a frame on the first iteration, which
        # makes counting the number of frames we playback harder.
        self.current_time = max_time
        frames_per_iteration = max_time - min_time + 1
        played_frames = 0
        start_time = cmds.timerX()
        # loop until we've played enough frames to get to the requested time
        finished = False
        while True:
            if self.current_time != min_time:
                played_frames += 1
            self.current_time = min_time
            cmds.play( wait=True )
            played_frames += self.maxTime - self.minTime
            elapsed_time = cmds.timerX(startTime=start_time)
            if elapsed_time > seconds or finished:
                break
            
            #Figure out how many more frames we need to do to finish as after as close to seconds as possible
            time_per_frame = elapsed_time / played_frames
            time_remaining = seconds - elapsed_time
            time_per_iteration = frames_per_iteration * time_per_frame
            if time_per_iteration > time_remaining:
                percentage_of_iteration_remaining = time_remaining / time_per_iteration
                frames_to_run = math.ceil(frames_per_iteration * percentage_of_iteration_remaining)
                self.maxTime = min_time + frames_to_run
                finished = True

        self.loop = loop
        self.maxTime = max_time

        return (elapsed_time, played_frames)

    #----------------------------------------------------------------------
    def play_range(self, min_time, max_time):
        '''
        Playback the given animation range once, returning the elapsed time when it is done.
        The time range is only set temporarily for this playback sequence.

        :return: 3-tuple (TIME,START,END) indicating the elapsed play time and the
                frame numbers that were played
        '''
        self.dbg( 'PlaybackManager::playRange({},{})'.format(min_time,max_time) )
        original_settings = [self.minTime, self.maxTime, self.loop]
        (self.minTime, self.maxTime, self.loop) = (min_time, max_time, 'once')

        self.current_time = min_time
        start_time = cmds.timerX()
        cmds.play( wait=True )
        elapsed_time = cmds.timerX(startTime=start_time)

        self.minTime = original_settings[0]
        self.maxTime = original_settings[1]
        self.loop = original_settings[2]

        if max_time != self.current_time:
            self.dbg_err( 'Playrange {} - {} ended on frame {}'.format(min_time, max_time, self.current_time) )

        return (elapsed_time, min_time, max_time)

    #----------------------------------------------------------------------
    def limited_range(self, max_frames, from_start=False):
        '''
        :param max_frames: Maximum number of frames to play
        :param from_start: When set to True get the range from the start of the
                   animation, else get it from the current frame.

        :return: 2-tuple (START,END) indicating the frame numbers actually used
                 in the defined limited range
        '''
        self.dbg( 'PlaybackManager::limited_range({}, {})'.format( max_frames, from_start ) )

        min_time = self.minTime if from_start else self.current_time
        max_time = self.maxTime
        if self.maxTime - min_time >= max_frames:
            # If the range is too large then stop early
            max_time = min_time + max_frames - 1

        self.dbg( ' -> ({}, {})'.format(min_time, max_time) )

        return (min_time, max_time)

    #----------------------------------------------------------------------
    def set_limited_range(self, max_frames, from_start=False):
        '''
        Set up the manager to play the given animation range by setting the
        minTime and maxTime to respect the arguments. After calling this you
        can use playAll() rather than playRange() or playLimitedRange().

        The time range is set for the duration of this manager so only use
        it if you will be using the same range repeatedly. It returns a
        tuple of (original_min_time, original_max_time) in case you want
        to restore it later.

        :param max_frames: Maximum number of frames to play
        :param from_start: When True this will first move the playback to the first
                   frame of the animation. Otherwise it will go to what the current
                   time was when the manager was created. This allows you to get
                   consistent limited length playbacks from an arbitrary starting
                   frame.

        Note: If the current time is at or near the maxTime and you do not
              specify 'from_start=True' there may be little or no animation so
              make sure your scene is set up appropriate if you use that option.

        :return: 2-tuple (START,END) indicating the frame numbers actually used
                 in the defined limited range
        '''
        self.dbg( 'PlaybackManager::setLimitedRange(%d)' % (max_frames) )

        (min_time, max_time) = self.limited_range( max_frames, from_start )
        (self.minTime, self.maxTime) = (min_time, max_time)
        return (min_time, max_time)

    #----------------------------------------------------------------------
    def play_limited_range(self, max_frames, from_start=False):
        '''
        Playback the given animation range, returning the elapsed time when it is done.
        The time range is only set temporarily for this playback sequence.
        If you wish to permanently change the time range use setOptions().

        max_frames: Maximum number of frames to play
        from_start: When set to True this will first move the playback to the first
                   frame of the animation. Otherwise it will go to what the current
                   time was when the manager was created. This allows you to get
                   consistent limited length playbacks from an arbitrary starting
                   frame.

        Note: If the current time is at or near the maxTime and you do not
              specify 'from_start=True' there may be little or no animation so
              make sure your scene is set up appropriate if you use that option.

        :return: 3-tuple (TIME,START,END) indicating the elapsed play time and the
                frame numbers that were played
        '''
        self.dbg( 'PlaybackManager::playLimitedRange(%d)' % (max_frames) )
        (min_time, max_time) = self.limited_range( max_frames, from_start )
        return self.play_range( min_time, max_time )

    #----------------------------------------------------------------------
    def restore(self):
        '''
        Restore the playback options to their original values (i.e. the ones
        present when this object was constructed).

        It's necessary to call this when using the "with PlaybackManager()"
        syntax. It's only needed when you explicitly instantiate the mode manager.
        Then you have to call this if you want your original state restored,
        or wait for the unknown point in the future where this object is
        destroyed.
        '''
        self.dbg( 'PlaybackManager::restore' )
        self.state.restore_state( self )

    #----------------------------------------------------------------------
    #
    # Use properties to make it easier to access generic playback information
    #
    @property
    def current_time(self):
        '''Get the current time in the playback timeline'''
        return cmds.currentTime( query=True )

    @current_time.setter
    def current_time(self, new_time):
        '''Set a new current time'''
        self.state.needs_restoring = True
        self.dbg( 'Setting a new current time of {}'.format( new_time ) )
        cmds.currentTime( new_time, edit=True )

    #----------------------------------------
    @property
    def current_time_unit(self):
        '''Get the current time unit in the playback timeline'''
        return cmds.currentUnit( query=True, time=True )

    @current_time_unit.setter
    def current_time_unit(self, new_time_unit):
        '''Set a new current time'''
        self.dbg( 'Setting a new current time unit of {}'.format( new_time_unit ) )
        cmds.currentUnit( time=new_time_unit )

    #----------------------------------------------------------------------
    #
    # Override the get and set methods to access the playbackOptions flags with minimal code.
    #
    def __getattribute__(self, option_name):
        '''
        :param option_name: Name of one of the parameters to the playbackOptions command
        :return: the playback option's current value
        '''
        if option_name in PlaybackManager.PLAYBACK_OPTIONS:
            return cmds.playbackOptions( **{ 'query' : True, option_name : True } )
        return super( PlaybackManager, self ).__getattribute__(option_name)

    def __setattr__(self, option_name, new_value):
        '''
        Set the new value of the playback option
        :param option_name: Name of one of the parameters to the playbackOptions command
        :param new_value: New end time value
        '''
        if option_name in PlaybackManager.PLAYBACK_OPTIONS:
            self.dbg( 'Setting {} to {}'.format(option_name, new_value) )
            try:
                cmds.playbackOptions( **{ option_name : new_value } )
                self.state.needs_restoring = True
            except Exception, ex:
                self.err( '--- Failed setting {} : {}'.format(option_name, ex) )
        else:
            super( PlaybackManager, self ).__setattr__(option_name, new_value)

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
