import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Scene Lint window support. Creates and manages a window that contains the results
from the sceneLint command as well as an interface that lets you apply the recommended
repairs for each potential problem.

Instantiate to create the window:

    from maya.debug.SceneLintWindow import SceneLintWindow
    scene_lint_window = SceneLintWindow()
    scene_lint_window.show_window()

Once the window is running it will shut down in the usual way. Due to the impossibility of
guaranteeing deletion on Python objects the window will stay alive if you delete or
reassign 'scene_lint_window' in the above. Holding on to the object is only meant to provide
a means of querying the window information.
'''

__all__ = ['SceneLintWindow']

import json
import maya.cmds as cmds
from functools import partial
from maya.common.ui import LayoutManager, setClipboardData, callback_tool

# Constants for the layout
STANDBY_COLOUR = [0.375, 0.375, 0.375]
ERROR_COLOUR   = [0.3, 0.1, 0.1]
OKAY_COLOUR    = [0.1, 0.3, 0.1]
READY_COLOUR   = [0.8, 0.6, 0.1]
RESULTS_ERRORS = maya.stringTable['y_SceneLintWindow.kSceneLintIssuesFound' ]
RESULTS_NONE   = maya.stringTable['y_SceneLintWindow.kSceneLintNoResults'   ]
RESULTS_OKAY   = maya.stringTable['y_SceneLintWindow.kSceneLintNoProblems'  ]
READY_TO_RUN   = maya.stringTable['y_SceneLintWindow.kSceneLintReadyToRun'  ]
SELECT_ALL     = maya.stringTable['y_SceneLintWindow.kSceneLintSelectAll'   ]
SELECT_NONE    = maya.stringTable['y_SceneLintWindow.kSceneLintSelectNone'  ]
BENEFIT        = maya.stringTable['y_SceneLintWindow.kSceneLintBenefit'     ]
DESCRIPTION    = maya.stringTable['y_SceneLintWindow.kSceneLintDescription' ]
CODE           = maya.stringTable['y_SceneLintWindow.kSceneLintCode'        ]
NO_CODE        = maya.stringTable['y_SceneLintWindow.kSceneLintNoCode'      ]
WINDOW_NAME    = 'SceneLintWindow'

# Constants from the sceneLint command
KEY_MAIN        = 'sceneLint'
KEY_MITIGATION  = 'mitigation'
KEY_BENEFIT     = 'benefit'
KEY_CODE        = 'code'
KEY_NAME        = 'name'
KEY_OBJECTS     = 'objects'
KEY_DESCRIPTION = 'description'

# Other dictionary keys
KEY_INFO         = '__INFO__'
KEY_LAYOUT       = '__LAYOUT__'
KEY_SELECT       = '__SELECT__'
KEY_TYPE         = '__TYPE__'
VALUE_CHECKBOX   = '__CHECKBOX__'
VALUE_TEXTSCROLL = '__TEXTSCROLL__'

#======================================================================

class SceneLintWindow(object):
    '''
    Class that manages the sceneLint UI. The window is an interface to the information
    provided by the sceneLint command, including the ability to run Python code it
    generates to help in optimizing a scene.

    :member all_issues_checkbox: Name of the "All" checkbox widget in the issue list
    :member issue_checkboxes:    {ISSUE_NAME: WIDGET} dictionary of checkbox widget names
    :member issue_descriptions:  {ISSUE_NAME: DESCRIPTION} dictionary of issue description strings
    :member issue_frame_layouts: {ISSUE_NAME: WIDGET} dictionary of issue frame layout widget names
    :member issue_results:       {ISSUE_NAME: MITIGATIONS} found by the most recent run, as
                                 defined by the sceneLint command. If an issue is missing then assume
                                 the test has not been run at all. If any mitigations are None then that
                                 specific issue test ran with no problems.
    :member issue_mitigation_widgets: { ISSUE_NAME : MITIGATION_WIDGETS } dictionary of widgets used to build up mitigation UI for an issue
                                            MITIGATION_WIDGETS = { KEY_LAYOUT|KEY_SELECT|KEY_INFO : WIDGET, KEY_TYPE : VALUE_CHECKBOX|VALUE_TEXTSCROLL }
                                                                 dictionary of widget information for the currently selected mitigation.
                                                                 KEY_LAYOUT:     The mitigation information layout control
                                                                 KEY_SELECT:     The selection widget (either a checkbox or a textScrollList)
                                                                 KEY_INFO:       The symbolButton widget to which the mitigation description is attached
                                                                 KEY_TYPE:       Which type of selection control is used. None means nothing is selectable
                                                                 KEY_MITIGATION: The mitigation dictionary to which the widget is attached
    :member script_job_id: ID of the job that is monitoring file read and new
    :member main_layout: UI name of the main layout inside the window (for rebuilding)
    :member window_name: UI name of main window
    '''
    def __init__(self):
        super( SceneLintWindow, self ).__init__()

        # Simple data
        self.issue_results = {}
        self.issue_mitigation_widgets = {}
        self.script_job_id = None
        # Get the dictionary of available issues and their descriptions.
        # The command returns an altering list of them for MEL compatibility so use that to
        # construct the dictionary.
        lint_info = cmds.sceneLint( query=True, verbose=True )
        self.issue_descriptions = dict( [[lint_info[i],lint_info[i+1]] for i in range(0,len(lint_info),2)] )

        # UI widgets
        self.window_name = None
        self.main_layout = None
        self.all_issues_checkbox = None
        self.issue_checkboxes = {}
        self.issue_frame_layouts = {}

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_run_selected_issues(tool):
        '''Callback invoked from the button to run the sceneLint command on the currently selected issues'''
        assert tool
        try:
            issue_list = []

            # If All issues are selected the command can run with no parameters
            if cmds.checkBox(tool.all_issues_checkbox, query=True, value=True):
                issue_list = tool.issue_descriptions.keys()
                tool.issue_results = cmds.sceneLint()

            # Otherwise pass in the list of currently selected issues
            else:
                for (issue_name, issue_widget) in tool.issue_checkboxes.iteritems():
                    if cmds.checkBox(issue_widget, query=True, value=True):
                        issue_list.append( issue_name )
                tool.issue_results = cmds.sceneLint( issueType=issue_list )

            tool.issue_results = json.loads( tool.issue_results )[KEY_MAIN]

            # Flag successful checks in the results with an empty list rather than omission from the list.
            # The latter means the issue did not run.
            for issue_name in issue_list:
                if issue_name not in tool.issue_results:
                    tool.issue_results[issue_name] = {}

        except (ValueError,KeyError), ex:
            tool.err( maya.stringTable['y_SceneLintWindow.kSceneLintParseError' ].format( ex ) )
            tool.issue_results = {}

        tool.populate_issue_results()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_clear_results(tool):
        '''
        Callback invoked from the button to clear the current results.
        Does not change the selection status of any of the results.
        '''
        assert tool
        tool.issue_results = {}
        tool.populate_issue_results()

    #----------------------------------------------------------------------
    def get_mitigation_code(self, issue_name):
        '''
        Utility to take the given issue with repair code and construct the
        full code including the loop over all selected items (if applicable).

        This loops over all potential mitigations to allow for combinations
        of different mitigations on different objects to be selected.

        It does not try to filter multiple mitigations applied to the same
        object as that may be intentional in some cases.

        :param issue_name: Name of the lint issue under which the mitigation appears
        :return: The string implementing the code that fixes the selected objects for this mitigation
        '''
        assert issue_name in self.issue_results
        # If no results then the issue is clean
        if len(self.issue_results[issue_name]) == 0:
            return 'pass'

        try:
            widgets = self.issue_mitigation_widgets[issue_name]
            assert KEY_MITIGATION in widgets

            if KEY_SELECT not in widgets:
                # No selection option means there is no code to apply
                complete_code = u'print "{}"'.format( NO_CODE )
            else:
                assert KEY_NAME in widgets[KEY_MITIGATION]
                mitigation_name = widgets[KEY_MITIGATION][KEY_NAME]

                assert KEY_CODE in widgets[KEY_MITIGATION]
                mitigation_code = widgets[KEY_MITIGATION][KEY_CODE]

                complete_code = ''
                if widgets[KEY_TYPE] == VALUE_CHECKBOX:
                    # Checkbox means the code is globally applied if the selection is made
                    if cmds.checkBox( widgets[KEY_SELECT], query=True, value=True ):
                        complete_code = mitigation_code
                    else:
                        complete_code = u'print "{}"'.format( maya.stringTable['y_SceneLintWindow.kSceneLintNotFixing' ].format( issue_name, mitigation_name ) )
                elif widgets[KEY_TYPE] == VALUE_TEXTSCROLL:
                    object_list = cmds.textScrollList( widgets[KEY_SELECT], query=True, selectItem=True )
                    # Only add this mitigation's code if it has selected objects
                    if object_list is None:
                        complete_code = u'print "{}"'.format( maya.stringTable['y_SceneLintWindow.kSceneLintNothingSelected' ].format( issue_name, mitigation_name ) )
                    else:
                        complete_code += u'OBJECTS = [{}]\n'.format( ','.join([u'"{}"'.format(obj) for obj in object_list]) )
                        complete_code += mitigation_code
            return complete_code

        except Exception, ex:
            # If an error occurs then generate empty code and show the problem
            cmds.warning( maya.stringTable['y_SceneLintWindow.kSceneLintCodeError' ].format( issue_name, ex ) )
            return 'pass'

    #----------------------------------------------------------------------
    def fix_selected_results(self, issue_name):
        '''
        Apply the selected fixes for the given issue
        :param issue_name: Name of the lint issue under which the mitigation appears
        '''
        try:
            fix_code = self.get_mitigation_code( issue_name )
            exec( fix_code )
            # After a fix is successfully applied the issue needs to be cleared
            del self.issue_results[issue_name]
            self.populate_issue_results()
        except Exception, ex:
            cmds.warning( maya.stringTable['y_SceneLintWindow.kSceneLintApplyError' ].format( issue_name, ex, fix_code ) )

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_apply_fixes(tool):
        '''
        Callback invoked from the button to apply all fixes on selected issues.
        Runs through all of the available issues and tries to apply the fixes
        for them, one at a time.

        If any one issue fix fails then a warning message will be printed and
        the processing will continue. No attempt is made to reorder the fixes
        to make them all succeed.
        '''
        assert tool
        for (issue_name, issue_widget) in tool.issue_checkboxes.iteritems():
            if issue_name in tool.issue_results:
                if cmds.checkBox(issue_widget, query=True, value=True):
                    try:
                        tool.fix_selected_results( issue_name )
                    except Exception, ex:
                        tool.warn( maya.stringTable['y_SceneLintWindow.kSceneLintIssueFixFailed' ].format( issue_name, ex ) )

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_fix_selected_results(tool, issue_name):
        '''
        Callback invoked from the button to fix the current results.
        Filters what it will fix based first on which of the issues are
        selected, and second on which of the results found are themselves selected.
        :param issue_name: Name of the lint issue under which the mitigation appears
        '''
        assert tool
        tool.fix_selected_results( issue_name )

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_copy_fix_to_clipboard(tool, issue_name):
        '''
        Callback invoked from the button to fix the current results.
        Filters what it will fix based first on which of the issues are
        selected, and second on which of the results found are themselves selected.
        :param issue_name: Name of the lint issue under which the mitigation appears
        '''
        assert tool
        setClipboardData( tool.get_mitigation_code( issue_name ) )

    #----------------------------------------------------------------------
    def deselect_all_mitigation_objects(self, issue_name):
        '''
        Helper method to deselect all of the objects under a particular issue/mitigation combination
        :param issue_name: Name of the lint issue under which the mitigation appears
        '''
        # Ensure the widget is where and what we expect
        assert KEY_TYPE in self.issue_mitigation_widgets[issue_name]
        assert KEY_SELECT in self.issue_mitigation_widgets[issue_name]
        assert self.issue_mitigation_widgets[issue_name][KEY_TYPE] == VALUE_TEXTSCROLL

        try:
            cmds.textScrollList( self.issue_mitigation_widgets[issue_name][KEY_SELECT], edit=True, deselectAll=True )
        except KeyError, ex:
            cmds.warning( maya.stringTable['y_SceneLintWindow.kSceneLintErrorDeselectObjError' ].format( issue_name, ex ) )

    #----------------------------------------------------------------------
    def select_all_mitigation_objects(self, issue_name):
        '''
        Helper method to select all of the objects under a particular issue/mitigation combination
        :param issue: Name of the lint issue under which the mitigation appears
        '''
        # Ensure the widget is where and what we expect
        assert KEY_TYPE in self.issue_mitigation_widgets[issue_name]
        assert KEY_SELECT in self.issue_mitigation_widgets[issue_name]
        assert self.issue_mitigation_widgets[issue_name][KEY_TYPE] == VALUE_TEXTSCROLL

        try:
            for object_to_select in cmds.textScrollList( self.issue_mitigation_widgets[issue_name][KEY_SELECT], query=True, allItems=True ):
                cmds.textScrollList( self.issue_mitigation_widgets[issue_name][KEY_SELECT], edit=True, selectItem=object_to_select )
        except KeyError, ex:
            cmds.warning( maya.stringTable['y_SceneLintWindow.kSceneLintErrorSelectObjError' ].format( issue_name, ex ) )

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_deselect_all_mitigation_objects(tool, issue_name):
        '''
        Callback invoked from the checkbox to toggle off selection of all objects for a particular item's mitigation
        :param issue_name: Name of the lint issue under which the mitigation appears
        '''
        assert tool
        tool.deselect_all_mitigation_objects(issue_name)

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_select_all_mitigation_objects(tool, issue_name):
        '''
        Callback invoked from the checkbox to toggle on selection of all objects for a particular item's mitigation
        :param issue_name: Name of the lint issue under which the mitigation appears
        '''
        assert tool
        tool.select_all_mitigation_objects(issue_name)

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_select_mitigation(tool, issue_name, menu_group):
        '''
        Callback invoked from the optionMenuGrp for a particular issue mitigation list.
        Updates the mitigation information to match the new selection.
        :param issue_name: Name of the lint issue under which the mitigation appears
        :param menu_group: optionMenuGrp widget that changed
        '''
        assert tool
        mitigation_index = cmds.optionMenuGrp( menu_group, query=True, select=True ) - 1
        try:
            tool.build_mitigation_widgets( issue_name, tool.issue_results[issue_name][KEY_MITIGATION][mitigation_index] )
        except Exception, ex:
            tool.err( 'Failed to find mitigation info for {}/{} ({})'.format( issue_name, mitigation_index, ex ) )

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_select_all_issues(tool):
        '''Callback invoked from the checkbox to toggle on or off selection of all issues'''
        assert tool
        all_selected = cmds.checkBox(tool.all_issues_checkbox, query=True, value=True)
        for issue_widget in tool.issue_checkboxes.values():
            cmds.checkBox(issue_widget, edit=True, value=all_selected)

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_select_one_issue(tool):
        '''
        Callback invoked from the checkbox to toggle on or off selection on one issue.
        If all issues are now selected then turn on the all_selected checkbox. If any
        issues are unselected turn it off.
        '''
        assert tool
        all_selected = True
        for issue_widget in tool.issue_checkboxes.values():
            if not cmds.checkBox(issue_widget, query=True, value=True):
                all_selected = False
                break
        cmds.checkBox(tool.all_issues_checkbox, edit=True, value=all_selected)

    #----------------------------------------------------------------------
    def populate_issue_results(self):
        '''
        Update the status of all of the sceneLint issues.
        Issue results have these different states:
            - Idle (Not Run and Not Selected)
            - Ready (Not Run and Selected)
            - Okay (Run and no issues found)
            - Error (Run and some issues found)

        if the results are None then no issues have been run:
            Idle/Ready
        else if an issue is not in the results:
            Idle/Ready
        else if the issue results are None:
            Okay
        else if the issue results are {}:
            Okay
        else:
            Error

        If the results are None then all issues are in the "Not Run" state.
"nurbs-tessellation": {
            "description": "Ensure NURBS are tessellated efficiently.",
            "mitigation": [
                {
                    "name": "enable-aruba",
                    "description": "Load the 'Aruba' plug-in to handle the tessellation.",
                    "benefit": "Increases the speed at which NURBS curves and surfaces are tessellated for drawing.",
                    "code": "import maya.cmds as cmds\ncmds.loadPlugin('ArubaTessellator')\n"
                }
            ]
        },
        '''
        for (issue_name, issue_widget) in self.issue_checkboxes.iteritems():

            # Only update the ones that ran
            if not cmds.checkBox(issue_widget, query=True, value=True):
                continue

            if issue_name in self.issue_results:
                if KEY_MITIGATION in self.issue_results[issue_name]:
                    mitigations = self.issue_results[issue_name][KEY_MITIGATION]
                else:
                    mitigations = []
            else:
                mitigations = None

            self.__update_issue_frame( issue_name, self.issue_descriptions[issue_name], mitigations )

    #----------------------------------------------------------------------
    def __build_window_buttons(self):
        '''
        Create the main action buttons in the window, laid out across a row

            +-----+  +-------+  +-------+
            | Run |  | Clear |  | Apply |
            +-----+  +-------+  +-------+
        '''
        with LayoutManager( cmds.rowLayout( numberOfColumns=3
                                          , columnAttach3=('right','both','left')
                                          , columnOffset3=(10,10,10) ) ):
            cmds.button( label=maya.stringTable['y_SceneLintWindow.kSceneLintRunSelected' ],             command=callback_tool(self, self.__callback_run_selected_issues) )
            cmds.button( label=maya.stringTable['y_SceneLintWindow.kSceneLintClearResults'],            command=callback_tool(self, self.callback_clear_results) )
            cmds.button( label=maya.stringTable['y_SceneLintWindow.kSceneLintApplyFixes'  ], command=callback_tool(self, self.__callback_apply_fixes) )

    #----------------------------------------------------------------------
    def __build_issue_fix_buttons(self, issue_name):
        '''
        Builds the buttons to apply all selected fixes on the given issue, or copy the fix code to
        the clipboard.
            +-------+  +------+
            | Apply |  | Copy |
            +-------+  +------+
        '''
        with LayoutManager( cmds.rowLayout( numberOfColumns=4
                                          , adjustableColumn=4
                                          , columnAlign4=('center','center','center','left')
                                          , columnAttach4=('right','both','both','left') ) ):
            cmds.button( label=maya.stringTable['y_SceneLintWindow.kSceneLintButtonApplyFixLabel' ]
                       , annotation=maya.stringTable['y_SceneLintWindow.kSceneLintApplFixAnnotation' ]
                       , width=50
                       , command=callback_tool(self, partial(self.__callback_fix_selected_results, issue_name=issue_name)) )
            cmds.text( label=maya.stringTable['y_SceneLintWindow.kSceneLintFixOr' ] )
            cmds.button( label=maya.stringTable['y_SceneLintWindow.kSceneLintCopyCode' ]
                       , annotation=maya.stringTable['y_SceneLintWindow.kSceneLintCopyCodeAnnotation' ]
                       , width=50
                       , command=callback_tool(self, partial(self.__callback_copy_fix_to_clipboard, issue_name=issue_name) ) )

            cmds.text( label=maya.stringTable['y_SceneLintWindow.kSceneLintFixButtonText' ] )

    #----------------------------------------------------------------------
    def build_mitigation_widgets( self, issue_name, mitigation ):
        '''
        Build the widget that allows the user to select any number of objects on the mitigation
        object list.
        :param issue_name: Name of the issue to which this mitigation applies
        :param mitigation: Dictionary of information data.
                KEY_NAME        (mandatory)  Short name of the mitigation
                KEY_DESCRIPTION (mandatory)  Description of what it does
                KEY_BENEFIT     (mandatory)  Benefit applying the fix should bring
                KEY_CODE        (optional)   Code to apply the fix automatically
                KEY_OBJECTS     (optional)   Objects to pass to the code
        '''
        # Ensure the information required is available
        assert KEY_NAME in mitigation
        assert KEY_DESCRIPTION in mitigation
        assert KEY_BENEFIT in mitigation

        mitigation_description = mitigation[KEY_DESCRIPTION]
        mitigation_benefit = mitigation[KEY_BENEFIT]

        widgets = self.issue_mitigation_widgets[issue_name]
        assert KEY_LAYOUT in widgets
        assert KEY_INFO in widgets

        # When building the widget the mitigation is by definition the active one
        widgets[KEY_MITIGATION] = mitigation

        # Update the annotation on the button containing the mitigation description
        try:
            info = u'{}\n{}'.format( mitigation_description, mitigation_benefit )
        except KeyError:
            info = maya.stringTable[ 'y_SceneLintWindow.kSceneLintNoDescription'  ]
        cmds.symbolButton( widgets[KEY_INFO], edit=True, annotation=info )

        # Make sure if we're rebuilding the widget that the old children are deleted first
        try:
            issue_children = cmds.layout( widgets[KEY_LAYOUT], query=True, childArray=True )
            for issue_child in issue_children or []:
                cmds.deleteUI( issue_child )
        except RuntimeError:
            pass

        # This is a simple columnLayout
        cmds.setParent( widgets[KEY_LAYOUT] )   # This will work both for an enclosed LayoutManager and independent calling
        with LayoutManager( widgets[KEY_LAYOUT] ):

            # If there is no mitigation code then the description is all there is,
            # containing information on either manual intervention steps or a
            # description of why the issue could not be fully explored.
            #
            #  +-------------+ +-----------------+
            #  | Description | | No Code Message |
            #  +-------------+ +-----------------+
            #
            mitigation_code = mitigation.get( KEY_CODE, '' )
            if len(mitigation_code) == 0:
                widgets[KEY_SELECT] = None
                widgets[KEY_TYPE] = None
                cmds.text( label=mitigation_description )
                cmds.text( align='left', backgroundColor=STANDBY_COLOUR, label=NO_CODE )
                return

            # If there are no objects then only a single checkbox is needed for this mitigation,
            # and it should be labeled differently than from the one that selects all objects
            #
            #  +---+ +-----------------+
            #  | X | | Select Request  |
            #  +---+ +-----------------+
            #
            mitigation_objects = mitigation.get( KEY_OBJECTS, [] )
            if len(mitigation_objects) == 0:
                widgets[KEY_SELECT] = cmds.checkBox( label=maya.stringTable['y_SceneLintWindow.kSceneLintSelectNoObjectMitigation'], value=True )
                widgets[KEY_TYPE] = VALUE_CHECKBOX
                return

            # With multiple objects a selection list so that the user can decide on which objects
            # to apply the fix.
            #
            #  +-------------+ +-----------------+
            #  | Select All  | | Object List     |
            #  +-------------+ |                 |
            #                  |                 |
            #  +-------------+ |                 |
            #  | Select None | |                 |
            #  +-------------+ |                 |
            #                  |                 |
            #                  +-----------------+
            #
            with LayoutManager( cmds.rowLayout( numberOfColumns=2
                                              , adjustableColumn=2
                                              , rowAttach=[(1,'both',0),(2,'top',0)]
                                              , columnAttach=[(1,'right',5), (2,'both',5)] ) ):

                with LayoutManager( cmds.columnLayout( rowSpacing=5 ) ):
                    # Select All and Select None will affect the selections in the textScrollList
                    cmds.button( width=50, label=SELECT_ALL
                               , command=callback_tool(self, partial(self.__callback_select_all_mitigation_objects, issue_name=issue_name)) )
                    cmds.button( width=50, label=SELECT_NONE
                               , command=callback_tool(self, partial(self.__callback_deselect_all_mitigation_objects, issue_name=issue_name)) )

                with LayoutManager( cmds.columnLayout( rowSpacing=5
                                                     , backgroundColor=(0.0,0.0,0.0) ) ):
                    # Display objects in a fixed size textScrollList
                    widgets[KEY_TYPE] = VALUE_TEXTSCROLL
                    widgets[KEY_SELECT] = cmds.textScrollList( numberOfRows=8
                                                             , allowMultiSelection=True
                                                             , append=mitigation_objects )
                    # Start with all objects selected
                    for object_to_select in cmds.textScrollList( widgets[KEY_SELECT], query=True, allItems=True ):
                        cmds.textScrollList( widgets[KEY_SELECT], edit=True, selectItem=object_to_select )

    #----------------------------------------------------------------------
    def __build_mitigation_section(self, issue_name, mitigation_list):
        '''
        Builds a layout comprising all of the mitigation information. Assumes that the
        parent widget context is currently active.

             +---+            +------------+
             | i |   Fix Type | MITIGATION |
             +---+            +------------+

             +--------------------------------------------+
             |                                            |
             |  Mitigation Selection Section              |
             |                                            |
             +--------------------------------------------+

             +--------------------------------------------+
             |                                            |
             |  Button section                            |
             |                                            |
             +--------------------------------------------+

        If there are more than one possible mitigations then a selection is offered:
            MITIGATION = Dropdown Menu
        otherwise it is hardcoded
            MITIGATION = Text "is MITIGATION_NAME"

        [i] indicates an information icon, whose annotation shows information about the
        mitigation.

        Mitigation Selection Section: Contains anything needed to select parts of the mitigation
        for application as a fix.

        Button Section: Contains buttons with operations to perform with the mitigation

        :param issue_name: Name of the issue whose frame is to be built
        :param mitigation_list: List of dictionary of mitigation information.
        '''
        # Empty out any object list widgets remembered for this issue's mitigations as they have just been deleted.
        self.issue_mitigation_widgets[issue_name] = {}
        first_mitigation = mitigation_list[0]

        try:
            self.issue_mitigation_widgets[issue_name] = {}
            with LayoutManager(cmds.columnLayout( adjustableColumn=True )):
                with LayoutManager( cmds.rowColumnLayout( adjustableColumn=3
                                                        , numberOfColumns=3
                                                        , rowSpacing=(1,5)
                                                        , columnAlign=[(1,'center'), (2,'right'), (3, 'left')]
                                                        , columnAttach=[(1, 'right', 10), (2, 'both', 5), (3, 'left', 5)] ) ):
                    self.issue_mitigation_widgets[issue_name][KEY_MITIGATION] = first_mitigation
                    self.issue_mitigation_widgets[issue_name][KEY_INFO] = cmds.symbolButton( image='info.png', annotation='' )
                    if len(mitigation_list) > 1:
                        cmds.text( label=maya.stringTable['y_SceneLintWindow.kSceneLintSelectFixType' ] )
                        menu_group = cmds.optionMenuGrp()
                        cmds.optionMenuGrp( menu_group, edit=True, changeCommand=callback_tool(self, partial(self.__callback_select_mitigation, issue_name=issue_name, menu_group=menu_group) ) )
                        for mitigation in mitigation_list:
                            cmds.menuItem( label=mitigation[KEY_NAME], annotation=mitigation[KEY_DESCRIPTION] )
                        cmds.optionMenuGrp( menu_group, edit=True, select=1 )
                    else:
                        cmds.text( label=maya.stringTable['y_SceneLintWindow.kSceneLintOneFixType' ].format( first_mitigation[KEY_NAME] ), annotation=first_mitigation[KEY_DESCRIPTION] )
                        cmds.text( label='' )

                cmds.separator( height=10, style='none' )

                self.issue_mitigation_widgets[issue_name][KEY_LAYOUT] = cmds.columnLayout( adjustableColumn=True
                                                                                         , columnAlign='left'
                                                                                         , rowSpacing=5 )

                self.build_mitigation_widgets( issue_name, first_mitigation )

                cmds.separator( height=10, style='none' )

                self.__build_issue_fix_buttons( issue_name )

        except KeyError:
            cmds.text( parent=self.issue_frame_layouts[issue_name], label=maya.stringTable['y_SceneLintWindow.kSceneLintNoMitigation' ] )

    #----------------------------------------------------------------------
    @staticmethod
    def __count_mitigation_objects(mitigations):
        '''
        :param mitigations: List of mitigation dictionaries
        :return: Number of unique objects found in mitigations
        '''
        objects_found = []
        for mitigation in mitigations:
            if KEY_OBJECTS in mitigation:
                objects_found += mitigation[KEY_OBJECTS]
            else:
                objects_found += [None]

        return len(set(objects_found))

    #----------------------------------------------------------------------
    def __update_issue_frame(self, issue_name, issue_description, issue_mitigations):
        '''
        Update the frameLayout of an issue, tailored to its current status:

            1. Not run - grey non-collapsible frame with "Not Run" as the status
                +------------------------------+
                | ISSUE NAME (Not Run)         |
                +------------------------------+

            2. Run with no issues - green non-collapsible frame with "okay" as the status
                +------------------------------+
                | ISSUE NAME (Not Run)         |
                +------------------------------+

            3. Run with some issues - red collapsible frame with the number of issues found as the status
                Inside the frame is a list of potential mitigations in their own frames (see
                __build_mitigation_section for their format).
                +---------------------------------+
                | v  ISSUE NAME (## Issues Found) |
                +---------------------------------+
                    +--------------------------------------------+
                    |    MITIGATION SECTION                      |
                    +--------------------------------------------+

        :param issue_name: Name of the issue whose frame is to be built
        :param issue_description: Description of the issue whose frame is to be built
        :param issue_mitigations: List with the issue run result information in it. An empty
                                  list means the issue ran but no problems were found.
                                  Otherwise it will contain a list of mitigations that can
                                  be applied to fix the issue's problems.
        '''

        # If the issue already has a frame then empty out the children to build the new one
        if issue_name in self.issue_frame_layouts:
            issue_children = cmds.frameLayout( self.issue_frame_layouts[issue_name], query=True, childArray=True )
            for issue_child in issue_children or []:
                cmds.deleteUI( issue_child )
        # Otherwise create a blank frame for it
        else:
            self.issue_frame_layouts[issue_name] = cmds.frameLayout( label=RESULTS_NONE.format(issue_name)
                                                                   , annotation=issue_description
                                                                   , collapsable=False
                                                                   , backgroundColor=STANDBY_COLOUR )

        with LayoutManager( self.issue_frame_layouts[issue_name] ):
            if issue_mitigations is None:
                # With no results just reset the frame
                cmds.frameLayout( self.issue_frame_layouts[issue_name], edit=True
                                , collapsable=False
                                , label=RESULTS_NONE.format(issue_name)
                                , backgroundColor=STANDBY_COLOUR )
            elif len(issue_mitigations) == 0:
                # With no problems status goes green and no further UI is needed
                cmds.frameLayout( self.issue_frame_layouts[issue_name], edit=True
                                , collapsable=False
                                , label=RESULTS_OKAY.format(issue_name)
                                , backgroundColor=OKAY_COLOUR )
            else:
                # With some problems status goes red and mitigation information is added in collapsible frame
                cmds.frameLayout( self.issue_frame_layouts[issue_name], edit=True
                                , label=RESULTS_ERRORS.format(issue_name, self.__count_mitigation_objects(issue_mitigations))
                                , collapsable=True
                                , collapse=True
                                , backgroundColor=ERROR_COLOUR )

                cmds.setParent( self.issue_frame_layouts[issue_name] )
                with LayoutManager( cmds.columnLayout( adjustableColumn=True, columnOffset=('left',30) ) ):
                    self.__build_mitigation_section( issue_name, issue_mitigations )

    #----------------------------------------------------------------------
    def __build_issue_frame(self, issue_name, issue_description):
        '''
        Builds an empty frame for an issue. Initially the frame will be non-collapsable and
        contain no children. __update_issue_frame will later populate it with results of the
        runs.
        :param issue_name: Name of the issue whose frame is to be built
        :param issue_description: Description of the issue whose frame is to be built
        '''
        self.__update_issue_frame( issue_name, issue_description, None )

    #----------------------------------------------------------------------
    def __build_issue_widgets(self):
        '''
        Create the list of checkboxes and frameLayouts that will encapsulate
        the information for each isse to be checked.

            +---+  +------------------------------+
            | X |  | ISSUE NAME (ISSUE STATUS)    |
            +---+  +------------------------------+

        Initially the issue frame will not be collapsible and will contain
        only the name of the issue with "(Not Run)" as the status. As the
        issue state changes the frame will be updated accordingly.
        '''

        row_attachment = [(1, 'top', 0)]
        for issue_count in range(0, len(self.issue_descriptions.keys())):
            row_attachment.append( (issue_count+2, 'top', 0) )

        with LayoutManager( cmds.rowColumnLayout( numberOfColumns=2, adjustableColumn=2
                                                , columnAttach=[(1,'right',5), (2,'both',5)]
                                                , rowAttach=row_attachment
                                                , rowSpacing=(1,5) ) ):

            # The first row will be special with the text "All" appearing and no frame.
            # This is a UI element that enables the user to toggle on and off the selection
            # of all issues in the list.
            self.all_issues_checkbox = cmds.checkBox( label='', value=True
                                                    , changeCommand=callback_tool(self, self.__callback_select_all_issues) )
            cmds.text( label=SELECT_ALL, font='obliqueLabelFont', align='left' )

            # Walk all of the issues, adding in a checkbox and empty frame for each
            for issue_name, issue_description in self.issue_descriptions.iteritems():
                # The issue test
                self.issue_checkboxes[issue_name] = cmds.checkBox( label='', value=True
                                                                , changeCommand=callback_tool(self, partial(self.__callback_select_one_issue)) )

                self.__build_issue_frame( issue_name, issue_description )

    #----------------------------------------------------------------------
    def __build_window(self):
        '''
        Create the main window and frames within it.  Creates the initial
        list of available lint checks, with an empty section for reported
        problems to be populated later.
        '''
        if self.window_name is None:
            if cmds.window(WINDOW_NAME, exists=True):
                cmds.deleteUI( WINDOW_NAME )
            self.window_name = cmds.window( WINDOW_NAME
                                          , title=maya.stringTable['y_SceneLintWindow.kSceneLintTitle' ]
                                          , iconName=maya.stringTable['y_SceneLintWindow.kSceneLintIconName' ]
                                          , closeCommand=callback_tool(self, self.__callback_close_window)
                                          )
            self.script_job_id = cmds.scriptJob( event=['deleteAll',callback_tool(self, self.__callback_delete_all)] )

        # Easiest way to build an already existing window is to blow away the contents and rebuild
        if self.main_layout is not None:
            cmds.deleteUI( self.main_layout )

        # The main layout is a scrollable list to allow arbitrariliy long lists of issue types.
        # The action buttons are at the top since they are the most frequently accessed operations
        self.main_layout = cmds.scrollLayout( parent=self.window_name, childResizable=True )
        with LayoutManager(self.main_layout):
            with LayoutManager( cmds.columnLayout( columnAlign='center', adjustableColumn=True ) ):
                self.__build_window_buttons()
                cmds.separator( height=10, style='in' )
                self.__build_issue_widgets()

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_delete_all( tool ):
        '''
        Callback invoked when the file is new'd or loaded. Clears out the results.
        '''
        tool.callback_clear_results( tool )

    #----------------------------------------------------------------------
    @staticmethod
    def __callback_close_window( tool ):
        '''
        Callback invoked when the window is closed. Stops monitoring for deleteAll events
        '''
        if tool.script_job_id is not None:
            cmds.scriptJob( kill=tool.script_job_id )

    #----------------------------------------------------------------------
    def show_window(self):
        '''
        If the window already exists then pop it up, otherwise create it
        and then pop it up. The window's contents are not sync'd with the
        outside world so it's possible to have references to files or
        directories that no longer exist in the window.

        Returns the name of the window.
        '''
        # If calling this for the first time then build the window.
        if self.window_name is None or not cmds.window( self.window_name, exists=True ):
            self.window_name = None
            self.__build_window()

        cmds.showWindow( self.window_name )
        return self.window_name

# ===========================================================================
# Copyright 2018 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
